<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualisation de Graphe avec Sigma.js</title>

 <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
	
  
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/sigma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/plugins/sigma.layout.forceAtlas2.min.js"></script>

 <script src="./bundle.js"></script>
 
 <script>
window.addEventListener("load", function () {
    console.log("üìå V√©rification apr√®s chargement complet des scripts...");

    console.log("üìå V√©rification de sigma :", window.sigma);
    console.log("üìå V√©rification de forceatlas2 :", window.forceAtlas2);
    console.log("üìå V√©rification de graphology :", window.graphology);
    console.log("üìå V√©rification de pandemonium :", window.pandemonium);
    console.log("üìå V√©rification de graphology-indices :", window.graphologyIndices);
    console.log("üìå V√©rification de graphology-communities-louvain :", window.graphologyCommunitiesLouvain);
});
</script>
 
  <link rel="icon" href="data:,">
 
<!-- STYLE----------------------------------------------------------------------------------------------------- -->
 <style>
 
.container {
    display: flex;
    justify-content: space-between;
    align-items: stretch;  /* ‚úÖ Toutes les colonnes prennent la m√™me hauteur */
    height:90vh;  /* ‚úÖ Utilise toute la hauteur de l'√©cran */
}

/* ‚úÖ Colonne de gauche */
#left-panel {
    width: 250px;
    padding: 1px;
    border-right: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}


/* ‚úÖ Colonne de droite */
#right-panel {
    width: 250px;
    padding: 1px;
    border-left: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

/* ‚úÖ Zone du graphe - Ajuste la hauteur automatiquement */
#graph-container {
    flex-grow: 1;
	max-height:100vh;  /* ‚úÖ Permet au graphe de prendre la m√™me hauteur que les colonnes */
    border: 1px solid #ccc;
    background: #f9f9f9;
    display: flex;
    align-items: stretch;  /* ‚úÖ Ajuste le graphe √† la hauteur de son parent */
	position: relative; /* ‚úÖ Cette ligne est essentielle pour que les enfants absolus s‚Äôalignent par rapport √† lui */
    overflow: hidden;    /* ‚úÖ Pour √©viter les d√©bordements */
}

/* ‚úÖ Style du conteneur de recherche */
#search-container {
    padding: 5px;
    border: 2px solid #ddd;
    background: #f9f9f9;
    margin-bottom: 4px;
    border-radius: 2px;
	position: relative
}


/* ‚úÖ Style de la zone de saisie et du bouton */
#node-search {
    width: 90%;
    padding: 6px;
    margin-bottom: 5px;
    border: 2px solid #ccc;
    border-radius: 4px;
}

#search-node-btn {
    width: 90%;
    padding: 6px;
    font-size: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#search-node-btn:hover {
    background-color: #2980b9;
}

#search-initial-btn  {
    width: 90%;
    padding: 6px;
    font-size: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#search-initial-btn:hover {
    background-color: #2980b9;
}


/* ‚úÖ Liste des r√©sultats de recherche */
#search-results {
    list-style-type: none;
    padding: 0;
    margin: 5px 0;
    max-height: 100px;
    overflow-y: auto;
    border: 1px solid #ccc;
    background: white;
    border-radius: 4px;
}

#search-results li {
    padding: 8px;
    cursor: pointer;
    transition: background 0.3s;
    border-bottom: 1px solid #ddd;
}

#search-results li:hover {
    background: #f1f1f1;
}


#info-text {
    flex-grow: 1;
    overflow-y: auto;
    max-height: 110px;
    max-width: 230px;
    word-wrap: break-word;
    padding: 10px;
    border: 1px solid #ccc; /* ‚úÖ Bordure pour d√©marquer */
    background: #f9f9f9; /* ‚úÖ Fond clair */
    border-radius: 4px; /* ‚úÖ Arrondi des coins */
	margin-bottom: 5px;  /* ‚úÖ Ajoute de l'espace sous cette zone */
}


#info-buttons {
    display: flex;
    flex-direction: column;
    gap: 5px;  /* ‚úÖ Espacement entre les boutons */
	margin-bottom: 6px; 
    padding-top: 10px; /* ‚úÖ Ajoute de l‚Äôespace au-dessus des boutons */
}

button {
    width: 90%;  
    padding: 10px;
    font-size: 12px;
    background-color: #3498db; 
    color: white;
    border: none;
    border-radius: 4px; 
    cursor: pointer;
    transition: background 0.3s ease;
	margin-bottom: 10px;  /* Augmente l'espacement sous chaque bouton */
}


/* Effet au survol */
button:hover {
    background-color: #2980b9;
}


#show-neighbors-btn {
    width: 100%;
    padding: 5px;
    font-size: 12px;
    background-color:  #ff9933  ; /* ‚úÖ synonymes  */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#show-neighbors-btn:hover {
    background-color: #d35400;
}

#show-neighbors-btn:disabled {
    background-color: #bdc3c7; /* ‚úÖ Gris quand d√©sactiv√© */
    cursor: not-allowed;
}

#show-syno2-btn {
    width: 100%;
    padding: 8px;
    font-size: 12px;
    background-color: #e67e22  ; /* ‚úÖ syno2*/
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#show-syno2-btn:hover {
    background-color:  #d35400;
}

#show-syno2-btn:disabled {
    background-color: #bdc3c7; /* ‚úÖ Gris quand d√©sactiv√© */
    cursor: not-allowed;
}

#show-adjacency-btn {
    width: 100%;
    padding: 8px;
    font-size: 12px;
    background-color: #b35900; /* ‚úÖ  bouton adjacence */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
	margin-bottom: 1px;
}

#show-adjacency-btn:hover {
    background-color: #d35400;
}

#show-adjacency-btn:disabled {
    background-color: #bdc3c7; /* ‚úÖ Gris quand d√©sactiv√© */
    cursor: not-allowed;
}

#graph-management {
    padding: 10px;
    border: 4px solid #2980b9;  /* ‚úÖ Bordure √©paisse bleue */
    border-radius: 8px;  /* ‚úÖ Coins arrondis */
    background: #f9f9f9;  /* ‚úÖ Fond clair */
    text-align: center;
    margin-top: 1px;
}

#graph-management h3 {
    margin-top: 0;
    font-size: 12px;
    color: #2980b9;
}
#community-legend {    /* COMMUNAUTES */
    width: auto;
    max-width: 115px; /* ‚úÖ R√©duit la largeur du cadre pour 1 colonne */
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* ‚úÖ Meilleur alignement √† gauche */
    padding: 5px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    position:  relative;
    top: 1px;
	left : 1px ;
    z-index: 10;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
}

/* ‚úÖ Conteneur des pastilles avec 2 colonnes */
#community-items {  
	display: flex;
    flex-wrap: wrap;
    max-height: 500px;
    overflow-y: auto;
    gap: 5px;
   justify-content: space-between;
}

/* ‚úÖ √âl√©ments de la l√©gende (adapt√©s pour 2 colonnes) */
.legend-item {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    transition: all 0.3s ease-in-out;
    width: calc(50% - 10px); /* ‚úÖ Deux colonnes maximum */
    min-width: 90px;
}



/* ‚úÖ Pastille de couleur */
.color-dot {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    transition: transform 0.2s ease-in-out;
}

/* ‚úÖ Effet zoom au survol */
.legend-item:hover .color-dot {
    transform: scale(1.2);
}

/* ‚úÖ Labels des communaut√©s */
.legend-label {
    font-size: 14px;
    font-weight: bold;
}

/* ‚úÖ Style du bouton "Toutes Communaut√©s" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
}

.show-all-button:hover {
    background-color: #2980b9;
}

#hide-legend-zone {
    width: 80%;
    text-align: center;
    padding: 5px;
    background: #a3a3c2;
    color: white;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
}

#hide-legend-zone:hover {
    background: #c0392b;
}

#show-legend-btn {
    padding: 5px;
    background: #2ecc71;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    display: none;
}

#hide-legend-btn {
    width: 100%;
    margin-top: 10px;
    padding: 5px;
    background-color: #bdc3c7;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#hide-legend-btn:hover {
    background-color:  #a3a3c2;
}

#connected-components-legend {  /* CONNEXES */
    width: auto;
    max-width:180px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    padding: 5px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    position: relative;        
    top: 1px;              /* ‚úÖ d√©calage depuis le haut de la page */
    left: 1px;
    z-index: 10 ;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
	/*  hauteur fixe + scroll */
    max-height: 500px;
    overflow-y: auto;
	 overflow-x: hidden;
	
}

#connected-components-legend .legend-item {
    width: 100% !important;
    min-width: 100px !important;
    box-sizing: border-box;
}


/* ‚úÖ Conteneur   */
#legend-items {
	display: flex;
    flex-wrap: wrap;
    max-height: 500px;
    overflow-y: auto;
    gap: 5px;
    justify-content: space-between;
}

/* ‚úÖ Chaque pastille prend la moiti√© de la ligne = 2 colonnes */
.legend-item {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    transition: all 0.3s ease-in-out;
    width: calc(50% - 10px); 
    min-width: 90px;
    box-sizing: border-box; /* ‚úÖ Pour une meilleure coh√©rence d‚Äôaffichage */
}

/* ‚úÖ Pastilles */
.color-dot {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    border: 1px solid #000;
    transition: transform 0.2s ease-in-out;
}

/* ‚úÖ Zoom au survol */
.legend-item:hover .color-dot {
    transform: scale(1.2);
}

.legend-label {
    font-size: 14px;
    font-weight: bold;
}

/* ‚úÖ Style du bouton "Toutes Composantes" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db; /* ‚úÖ Bleu Sigma.js */
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
}

.show-all-button:hover {
    background-color: #2980b9; /* ‚úÖ Bleu fonc√© au survol */
}

/* ‚úÖ Bouton "TOUTES Communaut√©s" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
    width: 100%;
}

.show-all-button:hover {
    background-color: #2980b9;
}

/* ‚úÖ Bouton "Masquer" */
.hide-legend-button {
    margin-top: 5px;
    background-color: #bdc3c7;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
    width: 100%;
	 display: block; /* ‚úÖ Assurer qu'il est bien affich√© */
}

.hide-legend-button:hover {
    background-color: #e74c3c; /* ‚úÖ Rouge au survol */
}

#graph-stats-display {
    position: absolute;
    top: 1px;
    left: 1px;
    background-color: rgba(255, 255, 255, 0.85);
    padding: 4px 8px;
    font-size: 12px;
    border-radius: 4px;
    font-weight: bold;
    z-index: 10;
    border: 1px solid #ccc;
}

 /* ‚úÖ Style pour la notification */
.graph-notification {
    position: absolute;
    top: 5px;
    left: 400px;
    background-color: #33cc33;
    color: #336600;
    border: 2px solid #ccc;
    padding: 8px 12px;
    border-radius: 5px;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    font-size: 14px;
    z-index: 9999;
    display: none;
    max-width: 300px;
}
#graph-message {
  position: fixed;
  top: 60px;
  left: 60px;
  max-width: 400px;
  max-height: 600px;
  overflow-y: auto;
  background-color: #99ddff;
  border: 1px solid #ccc;
  padding: 10px;
  font-size: 14px;
  color: #333;
  z-index: 3000;
  border-radius: 6px;
  box-shadow: 0 0 10px rgba(0,0,0,0.2);
}

#btn-mode-chemin {
  background-color: #ff9933;
  color: white;
  border: none;
  padding: 6px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 12px;
  transition: background 0.3s ease-in-out;
  margin-top: 10px;
}

#btn-mode-chemin.active {
  background-color: #1bcc53;
  font-size: 12px;
}



  </style>
  <!-- FIN STYLE----------------------------------------------------------------------------------------------------- -->


</head>
<body>

 <h1>Graphe de synonymes ( 2217 adjectifs)</h1>

<!-- DIV----------------------------------------------------------------------------------------------------- -->

  <div class="container">
  
  <!-- ‚úÖ Colonne de gauche (Infos & Recherche par mot) -->
	<div id="left-panel"> 
		
		<div id="graph-management">
		<h3>Approche individuelle</h3>
		
			
			<div id="info-text">	 
			<p>Survoler ou Cliquez sur un n≈ìud pour voir les donn√©es associ√©es.</p>
			<p>Cliquer dans le graphe HORS des n≈ìuds pour les cacher.</p>
			<p>Zoom disponible</p>
			</div>
			
			<div id="search-container">
			<input type="text" id="node-search" placeholder="Rechercher un n≈ìud..." />
			<button id="search-initial-btn">Rechercher dans le graphe initial</button>
			<button id="search-node-btn">Rechercher dans le graphe affich√©</button>
			<ul id="search-results"></ul>
			</div>	
			
			<!-- ‚úÖ boutons pour afficher les graphes de la vedette -->
			<button id="show-neighbors-btn" title="Synonymes de rang 1 (voisins) du mot s√©lectionn√©" disabled>Synonymes 1</button>
			 
			<button id="show-adjacency-btn" title="Relations de synonymie entre les synonymes de rang 1 du mot s√©lectionn√©" disabled>Adjacence</button>	
			<div id="info-buttons"></div>
			
			<button id="show-syno2-btn" title="Synonymes de rang 1 (voisins, bleus) et 2 (oranges) du mot s√©lectionn√©" disabled>Synonymes 1 et 2</button>
			
			<button id="btn-mode-chemin"title="Affiche le chemin de synonymie, dans le graphe complet, entre 2 mots s√©lectionn√©s" >Chemin entre deux mots</button>
				 

		<h3>Approche globale</h3>
			<button id="completude-btn" title="Toutes les relations de synonymie entre les mots affich√©s" style=" background-color: #b35900;" >Compl√©tude</button>
			<button id="extension-btn" title="Ajout des synonymes de tous les mots affich√©s" style=" background-color: #ff9933;" >Extension</button>
			<button id="export-matrix-btn" title="Ce bouton cr√©e un tableau dont les cases (i,j) indiquent si les mots i et j affich√©s dans le graphe sont synonymes dans la base de synonymie compl√®te (graphe initial). Si les mots i et j sont synonymes, la case (i,j) qui les croise contient 1, m√™me s‚Äôils ne sont pas reli√©s dans le graphe affich√©. S‚Äôils ne sont pas synonymes, la case contient 0."  style=" background-color: #66ccff;" >Exporter matrice de synonymie</button>
			<button id="export-path-btn" title="Ce bouton cr√©e un tableau dont les cases (i,j) indiquent la distance (nombre minimum de liens pour aller d‚Äôun mot √† un autre) entre les mots i et j affich√©s, en utilisant tous les liens de synonymie de la base compl√®te (graphe initial). Si deux mots sont synonymes dans la base leur distance est 1 ; s‚Äôils sont reli√©s par un chemin de synonymie comportant d‚Äôautres (2, 3, n) mots interm√©diaires, la distance est 2, 3, n. S‚Äôil n‚Äôexiste aucun lien entre eux dans la base, la case contient -1."  style=" background-color: #66ccff;" >Exporter matrice des distances</button>
		</div>
		
	</div>

	
<!-- ‚úÖ Zone d'affichage du graphe -->	
	<div id="graph-container">
	
	
	<!-- ‚úÖ Notification plac√©e en haut √† gauche du conteneur -->
		<div id="graph-stats-display">0 points, 0 liens</div>
		
		<!-- ‚úÖ Notification plac√©e en haut √† droite du conteneur -->
		<div id="notification" class="graph-notification">Notification...</div>
	 
		<div id="graph-message" style="display: none;">
			<!-- le message sera inject√© ici par JS -->
		</div>
	</div>
			<!-- L√©gende des communaut√©s  -->
		<div id="community-legend"style="display: none;" >
		<h3>Communaut√©s</h3>
		<button id="hide-legend-btn">Masquer</button> <!-- üìå Bouton pour cacher -->
		<div id="legend-items"></div> <!-- üìå Contiendra les pastilles -->
		</div>
			<!-- L√©gende des composantes connexes  -->
		<div id="connected-components-legend" style="display: none;">
		<h3>Composantes connexes</h3>
		<div id="legend-items"></div>  <!--  Contiendra les pastilles -->
		</div>
	
	
<!-- ‚úÖ Colonne de droite (gestion des graphes) -->
    <div id="right-panel">

		<div id="graph-management">
			<h3>Gestion des graphes</h3>
			
			
			<button id="store-graph-en-0" title="Enregistre le graphe affich√© (supprime l'enregistrement pr√©c√©dent)" style=" background-color: #6666ff;">STOCKER</button>
			<button id="show-stored-graph0" title="Affiche le graphe stock√©" style=" background-color: #6666ff;" >AFFICHER</button>
			
			<button id="store-graph-en-1" title="Enregistre le graphe affich√© (ne supprime pas l'enregistrement pr√©c√©dent)"style=" background-color: #0066ff;" >Ajouter au CUMUL</button>
			<button id="subtract-graph-en-1" title="Retire le graphe affich√© du CUMUL " style=" background-color: #0066ff;" >Soustraire du CUMUL</button>
			<button id="show-stored-graph1"style=" background-color:#0066ff;" >Afficher le CUMUL</button>
			<button id="reset-stored-graph-1"style=" background-color: #0066ff;" >Vider le CUMUL</button>
			
			<button id="export-graph" title="Exporte le fichier correspondant au graphe affich√©, au format JSON, dans votre dossier T√©l√©chargement" style=" background-color: #66ccff;" >Exporter le graphe</button>
			<button onclick="exportGraphToPDF()" title="Exporte le graphe affich√© au format PDF dans votre dossier de T√©l√©chargement" style=" background-color: #66ccff;">Exporter le graphe en PDF</button>
			<button id="import-graph" title="Importe un fichier, au format JSON compatible, √† partir de votre ordinateur"  style=" background-color: #cc99ff;" >Importer un graphe</button>
			<input type="file" id="import-file" accept=".json" style="display: none;" />
			<button id="export-label"  title="Copie la liste des mots du graphe affich√© dans un fichier CSV de votre dossier T√©l√©chargement" style=" background-color: #66ccff;" >Exporter les mots</button>
			 
   
			<button id="btn-importer-mots" title="Importe et affiche les mots d'un fichier, au format CSV sur votre ordinateur, contenant une liste de mots s√©par√©s par une virgule " style=" background-color: #cc99ff;" >Importer des mots</button>
			 <input type="file" id="file-mots-import" accept=".csv" style="display: none;">
			
		 
			<h3>Traitements sur graphes</h3>	
			
			<button id="show-connected-components-btn" title="Colorie les composantes connexes du graphe affich√© (sous ensembles disjoints de mots)">Connexes</button>
			<button id="detect-communities" title="Colorie les sous groupes de mots fortement interconnect√©s (algorithme de Louvain)">Communaut√©s</button>
			<button id="show-legend-btn" style="display:none;">Afficher la l√©gende</button>
			<button id="toggle-forceatlas2" title="Optimisation de la disposition spatiale du graphe affich√© " >Arr√™ter-d√©marrer ForceAtlas2</button>	
			


		</div>	
		 
		
	</div>	
	
<!-- ‚úÖ boutons vert clair en dessus du graphe   -->	
	
<!-- ‚úÖ bouton graphe initial -->	
	<button id="graphe-initial" 
	title="Affiche le graphe initial complet"
	style=" position: fixed; top: 10px; right:200px; left:550px; width: 120px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Graphe initial</button>
	
<!-- ‚úÖ bouton Rafra√Æchir l'affichage  -->		
	<button id="refresh-graph-btn" 
	title="Corrige les d√©fauts de l'affichage"
	style="position: fixed; top: 10px; right: 200px;left:700px; width: 150px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Rafra√Æchir l'affichage</button>
	
	
<!-- ‚úÖ bouton Histogramme -->	
	<button id="show-histo-btn"
	title="Histogramme du graphe affich√© : nombre de liens/nombre de mots"
	style=" position: fixed; top: 10px; right:200px; left:1000px; width: 100px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Histogramme</button>	
	
	
<!-- ‚úÖ bouton aide -->	
	<button id="help-btn"
        style="position: fixed; top: 10px; right: 300px;left:420px; width: 60px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Aide</button>
	
<!-- ‚úÖ contenu aide -->	
	<div id="help-modal"
     style="display: none; position: fixed; top: 20%; left:20%; width: 37%;
            background: white; border: 1px solid #ccc; padding: 20px;fontSize = "28px";
            box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 2000;">
	<h2>Aide</h2>
	<p>Affichage et analyse de graphes de mots li√©s par la relation de <strong>synonymie</strong>. </p>
	<p>La synonymie est issue du D√âS (Dictionnaire √âlectronique des Synonymes),</p>
	<p>mis √† disposition sur Internet par le laboratoire CRISCO de l‚ÄôUniversit√© de Caen.</p>
	<p>Dans cette page, les mots retenus sont les adjectifs du D√âS ayant au moins 2 synonymes (2217 en coh√©rence).</p>
	<p> -</p>
	<p>Vous pouvez <strong>survoler</strong> les points (mots) du graphe,</p>
	<p><strong>clic gauche</strong> pour en s√©lectionner un (vedette), </p>
	<p><strong>clic droit</strong> pour afficher les informations associ√©es.</p>
	<p><strong>Clic gauche sur le fond du graphe</strong> pour r√©initialiser l'affichage,</p>
	<p>utiliser le <strong>zoom</strong> (molette de la souris) pour modifier la taille de l'affichage (visibilit√© des mots). </p>
	<p>- </p>
	<p><strong>Survoler les boutons pour en avoir une courte explication.</strong> </p>
			 
	<button onclick="document.getElementById('help-modal').style.display='none'" 
	style="margin-top: 10px;width: 200px;"
	>Fermer</button>   
</div>

	
<!-- ‚úÖ info bulle au survol de noeud -->		
	<div id="node-tooltip"
	style="position: absolute;background: rgba(0, 0, 0, 0.8);color: white;
	padding: 5px;border-radius: 5px;display: none;font-size: 14px;	z-index: 1000;">				
    </div>

</div>

<!-- FIN DES DIV----------------------------------------------------------------------------------------------------- -->
 
 
<!-- scrip js----------------------------------------------------------------------------------------------------- -->
 <script>
 
//////////////DECLARATION GLOBALE pour une utilisation partout////////////////////////////// 

	let storedGraphInitial = null; //variable de stockage du graphe initial : fichier json
    let storedGraphLouvain = null; //variable de stockage du graphe Louvain
	let isForceAtlas2Running = false;
	let storedGraph0 = { nodes: [], edges: [] }; //variable de stockage du graphe  
	let storedGraph1 = { nodes: [], edges: [] };  // ‚úÖ Initialise un graphe vide
	let baseGraphForComponents = null;  // ‚úÖ Stocke le graphe de r√©f√©rence pour la d√©tection des connexes
	let isFirstComponentDetection = true;  // ‚úÖ V√©rifie si c'est le premier calcul des connexes
	let s; // D√©clarez `s` dans la port√©e globale pour qu'elle soit accessible dans toutes les fonctions
	let vedette = null; //stocke l'ID du noeud s√©lectionn√©
	let communityColors = {};
let lastGraphDisplayed = null;
let lastDisplayOptions = {};


//////////////FIN DECLARATION GLOBALE ////////////////////////////// 

//////////<!-- CHARGER LES DONN√âES INITIALES a partir de DATA.JSON -->//////
 async function loadGraph() {
      try {
			<!-- LES DONN√âES xxxxx.JSON SONT DANS LE MEME DOSSIER QUE INDEX.HTML  -- ------->
			const response = await fetch('datafinal.json');
			const data = await response.json();

		// V√©rifier que les donn√©es contiennent les propri√©t√©s nodes et edges
        if (data && data.nodes && data.edges) {
			console.log('‚úÖLes donn√©es charg√©es contiennent bien les propri√©t√©s nodes et edges.');
			//couleur pr√©sentes dans le fichier json
			//console.log("üé® V√©rification des couleurs des n≈ìuds :", data.nodes.map(n => n.color));
			//console.log("üé® V√©rification des couleurs des ar√™tes :", data.edges.map(e => e.color));

		// Initialiser Sigma.js
			 s = new sigma (
				{ graph: data, container: 'graph-container',
					settings: {
					drawEdges: false,  // ‚úÖ D√©sactive compl√®tement l'affichage des ar√™tes
					// defaultNodeColor: 'blue',
					// nodeHoverColor: 'yellow',
					minNodeSize: 5,  // Taille minimale des n≈ìuds
					maxNodeSize: 5,	// Taille maximale des n≈ìuds
					//minEdgeSize: 0.01,
					//maxEdgeSize: 0.01
					}
				});
		} else {
				console.error('Les donn√©es charg√©es ne contiennent pas les propri√©t√©s nodes et edges.');
				}
			<!-- FIN DE CHARGER LES DONN√âES INITIALE -->			
			console.log("‚úÖ Donn√©es du graphe initial charg√©es :", data);
			//console.log("‚úÖ Type de data.nodes :", typeof data.nodes, Array.isArray(data.nodes));
			//console.log("‚úÖ Type de data.edges :", typeof data.edges, Array.isArray(data.edges));
	
	// survol des noeuds
	SurvolNoeud(s);
	
	// √âv√©nements au clic des n≈ìuds
	ClicNodeEvents(s);
	
	// ‚ùå Bloque le menu contextuel
	document.getElementById("graph-container").addEventListener("contextmenu", function (e)
		{
			e.preventDefault(); 
		});
	
	// chargement du graphe initial dans storedGraphInitial	
	storedGraphInitial = storeGraph(s.graph);

	if (!vedette && storedGraphInitial.nodes.length > 0) {
        vedette = storedGraphInitial.nodes[1169];  // ‚úÖ Prend le n≈ìud 1169 = innomable du graphe initial
		  console.log("‚úÖ`vedette` initialis√© automatiquement sur :", vedette.label);
		}
<!-- FIN DU TRY DE CHARGEMENT  -->
     } catch (error) {
					console.error('Erreur lors du chargement du fichier JSON:', error);
					}
	
	//affichage du graphe initial
	 displayGraph (storedGraphInitial, { initialgraph: true }  );
	
  } 
  /////////////////////<!-- FIN DU CHARGER LES DONN√âES INITIALES a partir de DATA.JSON  -->/////
	
	


///zone de MESSAGES √† l'utilisateur //////

///messages √† dur√©e d√©termin√©e 	courte
function showNotification(message, duration = 3000) {
    const notif = document.getElementById("notification");
   notif.innerHTML = message; // ‚úÖ HTML interpr√©t√©
    notif.style.display = "block";

    setTimeout(() => {
        notif.style.display = "none";
    }, duration);
}

///messages avec bouton "fermer" incorpor√©
function showNotif(message) {
  const notif = document.getElementById("graph-message");
  if (notif) {
    notif.innerHTML = `
      ${message}
      <br>
      <button onclick="document.getElementById('graph-message').style.display='none'"
              style="margin-top: 10px; padding: 4px 10px; background:#ccc; border:none; border-radius:4px;">
        Fermer
      </button>
    `;
    notif.style.display = "block";
  }
}
////fin MESSAGES ////////////

//AFFICHAGE STATS (nbre points et aretes) coin haut gauche du cadre du graphe
function updateGraphStats(graphData) {
    const nbNodes = graphData.nodes.length;
    const nbEdges = graphData.edges.length;
    const statsDiv = document.getElementById("graph-stats-display"); 
    statsDiv.textContent = `${nbNodes} point${nbNodes > 1 ? 's' : ''}, ${nbEdges/2} lien${nbEdges > 1 ? 's' : ''}`;
}
// FIN AFFICHAGE STATS 

//RAFRAICHIR pour effacer les traces des survols
document.getElementById("refresh-graph-btn").addEventListener("click", () => {
  if (s) {
    // üîÅ Lire le graphe affich√© actuellement (avec positions √† jour)
    const currentGraph = {
      nodes: s.graph.nodes().map(n => ({ ...n })),
      edges: s.graph.edges().map(e => ({ ...e }))
    };

    //console.log("üîÅ R√©affichage du graphe courant avec ses positions actuelles");
    displayGraph(currentGraph, lastDisplayOptions); // ou options par d√©faut
  }
});
//FIN de RAFRAICHIR


///////////// AFFICHAGE DES GRAPHES  ///////	DISPLAYGRAPH   ///////////////////////////
function displayGraph(graphData, options = {}) {
   const {
    rescale = true,        // recadrer le graphe 
    initialgraph = false  //  ne pas randomiser le graphe 
  } = options;

  if (rescale) {
    rescaleGraphLayout(graphData, 0.8);
  }
 
 if (s) {   // D√©truire l'instance actuelle de Sigma.js
  s.unbind('overNode');
  s.unbind('outNode');
  s.refresh(); // force le redraw sans survol
  s.kill();
}

lastGraphDisplayed = graphData;
lastDisplayOptions = options;


  const nodeCount = graphData.nodes.length  ;
  //  D√©finir la cat√©gorie du graphe
  let sizeClass = nodeCount < 200 ? "small"
                  : nodeCount <= 400 ? "medium"
                  : "big";

  //console.log(" DISPLAYGRAPH Type de graphe :", sizeClass, " N≈ìuds :", nodeCount, "rescale :",rescale, "initialgraph :",initialgraph); 

// redisposer aleatoirement les grands graphes sauf le graphe initial
  if ( !initialgraph && nodeCount> 400) {
	applyRandomLayout(graphData);
	}

//  D√©finir les tailles des n≈ìuds pour chaque cat√©gorie de graphe
const nodeSizes = {
  small: { vedette: 12, normal: 6 },
  medium: { vedette: 8, normal: 4 },
  big: { vedette: 4, normal: 2 }
};

//  D√©finir les param√®tres d‚Äôaffichage des tailles dans Sigma
const settingsSizes = {
  small: { minNode: 2, maxNode: 16 },
  medium: { minNode: 2, maxNode: 12 },
  big: { minNode: 0.5, maxNode: 6 }
};

	//  V√©rifie si la vedette est pr√©sente dans ce sous-graphe
	const vedetteInGraph = vedette && graphData.nodes.some(n => n.id === vedette.id);
	//console.log ("displaygraph : vedette pr√©sente  ", vedetteInGraph, "label", vedette.label);

  //  Appliquer couleur et taille aux n≈ìuds
  graphData.nodes.forEach(node => {
    if (vedette && node.id === vedette.id) {
      node.color = "#e74c3c"; // üî¥ vedette
      node.size = nodeSizes[sizeClass].vedette;
		// console.log("displaygraph : vedette", node.label, "Size:", node.size, "Color:", node.color);
    } else {
      node.size = nodeSizes[sizeClass].normal;
		//console.log("displaygraph: NON vedette", node.label, "Size:", node.size, "Color:", node.color);
    }
    node.originalColor = node.color;
  });
	
 //  Couleur et sauvegarde des ar√™tes
  graphData.edges.forEach(edge => {
    if (!edge.color) {
      edge.color = sizeClass === "big"
        ? "rgba(0, 0, 255, 0.2)"
        : "rgba(0, 0, 255, 0.6)";
    }
    if (!edge.originalColor) edge.originalColor = edge.color;
  });

 // Sauvegarde des couleurs initiales pour restauration ult√©rieure
	graphData.nodes.forEach(node => {
		if (!node.originalColor) node.originalColor = node.color;
		});
	graphData.edges.forEach(edge => {
		if (!edge.originalColor) edge.originalColor = edge.color;
		});
 
 //  Param√®tres Sigma adapt√©s
  const settings = {
    minNodeSize: settingsSizes[sizeClass].minNode,
    maxNodeSize: settingsSizes[sizeClass].maxNode,
    minEdgeSize: 0.4,
    maxEdgeSize: 1.2,
    font: "Arial",
    fontsize: sizeClass === "small" ? 20: (sizeClass === "medium" ? 14 : 10),
    defaultLabelColor: "#000"
  };


// fonction pour recalibrer laffichage du graphe dans 80% du container
function rescaleGraphLayout(graphData, scale = 0.8) {
  //  R√©cup√®re les extr√™mes des coordonn√©es
  const xs = graphData.nodes.map(n => n.x);
  const ys = graphData.nodes.map(n => n.y);

  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);

  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;

  const rangeX = maxX - minX;
  const rangeY = maxY - minY;
  const maxRange = Math.max(rangeX, rangeY);

  //  Applique un zoom centrant et r√©ducteur sur tous les n≈ìuds
  graphData.nodes.forEach(node => {
    node.x = ((node.x - centerX) / maxRange) * scale;
    node.y = ((node.y - centerY) / maxRange) * scale;
  });
}

rescaleGraphLayout(graphData, 0.8);

function applyRandomLayout(graphData, range = 1) {
  graphData.nodes.forEach(node => {
    node.x = (Math.random() - 0.5) * range;
    node.y = (Math.random() - 0.5) * range;
  });
}


//  Cr√©ation du graphe
    s = new sigma({
      graph: graphData,
      container: 'graph-container',
      settings: settings
    });
    s.refresh();
	
  
	//affiche les stats
	  updateGraphStats(graphData);	   
	// survol des noeuds
	  SurvolNoeud(s);  
	// Afficher des informations au clic gauche des n≈ìuds
      ClicNodeEvents(s);
	// Afficher des informations au clic droit des n≈ìuds	 
	   RightClickNodeEvents(s); 
  }
  //////////// FIN FONCTION POUR AFFICHER UN GRAPHE  
  
  
   // Charger le graphe lorsque la page est pr√™te
    window.onload = loadGraph;
		

<!-- BOUTONS DE l'APPROCHE INDIVIDUELLE  -->	

//// RECHERCHE D'UN NOEUD DANS LE GRAPHE AFFICH√â////////////////////////////////////////////
document.getElementById("search-node-btn").addEventListener("click", function() {
    let searchTerm = document.getElementById("node-search").value.toLowerCase().trim();
    let resultsContainer = document.getElementById("search-results");
    resultsContainer.innerHTML = "";  // ‚úÖ Efface les r√©sultats pr√©c√©dents

    let foundNodes = s.graph.nodes().filter(node => node.label.toLowerCase().includes(searchTerm));

    if (foundNodes.length > 0) {
        foundNodes.forEach(node => {
            let listItem = document.createElement("li");
            listItem.innerHTML = `<strong>${node.label}</strong>`;
            listItem.style.cursor = "pointer";
            listItem.style.padding = "5px";
            listItem.style.borderBottom = "1px solid #ddd";
            
			listItem.addEventListener("click", function() {
				highlightNode(node.id);  // ‚úÖ Met en √©vidence le n≈ìud s√©lectionn√©
				selectedNodeId = node.id;  // ‚úÖ Stocke l'ID du n≈ìud s√©lectionn√©
				
				vedette = node  ;     // ‚úÖ Stocke le n≈ìud s√©lectionn√© via recherche
		//console.log("üìå Noeud s√©lectionn√© via recherche dans affich√© :", vedette);
			
			// ‚úÖ Active les boutons
				document.getElementById("show-neighbors-btn").disabled = false; 
				document.getElementById("show-syno2-btn").disabled = false;
				document.getElementById("show-adjacency-btn").disabled = false; // ‚úÖ Active le bouton "Graphe d'adjacence"
			
			
			resultsContainer.innerHTML = "";  // ‚úÖ Masque la liste apr√®s s√©lection
            });

            resultsContainer.appendChild(listItem);
        });
    } else {
        resultsContainer.innerHTML = "<li>Aucun n≈ìud trouv√©.</li>";
    }
});

function highlightNode(nodeId) {
    s.graph.nodes().forEach(node => {
        node.color = (node.id === nodeId) ? "#e74c3c" : "#3498db"; // üî¥ Rouge pour le n≈ìud trouv√©, üîµ Bleu pour les autres
		node.size = (node.id === nodeId) ? "20" : "8" ;
    });
    s.refresh();  // ‚úÖ Met √† jour l'affichage du graphe
}
//// FIN de RECHERCHE D'UN NOEUD DANS LE GRAPHE AFFICH√â/////////////////////////////////////


// üîç RECHERCHE D'UN NOEUD DANS LE GRAPHE INITIAL (TOUS les n≈ìuds)////////////////////////
document.getElementById("search-initial-btn").addEventListener("click", function() {
    let searchTerm = document.getElementById("node-search").value.toLowerCase().trim();
    let resultsContainer = document.getElementById("search-results");
    resultsContainer.innerHTML = "";  // ‚úÖ Efface les r√©sultats pr√©c√©dents

    let foundNodes = storedGraphInitial.nodes.filter(node => node.label.toLowerCase().includes(searchTerm));

    if (foundNodes.length > 0) {
        foundNodes.forEach(node => {
            let listItem = document.createElement("li");
            listItem.innerHTML = `<strong>${node.label}</strong>`;
            listItem.style.cursor = "pointer";
            listItem.style.padding = "5px";
            listItem.style.borderBottom = "1px solid #ddd";

            listItem.addEventListener("click", function() {
                highlightNode(node.id);  // ‚úÖ Met en √©vidence le n≈ìud s√©lectionn√© dans le graphe affich√©
				
				vedette = node ;  // ‚úÖ Stocke tout l'objet du n≈ìud s√©lectionn√©
               		    
    //console.log("üìå Noeud s√©lectionn√© via recherche dans initial :", vedette);
		
                // ‚úÖ Active les boutons
                document.getElementById("show-neighbors-btn").disabled = false; 
                document.getElementById("show-syno2-btn").disabled = false;
                document.getElementById("show-adjacency-btn").disabled = false;

                resultsContainer.innerHTML = "";  // ‚úÖ Masque la liste apr√®s s√©lection
            });

            resultsContainer.appendChild(listItem);
        });
    } else {
        resultsContainer.innerHTML = "<li>Aucun n≈ìud trouv√©.</li>";
    }
});
// üîç FIN Recherche d'un noeud dans le graphe initial (TOUS les n≈ìuds)////////////////////////


//////////// GRAPHE DES SYNONYMES = VOISINS de la vedette /////////// 
// CLIC sur le bouton "synonymes" => afficher les voisins de la vedette (graphe)
document.getElementById("show-neighbors-btn").addEventListener("click", function () {
  if (!vedette) {
    showNotification("‚ùå Aucun n≈ìud s√©lectionn√© !");
    return;
  }
 // console.log("üìågraphe des voisins pour la vedette :", vedette.label);


  // ‚úÖ Filtrer toutes les ar√™tes contenant le n≈ìud s√©lectionn√©
  let subGraphEdges = storedGraphInitial.edges.filter(
  edge => edge.source === vedette.id || edge.target === vedette.id  );

  // ‚úÖ Extraire les n≈ìuds impliqu√©s dans ces ar√™tes
  let neighborIds = new Set();
  subGraphEdges.forEach(edge => {
    neighborIds.add(edge.source);
    neighborIds.add(edge.target);
  });

  // ‚úÖ Inclure les n≈ìuds du graphe initial
  let subGraphNodes = storedGraphInitial.nodes.filter(node => neighborIds.has(node.id));

	let subGraph = { nodes: subGraphNodes, edges: subGraphEdges };
	// ‚úÖ V√©rification dans la console avant affichage
    //console.log("üìå Sous-graphe Syno1 g√©n√©r√© :", { nodes: subGraphNodes, edges: subGraphEdges });

  
     vedette.color =  "#e74c3c"  ; // üî¥ Rouge pour la vedette
    
	//console.log("vedette.color", vedette.color);
	// ‚úÖ Appliquer les couleurs pour forcer vedette rouge, autres en bleu
	subGraphNodes.forEach(node => {
	node.color = (node.id === vedette.id) ? "#e74c3c" : "#3498db";
	});


	// ‚úÖ Afficher le sous-graphe
	displayGraph(subGraph);
});
//// fin de calcul et affichage du graphe des VOISINS = SYNONYMES
  
  
////fonction pour calculer et afficher le graphe SYNO2 d'une VEDETTE
document.getElementById("show-syno2-btn").addEventListener("click", function() {
    if (!vedette) {
        showNotification("‚ùå Aucun n≈ìud s√©lectionn√© !");
        return;
    }
	//console.log("üìå G√©n√©ration du graphe des SYNO2 pour :", vedette);

    // ‚úÖ √âtape 1 : Trouver les voisins directs (niveau 1)
    let level1Neighbors = new Set();
    storedGraphInitial.edges.forEach(edge => {
        if (edge.source === vedette.id) level1Neighbors.add(edge.target);
        if (edge.target === vedette.id) level1Neighbors.add(edge.source);
    });

    // ‚úÖ √âtape 2 : Trouver les voisins des voisins (niveau 2)
    let level2Neighbors = new Set();
    level1Neighbors.forEach(neighborId => {
        storedGraphInitial.edges.forEach(edge => {
            if (edge.source === neighborId && edge.target !== vedette.id) level2Neighbors.add(edge.target);
            if (edge.target === neighborId && edge.source !== vedette.id) level2Neighbors.add(edge.source);
        });
    });

   // ‚úÖ √âtape 3 : Construire le sous-graphe "syno2"
let allSyno2Nodes = new Set([...level1Neighbors, ...level2Neighbors, vedette.id]);

// ‚ñ∂Ô∏è Cr√©ation des n≈ìuds du sous-graphe avec couleur selon niveau
let subGraph  = { nodes: [], edges: [] };

allSyno2Nodes.forEach(nodeId => {
    const originalNode = storedGraphInitial.nodes.find(n => n.id === nodeId);
    if (originalNode) {
        let color = "#000000"; // couleur par d√©faut
        if (nodeId === vedette.id) color = "#FFD700"; // vedette : jaune
        else if (level1Neighbors.has(nodeId)) color = "#1f77b4"; // niveau 1 : bleu
        else if (level2Neighbors.has(nodeId)) color = "#ff7f0e"; // niveau 2 : orange

        subGraph.nodes.push({
            ...originalNode,
            color: color
        });
    }
});

// ‚ñ∂Ô∏è Ajouter les ar√™tes entre les n≈ìuds du sous-graphe
storedGraphInitial.edges.forEach(edge => {
    if (allSyno2Nodes.has(edge.source) && allSyno2Nodes.has(edge.target)) {
        subGraph.edges.push({ ...edge });
    }
});

    // ‚úÖ Afficher le sous-graphe "syno2"
    displayGraph( subGraph );
});
////FIN fonction   GRAPHE SYNO2 D'UNE VEDETTE
  

//// Graphe ADJACENCE /////////////////////////////////////////////
document.getElementById("show-adjacency-btn").addEventListener("click", function() {
    if (!vedette) {
        showNotification("‚ùå Aucun n≈ìud s√©lectionn√© !");
        return;
    }

    //console.log("üìå G√©n√©ration du graphe d'adjacence pour :", vedette);

    // ‚úÖ √âtape 1 : Trouver les voisins directs (niveau 1)
    let level1Neighbors = new Set();
    storedGraphInitial.edges.forEach(edge => {
        if (edge.source === vedette.id) level1Neighbors.add(edge.target);
        if (edge.target === vedette.id) level1Neighbors.add(edge.source);
    });

    // ‚úÖ √âtape 2 : Trouver les voisins des voisins (niveau 2)
    let level2Neighbors = new Set();
    level1Neighbors.forEach(neighborId => {
        storedGraphInitial.edges.forEach(edge => {
            if (edge.source === neighborId && edge.target !== vedette.id) level2Neighbors.add(edge.target);
            if (edge.target === neighborId && edge.source !== vedette.id) level2Neighbors.add(edge.source);
        });
    });

    // ‚úÖ √âtape 3 : Construire le sous-graphe Syno2
    let allSyno2Nodes = new Set([...level1Neighbors, ...level2Neighbors, vedette.id]);

    let subGraphNodes = storedGraphInitial.nodes.filter(node => allSyno2Nodes.has(node.id));

    // ‚úÖ Cr√©er un Set des IDs des n≈ìuds valides pour √©viter l'erreur
    let validNodeIds = new Set(subGraphNodes.map(node => node.id));

    // ‚úÖ Filtrer les ar√™tes pour ne garder que celles qui connectent des n≈ìuds existants
    let subGraphEdges = storedGraphInitial.edges.filter(edge =>
        validNodeIds.has(edge.source) && validNodeIds.has(edge.target)
    );

    // ‚úÖ √âtape 4 : Garder uniquement `vedette` et ses voisins directs **avec leurs connexions**
    let adjacencyNodes = new Set([...level1Neighbors, vedette.id]);  // ‚úÖ On garde `vedette` et ses voisins directs
    let finalNodes = storedGraphInitial.nodes.filter(node => adjacencyNodes.has(node.id));  // ‚úÖ R√©cup√©rer les n≈ìuds valides

    let finalEdges = subGraphEdges.filter(edge =>  // ‚úÖ V√©rification suppl√©mentaire pour √©viter les erreurs
        adjacencyNodes.has(edge.source) && adjacencyNodes.has(edge.target)
    );

    let adjacencyGraph = { nodes: finalNodes, edges: finalEdges };

    //console.log("üìå Graphe d'adjacence g√©n√©r√© :", adjacencyGraph);

    // ‚úÖ V√©rification avant affichage
    //console.log("üìå V√©rification des n≈ìuds :", adjacencyGraph.nodes);
    //console.log("üìå V√©rification des ar√™tes :", adjacencyGraph.edges);

    // ‚úÖ Afficher le Graphe d'adjacence
    displayGraph(adjacencyGraph);


    // ‚úÖ Supprimer l‚Äôancien bouton s‚Äôil existe d√©j√†
    const existingBtn = document.getElementById("remove-vedette-links-btn");
    if (existingBtn) existingBtn.remove();

    // ‚úÖ Cr√©er dynamiquement le bouton
    const btn = document.createElement("button");
    btn.id = "remove-vedette-links-btn";
    btn.textContent = "Adjacence sans liens avec la vedette";
    btn.classList.add("hide-vedette-edges-btn");
    
	btn.style.height = "15px";
	btn.style.width = "200px";
	btn.style.marginTop = "1px"; /* ‚úÖ  espace au-dessus du bouton */
	btn.style.fontSize = "11px";
    btn.style.backgroundColor = "#ffd9b3";
    btn.style.color = "black";
    btn.style.border = "none";
    btn.style.padding = "2px";
    btn.style.borderRadius = "5px";
    btn.style.cursor = "pointer";

    document.getElementById("info-buttons").appendChild(btn);

    btn.addEventListener("click", function () {
        const edgesToRemove = s.graph.edges().filter(edge =>
            edge.source === vedette.id || edge.target === vedette.id
        );
        edgesToRemove.forEach(edge => {
            s.graph.dropEdge(edge.id);
        });
        s.refresh();
        showNotif(` ‚úÖ Liens avec "${vedette.label}" supprim√©s.`);
        btn.remove(); // ‚úÖ Dispara√Æt apr√®s usage
    });
	
});
//// FIN Graphe ADJACENCE //////////////////////////////////


//////COMPLETUDE du graphe affich√©
//fonction associ√©e au bouton "Compl√©tude"
document.getElementById("completude-btn").addEventListener("click", completeGraphEdgesFromInitial);

function completeGraphEdgesFromInitial() {
    if (!s || s.graph.nodes().length === 0) {
        console.warn("‚ùå Aucun graphe affich√© pour la compl√©tude.");
        return;
    }
    const currentNodes = s.graph.nodes();
    const currentEdges = s.graph.edges();
    const currentNodeIds = new Set(currentNodes.map(n => n.id));

    // üîç Construire un ensemble d'ar√™tes existantes (source+target ou target+source)
    const existingEdgeKeys = new Set(
        currentEdges.map(e => {
            const a = [e.source, e.target].sort().join("‚Üî");
            return a;
        })
    );
    const completedEdges = [];
    storedGraphInitial.edges.forEach(edge => {
        if (
            currentNodeIds.has(edge.source) &&
            currentNodeIds.has(edge.target)
        ) {
            const edgeKey = [edge.source, edge.target].sort().join("‚Üî");

            // ‚úÖ Si l‚Äôar√™te est d√©j√† pr√©sente, on la garde telle quelle
            if (existingEdgeKeys.has(edgeKey)) {
                completedEdges.push(edge);
            }
            // ‚úÖ Sinon, on ajoute une nouvelle ar√™te en gris
            else {
                completedEdges.push({
                    ...edge,
                    color: "#7f8c8d"  // üé® Gris pour les nouvelles ar√™tes
                });
            }
        }
    });
    const completedGraph = {
        nodes: [...currentNodes],
        edges: completedEdges
    };
    //console.log("üìå Ar√™tes totales :", completedEdges.length/2);    
	displayGraph(completedGraph);
	
}
//////FIN COMPLETUDE du graphe affich√©

	
///////EXTENSION ajout des syno au graphe affich√©	///////////////
// fonction associ√©e au bouton "Extension"
document.getElementById("extension-btn").addEventListener("click", function () {
    extendGraph();
});

function extendGraph() {
    //console.log("üìå D√©but de l'extension du graphe...");

    // ‚úÖ V√©rifier si un graphe est affich√©
    if (!s || s.graph.nodes().length === 0) {
        console.warn("‚ùå Aucun graphe affich√©. Impossible d'√©tendre.");
        return;
    }
    // ‚úÖ R√©cup√©rer les n≈ìuds et ar√™tes du **graphe affich√©** (A)
    let baseNodes = [...s.graph.nodes()];
    let baseEdges = [...s.graph.edges()];
    
    let baseNodeIds = new Set(baseNodes.map(node => node.id)); // üîπ Ensemble des IDs des n≈ìuds existants (A)

   // console.log(`üìå N≈ìuds initiaux du graphe affich√© :`, baseNodeIds.size);
   // console.log(`üìå Ar√™tes initiales du graphe affich√© :`, baseEdges.length/2);
    //console.log(`üìå IDs des n≈ìuds initiaux :`, baseNodeIds);

    // ‚úÖ Trouver les synonymes (voisins) des n≈ìuds du graphe affich√© dans `storedGraphInitial`
    let newNodes = new Set(); // üîπ Stocke les synonymes √† ajouter (B - A)
    let newEdges = []; // üîπ Stocke les nouvelles ar√™tes

    baseNodes.forEach(node => {
        let nodeId = node.id;
        
        // üîç R√©cup√©rer les voisins (= synonymes) via les ar√™tes dans le graphe initial
        let synonyms = storedGraphInitial.edges
            .filter(edge => edge.source === nodeId || edge.target === nodeId) // ‚úÖ Garde les ar√™tes connect√©es √† `nodeId`
            .map(edge => edge.source === nodeId ? edge.target : edge.source); // üîÑ R√©cup√®re l‚Äôautre extr√©mit√©

        synonyms.forEach(synonym => {
            if (!baseNodeIds.has(synonym)) {  // ‚úÖ Ne garder que les synonymes **absents** de A
                newNodes.add(synonym);		
            }
        });
    });

    //console.log(`üìå Synonymes uniques ajout√©s (B - A) :`, newNodes.size);

    // ‚úÖ Ajouter les nouvelles ar√™tes entre les synonymes et les n≈ìuds initiaux
    storedGraphInitial.edges.forEach(edge => {
        if (
            (baseNodeIds.has(edge.source) && newNodes.has(edge.target)) ||
            (baseNodeIds.has(edge.target) && newNodes.has(edge.source))
        ) {
            newEdges.push(edge); // ‚úÖ Ajoute uniquement les ar√™tes valides
        }
    });
    //console.log(`üìå Nouvelles ar√™tes ajout√©es :`, newEdges.length/2);

    // ‚úÖ G√©n√©rer le graphe √©tendu
    let extendedGraph = {
        nodes: [...baseNodes], // üîπ On commence avec A
        edges: [...baseEdges, ...newEdges] // üîπ On ajoute les nouvelles ar√™tes
    };

    // ‚úÖ Ajouter les nouveaux synonymes au graphe avec une couleur diff√©rente
    newNodes.forEach(synonym => {
        let originalNode = storedGraphInitial.nodes.find(n => n.id === synonym);
        if (!originalNode) return;
		
        // üîπ Ajouter les coordonn√©es du n≈ìud s'il existe dans `storedGraphInitial`
        extendedGraph.nodes.push({
            id: synonym,
            label: originalNode.label ,
			"nombre de synonymes": originalNode["nombre de synonymes"], 
			synonymes: originalNode["synonymes"],
            color: "#8e44ad", // üé® Couleur sp√©ciale pour les synonymes (violet)
            size: 1, // üìå Taille plus petite
            x: originalNode.x || Math.random() * 100, // üîÑ Position al√©atoire si absente
            y: originalNode.y || Math.random() * 100
        });
    });
    // ‚úÖ Afficher le nouveau graphe √©tendu
	 displayGraph (extendedGraph);	
}		 
///////FIN EXTENSION graphe des syno du graphe affich√©	///////////////

	
// Fonction pour calculer l'HISTOGRAMME du graphe affich√©
function calculateHistogram(nodes, edges) {
    const histogram = {};
    nodes.forEach(node => {
        const degree = edges.filter(edge =>
            edge.source === node.id || edge.target === node.id
        ).length/2;
		 
        if (!histogram[degree]) {
            histogram[degree] = { count: 0, ids: [] };
        }
        histogram[degree].count++;
        histogram[degree].ids.push(node.label);
    });
    return histogram;
}
// Fonction pour formater l'HISTOGRAMME en une cha√Æne lisible
function formatHistogram(histogram) {
    let formattedMessage = "Histogramme du graphe affich√© <br> nombre de liens : nombre de mots (mots dans ce cas)<br>";

    for (const degree in histogram) {
        formattedMessage += `${degree}: ${histogram[degree].count} `;
        if (histogram[degree].ids.length > 0) {
            formattedMessage += ` (${histogram[degree].ids.slice(0, 100).join(', ')})`;
        }
        formattedMessage += "<br>";
    }
    return formattedMessage;
}
// Gestionnaire d'√©v√©nement pour le bouton
document.getElementById("show-histo-btn").addEventListener("click", function() {
    if (!s) {
        showNotification("‚ùå Aucun graphe affich√© !");
        return;
    }
    // R√©cup√©rer les n≈ìuds et ar√™tes du graphe affich√©
    const nodes = s.graph.nodes();
    const edges = s.graph.edges();

    // Calculer l'histogramme
    const histogram = calculateHistogram(nodes, edges);

    // Afficher l'histogramme dans la console
   // console.log("‚úÖ Histogramme du graphe affich√© :", histogram);
	
	// Formater l'histogramme en message lisible
    const message = formatHistogram(histogram);
	//console.log("‚úÖ Histogramme du graphe affich√© format√©:", message);
    // Afficher l'histogramme dans la zone de notification
    showNotif(message);
});
// FIN Fonction pour calculer l'HISTOGRAMME du graphe affich√©

///// ‚ñ∂Ô∏è Activation du panneau d'AIDE au clic sur le bouton "Aide"
document.getElementById("help-btn").addEventListener("click", () => {
  const helpModal = document.getElementById("help-modal");
  if (helpModal) {
    helpModal.style.display = "block";
  }
});
///// FIN Activation du panneau d'AIDE au clic sur le bouton "Aide"

// gestion du bouton "GRAPHE INITIAL" 
// qui affiche le graphe initial stock√© en storedGraphInitial
    document.getElementById('graphe-initial').addEventListener('click', function() {
	if (storedGraphInitial && storedGraphInitial.nodes.length > 0 && storedGraphInitial.edges.length > 0) { 
 
	displayGraph (storedGraphInitial, { initialgraph: true });
} else {
    showNotification('‚ö†Ô∏è Pas de graphe initial stock√©');
}
	});
// FIN gestion du bouton "GRAPHE INITIAL" 	


// Gestion bouton pour alterner  D√âMARRER/ARR√äTER FORCEATLAS2
    document.getElementById('toggle-forceatlas2').addEventListener('click', function() {
      if (isForceAtlas2Running) {
        s.stopForceAtlas2();
        this.textContent = 'D√©marrer ForceAtlas2';
      } else {
        startForceAtlas2(s);
        this.textContent = 'Arr√™ter ForceAtlas2';
      }
      isForceAtlas2Running = !isForceAtlas2Running;
    });
//  FIN  Gestion bouton pour alterner  D√âMARRER/ARR√äTER FORCEATLAS2


<!-- FIN BOUTONS DE l'APPROCHE INDIVIDUELLE  -->	


<!-- BOUTONS DE LA GESTION DES GRAPHES  -->

// STOCK CUMUL IMPORT EXPORT 

// Fonction pour STOCKER et afficher un graphe en remplacement de celui stock√© pr√©c√©demment
  
	//copie du graphe affich√© 
	function storeGraph(graph) 
	{
		let nodes = typeof graph.nodes === "function" ? graph.nodes() : Object.values(graph.nodes);
		let edges = typeof graph.edges === "function" ? graph.edges() : Object.values(graph.edges);
		//console.log("üìå V√©rification des attributs des n≈ìuds AVANT stockage :", nodes);

		return {
        nodes: nodes.map(node => ({
            id: node.id,
            label: node.label,
            x: node.x,
            y: node.y,
            size: node.size,
            color: node.color,
            antonymes: node.antonymes || [],   
            variantes: node.variantes || [],
            cliques: node.cliques || [],
            "nombre de synonymes": node["nombre de synonymes"] || 0,   
            "synonymes": node.synonymes || [],  
            //liste10: node.liste10 || []      // NE PAS  Conserver les listes
			})),
        edges: edges.map(edge => ({
            id: edge.id,
            source: edge.source,
            target: edge.target,
            size: edge.size,
            color: edge.color
			}))
		};
	}

	// gestion du bouton "STOKER le graphe affich√© "
	document.getElementById("store-graph-en-0").addEventListener("click", function() {
    if (s.graph.nodes().length > 0) {
        storedGraph0 = storeGraph(s.graph);
        //console.log("‚úÖ Graphe affich√© stock√© par l'utilisateur :", storedGraph0);
		showNotification('‚úÖ Graphe stock√©');
    } else {
        console.warn(" Impossible de stocker : aucun n≈ìud dans le graphe.");
    }
});

// gestion du bouton "AFFICHER le graphe STOCK√â "
    document.getElementById('show-stored-graph0').addEventListener('click', function() {
		if (storedGraph0 && storedGraph0.nodes.length > 0 && storedGraph0.edges.length > 0) { 
		displayGraph(storedGraph0);
		} else {
			showNotification('‚ö†Ô∏è Pas de graphe stock√©');
		}
	});
	
////////////// Fin de la fonction pour stocker et afficher un graphe


////////////// fonction pour EXPORTER un graphe   
document.getElementById("export-graph").addEventListener("click", function() {
    if (!s) {
        showNotification("‚ùå Aucun graphe √† exporter !");
        return;
    }
	
	// ‚úÖ R√©cup√©rer les n≈ìuds et ar√™tes du graphe affich√©
    let graphData = {
        nodes: s.graph.nodes().map(node => ({
            id: node.id,
            label: node.label,
            x: node.x,
            y: node.y,
            size: node.size,
            color: node.color,
			synonymes: node.synonymes || [],
			["nombre de synonymes"]: node["nombre de synonymes"],
            antonymes: node.antonymes || [],
            variantes: node.variantes || [],
            cliques: node.cliques || [],
            liste10: node.liste10 || []
        })),
        edges: s.graph.edges().map(edge => ({
            id: edge.id,
            source: edge.source,
            target: edge.target,
            size: edge.size,
            color: edge.color
        }))
    };

    // ‚úÖ Convertir en JSON
    let jsonString = JSON.stringify(graphData, null, 4);

    // ‚úÖ Cr√©er un blob et un lien de t√©l√©chargement
    let blob = new Blob([jsonString], { type: "application/json" });
    let a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    //a.download = "graphe_export.json";  // üìå Nom du fichier export√©
	let fileName = prompt("Nom pour le fichier export√©, au format JSON, dans le dossier : T√©l√©chargement", "graphe_export.json");
	if (!fileName) return;  // utilisateur a annul√©
	a.download = fileName.endsWith(".json") ? fileName : fileName + ".json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    //console.log("‚úÖ Exportation r√©ussie !");
});
////////////// FIN fonction pour EXPORTER un graphe   


////////// fonction pour IMPORTER un graphe
// üìå Quand on clique sur le bouton, d√©clencher l'ouverture du s√©lecteur de fichier
document.getElementById("import-graph").addEventListener("click", () => {
    document.getElementById("import-file").click();
});

// üìå G√©rer la s√©lection d‚Äôun fichier JSON
document.getElementById("import-file").addEventListener("change", function (event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();

    reader.onload = function (e) {
        try {
            const importedGraph = JSON.parse(e.target.result);
			
			// ‚úÖ REFUSER LES GRAPHES MARQU√âS COMME "R√âDUIT"
			//if (importedGraph.type === "reduit") {
			//showNotification("‚ùå Ce fichier est un graphe r√©duit. Il ne peut pas √™tre import√© dans cette page.");
			//return;
			//}

            // V√©rification de base
            if (!importedGraph.nodes || !importedGraph.edges) {
                console.error("‚ùå Format de graphe invalide.");
                showNotification("Le fichier s√©lectionn√© n‚Äôest pas un graphe JSON valide.");
                return;
            }

           // console.log("üì• Graphe import√© :", importedGraph);

            // ‚úÖ Afficher le graphe import√© (fonction existante)
			displayGraph(importedGraph);
        } catch (err) {
            console.error("‚ùå Erreur lors de la lecture du fichier JSON :", err);
            showNotification("Erreur lors de l‚Äôimport du fichier JSON.");
        }
    };

    reader.readAsText(file);
});
////////// FIN fonction pour IMPORTER un graphe


///////////////CUMUL DES GRAPHES//////////////////////////////////

// gestion du bouton "stoker le graphe affich√© en 1" CUMUL DES GRAPHES
	document.getElementById("store-graph-en-1").addEventListener("click", function() {
    if (s.graph.nodes().length > 0) {
        let newGraph = storeGraph(s.graph);  // ‚úÖ Graphe actuel

        if (!storedGraph1 || !storedGraph1.nodes) {  
            storedGraph1 = newGraph;  // ‚úÖ Premier graphe stock√© normalement
			showNotification ("‚úÖ Premier graphe ajout√© au CUMUL");
        } else {
            // ‚úÖ V√©rifier si le graphe actuel est r√©ellement diff√©rent avant d'ajouter
            let existingNodes = new Map(storedGraph1.nodes.map(node => [node.id, node])); 
            let existingEdges = new Map(storedGraph1.edges.map(edge => [edge.id, edge])); 

            let isNewGraph = false;

            newGraph.nodes.forEach(node => {
                if (!existingNodes.has(node.id)) {
                    existingNodes.set(node.id, node);
                    isNewGraph = true;
                }
            });

            newGraph.edges.forEach(edge => {
                if (!existingEdges.has(edge.id)) {
                    existingEdges.set(edge.id, edge);
                    isNewGraph = true;
                }
            });

            if (isNewGraph) {
                storedGraph1 = {
                    nodes: Array.from(existingNodes.values()),
                    edges: Array.from(existingEdges.values())
                };
                showNotification("‚úÖ Nouveau graphe ajout√© au CUMUL");
            } else {
                showNotification("‚ö†Ô∏è Aucun changement dans la composition des noeuds et ar√™tes d√©tect√© dans le graphe, stockage ignor√©.");
            }
        }
    } else {
        console.warn("‚ö†Ô∏è Impossible de stocker : aucun n≈ìud dans le graphe.");
    }
});
//  FIN  gestion du bouton "stoker le graphe affich√© en 1" CUMUL DES GRAPHES

// soustraction du graphe affich√© du CUMUL /////////
document.getElementById("subtract-graph-en-1").addEventListener("click", function () {
    if (!storedGraph1 || !storedGraph1.nodes || storedGraph1.nodes.length === 0) {
        showNotification("‚ùå Aucun graphe CUMUL√â √† modifier !");
        return;
    }

    if (!s || s.graph.nodes().length === 0) {
        showNotification("‚ùå Aucun graphe affich√© √† soustraire !");
        return;
    }

    const displayedNodeIds = new Set(s.graph.nodes().map(node => node.id));

    // 1Ô∏è‚É£ Supprimer les n≈ìuds affich√©s du cumul
    const remainingNodes = storedGraph1.nodes.filter(node => !displayedNodeIds.has(node.id));

    // 2Ô∏è‚É£ Supprimer les ar√™tes qui touchent un n≈ìud supprim√©
    const remainingNodeIds = new Set(remainingNodes.map(node => node.id));
    const remainingEdges = storedGraph1.edges.filter(edge =>
        remainingNodeIds.has(edge.source) && remainingNodeIds.has(edge.target)
    );

    // 3Ô∏è‚É£ Mettre √† jour le CUMUL
    storedGraph1 = {
        nodes: remainingNodes,
        edges: remainingEdges
    };

    //console.log("üìå Graphe affich√© retir√© du CUMUL. N≈ìuds restants :", remainingNodes.length);
    showNotification("‚úÖ Le graphe affich√© a √©t√© retir√© du CUMUL.");
});
// FIN soustraction du graphe affich√© du CUMUL /////////


// VIDER LE CUMUL DES GRAPHES
	document.getElementById("reset-stored-graph-1").addEventListener("click", function()
	{
		{
			if (storedGraph1 && storedGraph1.nodes.length > 0 && storedGraph1.edges.length > 0) 
			{
			if (confirm("‚ùó Confirmer le vidage du cumul ? Cette action est irr√©versible."))		
			
			storedGraph1 = { nodes: [], edges: [] };  // ‚úÖ R√©initialisation compl√®te
			//console.log("‚úÖ Graphe stock√© dans le cuml r√©initialis√© :", storedGraph1);
			if (s) {
				s.graph.clear();  // ‚úÖ Effacer l'affichage du graphe
				s.refresh();  // ‚úÖ Rafra√Æchir Sigma.js
			}
			showNotification("‚úÖ Le cumul des graphes stock√©s a √©t√© √©ffac√© !");			
			}
			else
			{
			showNotification('‚ö†Ô∏è Pas de graphe stock√©');	
			};
		};
	});
// FIN VIDER LE CUMUL DES GRAPHES//////////

// AFFICHER LE CUMUL  "Afficher le(s) Graphe(s) Stock√©(s) en 1" 
    document.getElementById('show-stored-graph1').addEventListener('click', function()
		{
		if (storedGraph1 && storedGraph1.nodes.length > 0 && storedGraph1.edges.length > 0) { 
		displayGraph(storedGraph1);
		} else {
			showNotification('‚ö†Ô∏è Pas de graphe stock√©');
		}
	});
/////// FIN AFFICHER LE CUMUL ///	

/////////////fontion pour EXPORTER LA LISTE DES LABELS ///////////////////
document.getElementById("export-label").addEventListener("click", function () {
    if (!s || s.graph.nodes().length === 0) {
        alert("‚ùå Aucun graphe affich√© !");
        return;
    }

    // 1. R√©cup√©rer les labels
    let labels = s.graph.nodes().map(node => node.label);

    // 2. Trier les labels par ordre alphab√©tique
    labels.sort((a, b) => a.localeCompare(b, 'fr', { sensitivity: 'base' }));

    // 3. Construire le contenu CSV (une ligne, s√©par√©e par des virgules)
   //mots s√©par√©s par une ,
   const csvContent = labels.join(","); 
   //labels.join("\n") un mot par ligne

    // 4. Demander le nom du fichier √† l'utilisateur
    const fileName = prompt("Nom du fichier CSV √† enregistrer dans le dossier : t√©l√©chargement  ", "mots_du_graphe.csv");
    if (!fileName) return;

    // 5. Cr√©er et d√©clencher le t√©l√©chargement
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = fileName.endsWith(".csv") ? fileName : fileName + ".csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    //console.log("‚úÖ Labels export√©s :", labels.length);
});
/////////////FIN fontion pour EXPORTER LA LISTE DES LABELS ///////////////////

function exportGraphToPDF() {
  const container = document.getElementById('graph-container');

  html2canvas(container).then(canvas => {
    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'pt',
      format: [canvas.width, canvas.height]
    });
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
    pdf.save("graphe.pdf");
  });
}


// FIN STOCK CUMUL IMPORT EXPORT ///////////////////////



	
////////// TRAITEMENTS sur graphes  ////////////////////////////////
	
/////// COMPOSANTES CONNEXES //////////////////////////////////////	

// ‚úÖ G√©n√®re une couleur unique pour chaque composante
function getColor(index) {
    const colors = [
        "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6", 
        "#1abc9c", "#e67e22", "#d35400", "#34495e", "#95a5a6"
    ];
    return colors[index % colors.length]; // ‚úÖ R√©utilise les m√™mes couleurs pour chaque composante
}

///////////bouton composantes connexes  
document.getElementById("show-connected-components-btn").addEventListener("click", function() {
    detectConnectedComponents();
});

//////////calcul des composantes CONNEXES
function detectConnectedComponents() {
  
  if (isFirstComponentDetection) {  
        baseGraphForComponents = {  // ‚úÖ Stocke le graphe affich√© au premier appel seulement
            nodes: [...s.graph.nodes()],  
            edges: [...s.graph.edges()]
        };
        isFirstComponentDetection = false;  // ‚úÖ D√©sactive le stockage pour les appels suivants
    }
	else 
	{ 						//	displayGraph (coloredGraph );
	}

   // let nodes = baseGraphForComponents.nodes;  // ‚úÖ Toujours utiliser le m√™me graphe de r√©f√©rence
   // let edges = baseGraphForComponents.edges;

  let nodes = s.graph.nodes();  // ‚úÖ Toujours utiliser le graphe AFFICH√â
  let edges = s.graph.edges();


    //console.log("üìå Utilisation du graphe affich√© pour les composantes :", nodes.length, "n≈ìuds,", edges.length/2, "ar√™tes");

    // ‚úÖ Construire la liste d'adjacence
    let adjacencyList = {};
    nodes.forEach(node => adjacencyList[node.id] = []);
    
    edges.forEach(edge => {
        adjacencyList[edge.source].push(edge.target);
        adjacencyList[edge.target].push(edge.source);
    });

    // ‚úÖ D√©tection des composantes connexes via DFS
    let visited = new Set();
    connectedComponents = [];  // ‚úÖ R√©initialise la liste des composantes

    function dfs(nodeId, component) {
        visited.add(nodeId);
        component.push(nodeId);
        adjacencyList[nodeId].forEach(neighbor => {
            if (!visited.has(neighbor)) {
                dfs(neighbor, component);
            }
        });
    }
    nodes.forEach(node => {
        if (!visited.has(node.id)) {
            let component = [];
            dfs(node.id, component);
            connectedComponents.push(component);
        }
    });

    // ‚úÖ Appliquer une couleur diff√©rente √† chaque composante connexe
	connectedComponents.forEach((component, index) => {
    let color = getColor(index);  // ‚úÖ Utilise la m√™me fonction que la l√©gende
    component.forEach(nodeId => {
        let node = s.graph.nodes(nodeId);
        if (node) node.color = color;
    });
});

    // ‚úÖ Sauvegarde le graphe color√© pour pouvoir le r√©afficher plus tard
    coloredGraph = { nodes: [...s.graph.nodes()], edges: [...s.graph.edges()] };
 
 //console.log("üìå Composantes connexes d√©tect√©es :", connectedComponents);
 
    // ‚úÖ Rafra√Æchir l'affichage pour voir toutes les composantes color√©es
    s.refresh();
	
	updateConnectedComponentsUI(connectedComponents);
	
//////////APPEL DE LA LEGENDE

// ‚úÖ Mise √† jour compl√®te de la l√©gende avant l'affichage
updateConnectedComponentsUI(connectedComponents);
// ‚úÖ Forcer l'affichage de la l√©gende apr√®s le calcul des composantes
setTimeout(() => {
let legendContainer = document.getElementById("connected-components-legend");
if (legendContainer) {
    legendContainer.style.display = "block"; // ‚úÖ Assure que la l√©gende est visible
 }
}, 100); // ‚úÖ Petit d√©lai pour que le DOM soit bien mis √† jour

}
//////////FIN calcul des composantes CONNEXES

///fonction pour avoir des couleurs
function getColor(index) {
    const colors = [
        "#3498db", "#e74c3c", "#2ecc71", "#f1c40f", "#9b59b6",
        "#1abc9c", "#e67e22", "#d35400", "#34495e", "#95a5a6"
    ];
    return colors[index % colors.length]; // ‚úÖ Assigne une couleur parmi la liste
}

///////////creation dynamique des boutons de CONNEXES
function updateConnectedComponentsUI(components) {

	let legendContainer = document.getElementById("connected-components-legend");

   // ‚úÖ Afficher la l√©gende
    legendContainer.style.display = "block";

    let legendItemsContainer = document.getElementById("connected-components-legend");
	if (legendContainer) {
    legendContainer.style.display = "block"; // ‚úÖ La l√©gende s'affiche d√®s le premier clic
	 legendContainer.innerHTML = "<h3>Composantes connexes</h3> <div id='legend-items'></div>";
}

    connectedComponents.forEach((component, index) => {
        let color = getColor(index); // üé® Fonction qui g√©n√®re une couleur pour chaque composante
		let nodeCount = component.length; // ‚úÖ R√©cup√®re le nombre de n≈ìuds dans la composante

        // ‚úÖ Cr√©ation d'une pastille de couleur
        let legendItem = document.createElement("div");
        legendItem.classList.add("legend-item");
        legendItem.innerHTML = `
            <span class="color-dot" style="background-color: ${color};"></span>
            <span class="legend-label">C ${index + 1} (${nodeCount})</span> <!-- ‚úÖ Ajoute le nombre de n≈ìuds -->
        `;

		// ‚úÖ Ajuste dynamiquement le nombre de colonnes en fonction du nombre de pastilles
		legendItemsContainer.style.columnCount = Math.ceil(connectedComponents.length / 15); 	

        // ‚úÖ Ajoute un √©v√©nement au clic
        legendItem.addEventListener("click", function () {
           // console.log(`üìå Affichage de la composante ${index + 1} avec ${nodeCount} n≈ìuds`);
            displayComponentGraph(index);
        });

        legendItemsContainer.appendChild(legendItem);
    });

    // ‚úÖ Ajouter un bouton pour afficher toutes les composantes
    let showAllButton = document.createElement("button");
    showAllButton.textContent = "TOUTES";
    showAllButton.style.marginTop = "10px";
    showAllButton.style.backgroundColor = "#3498db";  // Bleu Sigma.js
    showAllButton.style.color = "white";
    showAllButton.style.border = "none";
    showAllButton.style.padding = "8px";
    showAllButton.style.borderRadius = "5px";
    showAllButton.style.cursor = "pointer";
    showAllButton.style.fontSize = "14px";
    showAllButton.style.transition = "background 0.3s ease-in-out";

    // ‚úÖ Changement de couleur au survol
    showAllButton.addEventListener("mouseover", function () {
        showAllButton.style.backgroundColor = "#2980b9"; // Bleu fonc√©
    });
    showAllButton.addEventListener("mouseout", function () {
        showAllButton.style.backgroundColor = "#3498db"; // Bleu d'origine
    });

    // ‚úÖ Ajoute l'√©v√©nement de clic pour afficher toutes les composantes
    showAllButton.addEventListener("click", function () {
       // console.log("üìå Affichage de toutes les composantes");
         
		displayGraph(coloredGraph);
    });

    // ‚úÖ Ajouter le bouton au conteneur avant le bouton "Masquer"
    legendContainer.appendChild(showAllButton);

    // ‚úÖ Ajouter un bouton pour masquer la legende des connexes
    let hideButton = document.createElement("button");
    hideButton.textContent = "Masquer";
    hideButton.style.marginTop = "10px";
    hideButton.style.backgroundColor = "#bdc3c7";  
    hideButton.style.cursor = "pointer";
	 
	// Ajouter un gestionnaire d'√©v√©nements pour changer la couleur au survol du bouton masquer
	hideButton.addEventListener("mouseover", function() {
    hideButton.style.backgroundColor = "#FF0000"; // Rouge
	});
	hideButton.addEventListener("mouseout", function() {
    hideButton.style.backgroundColor = "#bdc3c7"; // Couleur d'origine
	});

    hideButton.addEventListener("click", function () {
        legendContainer.style.display = "none";
    });

    legendContainer.appendChild(hideButton);
}
///////////FIN creation dynamique des boutons CONNEXES

///////////////////affichage des CONNEXES
function displayComponentGraph(index) {
 
    let componentNodeIds = new Set(connectedComponents[index]);

    let subGraphNodes = coloredGraph.nodes.filter(node => componentNodeIds.has(node.id));

	// ‚úÖ Appliquer la couleur correcte √† chaque n≈ìud
    let color = getColor(index);
    subGraphNodes.forEach(node => {
        node.color = color; // üé® Applique la couleur correspondant √† la l√©gende
    });
   
   // ‚úÖ V√©rification des ar√™tes : Garde uniquement celles qui connectent les n≈ìuds de la composante
    let subGraphEdges = storedGraphInitial.edges.filter(edge =>
        componentNodeIds.has(edge.source) && componentNodeIds.has(edge.target)
    );
	
  //  console.log(`üìå Affichage de la composante ${index + 1}:`, subGraphNodes.length, "n≈ìuds et", subGraphEdges.length/2, "ar√™tes");

    let componentGraph = { nodes: subGraphNodes, edges: subGraphEdges };

     //affiche les stats
	   updateGraphStats(componentGraph );
	      
        // ‚úÖ Effacer l'ancien graphe et recharger uniquement la composante s√©lectionn√©e
        s.graph.clear();  // ‚úÖ Efface compl√®tement le graphe actuel
        s.graph.read(componentGraph);  // ‚úÖ Charge les nouveaux n≈ìuds et ar√™tes
        s.refresh();  // ‚úÖ Rafra√Æchir l'affichage pour forcer Sigma.js √† afficher les nouvelles donn√©es
		
		// ‚úÖ V√©rification des n≈ìuds et ar√™tes apr√®s le chargement
		// console.log("üìå N≈ìuds affich√©s :", s.graph.nodes().length);
		// console.log("üìå Ar√™tes affich√©es :", s.graph.edges().length);
		//console.log("‚úÖ Composante affich√©e :", s.graph.nodes().length, "n≈ìuds et", s.graph.edges().length, "ar√™tes");
}
///////////////////FIN affichage des connexes
/////// FIN COMPOSANTES CONNEXES //////////////////////////////////////		
	
	

///////// FONCTION  calcul COMMUNAUTES SUR LE GRAPHE AFFICH√â //////////
function detectCommunitiesOnCurrentGraph() {
    if (!s || s.graph.nodes().length === 0) {
        showNotification("‚ùå Aucun graphe affich√© pour calculer les communaut√©s !");
        return;
    }

    //  Cr√©er un graphe graphology √† partir du graphe affich√©
    const graph = new graphology.Graph();

    // Ajouter les n≈ìuds
    s.graph.nodes().forEach(node => {
        graph.addNode(node.id, { label: node.label });
    });

    // Ajouter les ar√™tes
    s.graph.edges().forEach(edge => {
        if (graph.hasNode(edge.source) && graph.hasNode(edge.target)) {
            graph.addEdge(edge.source, edge.target);
        }
    });
	
	//console.log("üìå V√©rification de graphology :", window.graphology); 
	//console.log("üìå V√©rification de graphology-communities-louvain :", window.graphologyCommunitiesLouvain);
	//console.log("üìå Propri√©t√©s disponibles :", Object.keys(window.graphologyCommunitiesLouvain));


	// Appliquer l'algorithme de Louvain  ///////////////////
		window.graphologyCommunitiesLouvain.assign(graph ,{
			resolution: 1,  // ‚úÖ Augmente la sensibilit√© au regroupement
			rng: Math.random, // ‚úÖ Randomisation pour √©viter les blocages
		});  
	///////////////////////////////////////////////////////////////////////
  
	//  V√©rifier apr√®s assign() que les communaut√©s sont bien ajout√©es dans graph
	//console.log("üìå Communaut√©s d√©tect√©es A :", Object.fromEntries(s.graph.nodes().map(node => [node.id, node.community])));
		//console.log("üìå Nombre de n≈ìuds dans s.graph avant stockage :", s.graph.nodes().length);
		//console.log("üìå Nombre d‚Äôar√™tes dans s.graph avant stockage :", s.graph.edges().length);

	//  V√©rification d√©taill√©e
	const communityData = window.graphologyCommunitiesLouvain.detailed(graph);
	//console.log("üìå D√©tails des communaut√©s :", communityData);

	//  R√©cup√©rer les communaut√©s depuis le graphe
	const communities = {};
	graph.forEachNode((node, attributes) => {
    communities[node] = attributes.community;
	});
	//console.log("üìå Communaut√©s d√©tect√©es :", communities);

    //  Ajouter la communaut√© comme attribut de chaque n≈ìud pour Sigma.js
    s.graph.nodes().forEach(node => {
        node.community = communities[node.id] || 0;  //0 si non d√©tect√©
    });

    //  Assigner une couleur diff√©rente √† chaque communaut√©
    const colorPalette = [
        "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6",
        "#1abc9c", "#e67e22", "#95a5a6", "#34495e", "#8e44ad"
    ];

   s.graph.nodes().forEach(node => {
       node.color = colorPalette[node.community % colorPalette.length] || "#bdc3c7";
    });
		 
    //  Rafra√Æchir le graphe pour afficher les couleurs des communaut√©s
    s.refresh();
 
	//  Stocker  le graphe avec les communaut√©s et les couleurs dans  storedGraphLouvain
		storedGraphLouvain = { 
		nodes: [...s.graph.nodes()], 
		edges: [...s.graph.edges()] 
		};

	window.graphologyCommunitiesLouvain.assign(graph );

	updateCommunityLegend();  //  Mettre √† jour la l√©gende apr√®s assignation

	//console.log("üìå Stockage dans storedGraphLouvain (apr√®s affectation des  communaut√©) effectu√© !", storedGraphLouvain);
	
	//console.log("üìå N≈ìuds dans le graphe affich√© :", s.graph.nodes().length);
	//console.log("üìå N≈ìuds dans storedGraphLouvain :", storedGraphLouvain.nodes.length);
	//console.log("üìå Ar√™tes dans storedGraphLouvain :", storedGraphLouvain.edges.length/2);
	//console.log("üìå V√©rification des attributs des n≈ìuds dans storedGraphLouvain :",
	// storedGraphLouvain.nodes.map(n => ({ id: n.id, community: n.community }))
	//);

	updateCommunityLegend();  //  Mettre √† jour la l√©gende apr√®s assignation

	//s.graph.nodes().forEach(node => {
	// if (node.community === 0) {
	//     console.warn(`‚ö†Ô∏è N≈ìud class√© 0 : ${node.id} (degr√© : ${s.graph.degree(node.id)})`);
	// }
	//});
	
}

// üìå Associer la fonction au bouton "Communaut√©s"
document.getElementById("detect-communities").addEventListener("click", function() {
    detectCommunitiesOnCurrentGraph();
});

/////////// g√©rer l‚Äôaffichage du bouton et r√©afficher la l√©gende 
document.getElementById("show-legend-btn").addEventListener("click", function() {
    let legendContainer = document.getElementById("community-legend");
    legendContainer.style.display = "block";
    this.style.display = "none"; //  Cacher le bouton apr√®s affichage
});

///////////////////////////////////////
   function displayCommunity(communityId) {
   // console.log(`üìå Affichage de la communaut√© ${communityId}`);

    //  V√©rifier que le graphe initial est bien stock√©
    if (!storedGraphLouvain) {
        console.error("‚ùå ERREUR : le graphe n'est pas d√©fini !");
        return;
    }
	
	//console.log("üìå storedGraphLouvain avant filtrage des communaut√©s " ,storedGraphLouvain );
	//console.log("üìå attributs des n≈ìuds dans storedGraphLouvain avant filtrage des communaut√©s",
     storedGraphLouvain.nodes.map(n => ({ id: n.id, community: n.community, color: n.color }));
	//console.log(`üìå Type de communityId :`, typeof communityId, `Valeur :`, communityId);
	//  Afficher un exemple de node pour voir son format exact
	//console.log(`üìå Exemple de n≈ìud dans storedGraphLouvain :`, storedGraphLouvain.nodes[0]);

	communityId = Number(communityId); //  Convertit en nombre 
	
	//  Utiliser le graphe initial pour FILTRER les communaut√©s
    let subGraphNodes = storedGraphLouvain.nodes.filter(node => node.community === communityId);
    let nodeIds = new Set(subGraphNodes.map(n => n.id));  

    //console.log(" N≈ìuds s√©lectionn√©s :", subGraphNodes);

    //  Filtrer les ar√™tes pour ne conserver que celles entre ces n≈ìuds
    let subGraphEdges = storedGraphLouvain.edges.filter(edge => 
        nodeIds.has(edge.source) && nodeIds.has(edge.target)
    );

	//console.log(`üìå V√©rification des n≈ìuds trouv√©s pour communaut√© ${communityId} :`,
    subGraphNodes.map(n => ({ id: n.id, community: n.community }));

    //console.log(" Ar√™tes s√©lectionn√©es :", subGraphEdges);

    //  V√©rifier que des ar√™tes existent
    if (subGraphEdges.length === 0) {
        console.warn(`‚ö†Ô∏è Aucun edge trouv√© pour la communaut√© ${communityId}`);
    }
	
	//  Trouver la couleur de la pastille associ√©e √† la communaut√© s√©lectionn√©e
	let legendItems = document.querySelectorAll(".legend-item");
	 
	let color = communityColors[communityId] || "#3498db";
	
	legendItems.forEach(item => {
    let label = item.querySelector(".legend-label").textContent;
    if (label.includes(`C${communityId} (`)) {
        color = item.querySelector(".color-dot").style.backgroundColor;
    }
	//console.log(` Couleur d√©tect√©e pour communaut√© ${communityId} :`, color);
	//console.log(" Contenu exact des labels :", Array.from(legendItems).map(item =>
	//item.querySelector(".legend-label").textContent
 
});

	//  Appliquer la couleur aux n≈ìuds
	subGraphNodes.forEach(node => {
    node.color = color;
});

    let communityGraph = { nodes: subGraphNodes, edges: subGraphEdges };
	// console.log(`üìå Graphe de la communaut√© ${communityId} g√©n√©r√© :`, communityGraph);
	//console.log(`üìå Couleur assign√©e √† la communaut√© ${communityId}:`, color);
	//console.log("üìå N≈ìuds color√©s :", subGraphNodes.map(n => ({ id: n.id, color: n.color })));

    //  Afficher uniquement cette communaut√©
	
	//console.log(`üìå Affichage de la communaut√© ${communityId} (${subGraphNodes.length} n≈ìuds)`);

	displayGraph(communityGraph); 
	 
}

//////////////////////////////////////// LEGENDE  COMMUNAUT√âS
function updateCommunityLegend() {
    let legendContainer = document.getElementById("community-legend");
	let legendItemsContainer = document.getElementById("legend-items");

//legendItemsContainer.style.columnCount = Math.ceil(connectedComponents.length / 15); // ‚úÖ Ajuste le nombre de colonnes


	//  Afficher la l√©gende lorsqu'on d√©tecte les communaut√©s
    legendContainer.style.display = "block";
	
    // Vider l'ancienne l√©gende
    legendContainer.innerHTML = "<h3>Communaut√©s</h3><div id='community-items'></div>";
	
   legendItemsContainer = document.getElementById("community-items");

    //  Cr√©er les pastilles pour chaque communaut√©
    let communityCounts = {};  // üìå Stocke la population de chaque communaut√©

    storedGraphLouvain.nodes.forEach(node => {
        let communityId = node.community;
        if (!communityCounts[communityId]) communityCounts[communityId] = 0;
        communityCounts[communityId]++;
    });

    Object.entries(communityCounts).forEach(([communityId, count], index) => {
         
let color = getColor(index);
communityColors[communityId] = color; // üî• enregistre la couleur

        let legendItem = document.createElement("div");
        legendItem.classList.add("legend-item");
        legendItem.innerHTML = `
            <span class="color-dot" style="background-color: ${color};"></span>
            <span class="legend-label">C${communityId} (${count})</span>
        `;

        legendItem.addEventListener("click", function () {
          //  console.log(`üìå Affichage de la communaut√© ${communityId} avec ${count} n≈ìuds`);
            displayCommunity(communityId);
        });

        legendItemsContainer.appendChild(legendItem);
    });

    //  Ajuste dynamiquement le nombre de colonnes
    legendItemsContainer.style.columnCount = Math.ceil(Object.keys(communityCounts).length / 15);

    //  Ajouter un bouton pour afficher toutes les communaut√©s
    let showAllButton = document.createElement("button");
    showAllButton.textContent = "TOUTES";
    showAllButton.classList.add("show-all-button");
	
	showAllButton.addEventListener("click", function () {
       // console.log("üìå Affichage de toutes les communaut√©s");
        
		 displayGraph(storedGraphLouvain);
    });
	
	//  Ajouter un bouton pour masquer la l√©gende des communaut√©s
    let hideButton = document.createElement("button");
    hideButton.textContent = "Masquer";
    hideButton.classList.add("hide-legend-button");

    hideButton.addEventListener("click", function () {
        legendContainer.style.display = "none"; //  Cache la l√©gende lorsqu'on clique sur "Masquer"
    });
	

    legendContainer.appendChild(showAllButton);
	legendContainer.appendChild(hideButton);
}
///////// FIN FONCTION POUR APPLIQUER L'ALGORITHME DE LOUVAIN COMMUNAUTES SUR LE GRAPHE AFFICH√â //////////
	
	
///////////GRAPHE de spatialisation des noeuds FORCEATLAS2 //////////////////  
function startForceAtlas2(data)
{
	s.graph.nodes().forEach(node => {
    if (node.x === undefined || node.y === undefined) {
        console.error(`‚ö†Ô∏è Probl√®me de coordonn√©es pour le n≈ìud ${node.id} (${node.label})`);
		}
	});	
	
	// repositionememt des nodes avant calcul
	s.graph.nodes().forEach(node => {
		node.x = Math.random();
		node.y = Math.random();
	});

				s.startForceAtlas2({
									worker: true,
									barnesHutOptimize: true,
									barnesHutTheta: 0.5,
									scalingRatio: 2,
									gravity: 4
									});
	// Arr√™ter ForceAtlas2 apr√®s 5 secondes
		setTimeout(() => {
			if (isForceAtlas2Running)
			{
			//console.log("‚úÖ Contenu de s.graph :", s.graph);
			//console.log("‚úÖ Type de s.graph.nodes :", typeof s.graph.nodes, Array.isArray(s.graph.nodes));
			//console.log("‚úÖ Type de s.graph.edges :", typeof s.graph.edges, Array.isArray(s.graph.edges));

			s.stopForceAtlas2();  // fonction defini dans sigmajs
			//console.log('ForceAtlas2 arr√™t√© automatiquement apr√®s 5 secondes.');
		
			//console.log("‚úÖ Graphe apr√®s ForceAtlas2 :", s.graph);
			//console.log("‚úÖ Type de s.graph.nodes :", typeof s.graph.nodes, Array.isArray(s.graph.nodes));
			//console.log("‚úÖ Type de s.graph.edges :", typeof s.graph.edges, Array.isArray(s.graph.edges));
			
		// ‚úÖ R√©cup√©rer le graphe affich√© sous forme JSON
        let currentGraph = {
            nodes: [...s.graph.nodes()],
            edges: [...s.graph.edges()]
        };

        // ‚úÖ R√©afficher le graphe actuel
		  
		displayGraph(currentGraph , { rescale: false } );
		 
			}
		}, 5000); // 5000 millisecondes = 5 secondes	
		 
	}	 	
///////////FIN graphe de spatialisation Forceatlas2 //////////////////


////   MATRICE BINAIRE

function exportMatrice() {

  // ‚ñ∂Ô∏è Construire liste des adjectifs avec +0 synonymes
 
const synonymEdges = s.graph.edges();


  const synonymMap = new Map();

  synonymEdges.forEach(e => {
    const a = e.source;
    const b = e.target;

    if (!synonymMap.has(a)) synonymMap.set(a, new Set());
    if (!synonymMap.has(b)) synonymMap.set(b, new Set());

    synonymMap.get(a).add(b);
    synonymMap.get(b).add(a);
  });
  
	//console.log("üìå synonymMap :", synonymMap);
	//console.log("üìå Noeuds avec plus de 0 synonymes :", Array.from(synonymMap.entries()).filter(([_, v]) => v.size > 0));

  // ‚ñ∂Ô∏è Ne garder que les adjectifs avec plus de 0 synonymes
  const adjectifs = Array.from(synonymMap.entries())
    .filter(([_, voisins]) => voisins.size > 0)
    .map(([mot]) => mot)
    .sort();

  // ‚ñ∂Ô∏è Matrice binaire
  const matrice = adjectifs.map(a1 =>
    adjectifs.map(a2 => synonymMap.get(a1)?.has(a2) ? 1 : 0)
  );
  
const idToLabel = new Map();
s.graph.nodes().forEach(n => idToLabel.set(n.id, n.label || n.id));

let csv = 'mot,' + adjectifs.map(id => idToLabel.get(id)).join(',') + '\n';

adjectifs.forEach((mot, i) => {
  csv += [idToLabel.get(mot), ...matrice[i]].join(',') + '\n';
});


  // ‚ñ∂Ô∏è T√©l√©charger le fichier CSV
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'matrice_synonymes_filtr√©e.csv';
  a.click();
  URL.revokeObjectURL(url);

  showNotif("‚úÖ Matrice de synonymie export√©e. Fichier CSV dans votre dossier de T√©l√©chargement.");
}
document.getElementById("export-matrix-btn").addEventListener("click", exportMatrice);
////  FIN MATRICE BINAIRE

////MATRICE DES distances
document.getElementById("export-path-btn").addEventListener("click", () => {
  if (!s || s.graph.nodes().length === 0) {
    showNotification("‚ùå Aucun graphe affich√©.");
    return;
  }

  const nodesAffiches = s.graph.nodes();
  const nodeIdsAffiches = nodesAffiches.map(n => n.id);

  // ‚úÖ Construire un graphe complet √† partir du graphe initial
  const fullGraph = {};
  storedGraphInitial.nodes.forEach(n => {
    fullGraph[n.id] = [];
  });
  storedGraphInitial.edges.forEach(edge => {
    fullGraph[edge.source].push(edge.target);
    fullGraph[edge.target].push(edge.source); // graphe non orient√©
  });

  // ‚úÖ Fonction pour calculer distances depuis un n≈ìud avec BFS
  function calculDistancesDepuis(sourceId) {
    const distances = {};
    const visited = new Set();
    const queue = [[sourceId, 0]];

    while (queue.length > 0) {
      const [current, dist] = queue.shift();
      if (visited.has(current)) continue;
      visited.add(current);
      distances[current] = dist;
      for (let neighbor of fullGraph[current]) {
        if (!visited.has(neighbor)) {
          queue.push([neighbor, dist + 1]);
        }
      }
    }
    return distances;
  }

  // ‚úÖ Calculer distances entre les mots affich√©s
  const distances = {};
  nodeIdsAffiches.forEach(id => {
    distances[id] = calculDistancesDepuis(id);
  });

  // ‚úÖ Cr√©er un dictionnaire ID ‚Üí label
  const idToLabel = {};
  nodesAffiches.forEach(n => idToLabel[n.id] = n.label);

  // ‚úÖ G√©n√©ration CSV avec labels et distances
  let csv = "Label," + nodeIdsAffiches.map(id => `"${idToLabel[id]}"`).join(",") + "\n";
  nodeIdsAffiches.forEach(i => {
    csv += `"${idToLabel[i]}",` +
           nodeIdsAffiches.map(j => {
             if (i === j) return 0;
             return distances[i][j] !== undefined ? distances[i][j] : -1;
           }).join(",") +
           "\n";
  });

  // ‚úÖ T√©l√©charger le fichier
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  link.setAttribute("href", URL.createObjectURL(blob));
  link.setAttribute("download", "matrice_distances.csv");
  link.style.display = "none";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  showNotif ("‚úÖ Matrice des distances export√©e. Fichier CSV dans votre dossier de T√©l√©chargement.");
});
//// FIN MATRICE DES distances


///// IMPORTER DES MOTS

// ‚ñ∂Ô∏è Quand on clique sur le bouton, on simule le clic du champ fichier
document.getElementById("btn-importer-mots").addEventListener("click", () => {
    document.getElementById("file-mots-import").click();
});

// ‚ñ∂Ô∏è Quand un fichier est s√©lectionn√©
document.getElementById("file-mots-import").addEventListener("change", function (e) {
    const fichier = e.target.files[0];
    if (!fichier) {
        alert("‚ùå Aucun fichier s√©lectionn√©.");
        return;
    }

    importerEtAfficherMotsDepuisCSV(fichier);

    // ‚úÖ Remettre le champ √† vide pour autoriser le m√™me fichier une prochaine fois
    this.value = null;
});

function importerEtAfficherMotsDepuisCSV(fichier) {
    const reader = new FileReader();

    reader.onload = function (e) {
        const contenu = e.target.result.trim();

        // üîç Extraire les mots import√©s
        const motsImport√©s = contenu
            .split(',')
            .map(m => m.trim())
            .filter(m => m.length > 0);

        // ‚úÖ V√©rifications de format via le tableau
        if (motsImport√©s.length === 0) {
            alert("‚ùå Aucun mot valide d√©tect√© dans le fichier. Assurez-vous qu'il contient une seule ligne de mots s√©par√©s par des virgules.");
            return;
        }

        // (optionnel) V√©rifie s'il y a des sauts de ligne suspects
        if (contenu.includes('\n')) {
            alert("‚ùå Le fichier semble contenir plusieurs lignes. Seule une ligne de mots s√©par√©s par des virgules est attendue.");
            return;
        }

        const nodesToShow = [];
        const motsNonTrouv√©s = [];
        const labelToNode = {};

        storedGraphInitial.nodes.forEach(node => {
            labelToNode[node.label] = node;
        });

        motsImport√©s.forEach(mot => {
            const node = labelToNode[mot];
            if (node) {
                nodesToShow.push({ ...node });
            } else {
                motsNonTrouv√©s.push(mot);
            }
        });

        if (nodesToShow.length === 0) {
            alert("‚ùå Aucun mot trouv√© dans le graphe.");
            return;
        }

        const subgraph = {
            nodes: nodesToShow,
            edges: []
        };

        displayGraph(subgraph);
        showNotification(`‚úÖ ${nodesToShow.length} mot(s) affich√©(s).`);

        if (motsNonTrouv√©s.length > 0) {
            alert("‚ö†Ô∏è Mots non trouv√©s dans le graphe :\n" + motsNonTrouv√©s.join(', '));
        }
    };

    reader.readAsText(fichier);

}
///FIN IMPORTER DES MOTS


//// CHEMIN ENTRE 2 MOTS
let modeCheminActif = false;
let selectedNode1 = null;
let grapheAvantChemin = null;
let surlignageActif = null;

document.getElementById("btn-mode-chemin").addEventListener("click", () => {
  modeCheminActif = true;
  selectedNode1 = null;
  //vedette = null;
  document.getElementById("btn-mode-chemin").classList.add("active");
  showNotification("Mode chemin activ√© : cliquez sur deux mots.");
  console.log("modeCheminActif",modeCheminActif);
});

console.log("modeCheminActif",modeCheminActif);
	s.bind('clickNode', function (e) {
  const clickedNode = e.data.node;

  // ‚úÖ Mode CHEMIN entre deux mots activ√©
  if (modeCheminActif) {
    if (selectedNode1 && clickedNode.id === selectedNode1.id) {
      selectedNode1 = null;
      s.refresh();
      showNotification("‚ö†Ô∏è S√©lection annul√©e.");
      return;
    }

    if (selectedNode1 && selectedNode1.originalColor)
      selectedNode1.color = selectedNode1.originalColor;

    if (!selectedNode1) {
      if (!clickedNode.originalColor) clickedNode.originalColor = clickedNode.color;
      clickedNode.color = "#FF0000";
      selectedNode1 = clickedNode;
      s.refresh();
      showNotification(`1er mot : <strong>${clickedNode.label}</strong>`);
      return;
    }

    const node1 = selectedNode1;
    const node2 = clickedNode;
    selectedNode1 = null;
    modeCheminActif = false;
    document.getElementById("btn-mode-chemin").classList.remove("active");

    // recherche du chemin dans le graphe affich√©
    const chemin = trouverChemin(currentDisplayedGraph, node1.label, node2.label);
	// recherche du chemin dans le graphe initial
    //const chemin = trouverChemin(storedGraphInitial, node1.label, node2.label);
    if (!chemin) {
      showNotification(`‚ùå Aucun chemin entre <strong>${node1.label}</strong> et <strong>${node2.label}</strong>.`);
      s.refresh();
      return;
    }

    const distance = chemin.length - 1;
    const labels = chemin.map(id => {
      const n = storedGraphInitial.nodes.find(n => n.id === id);
      return n ? n.label : id;
    });

    showNotif(`‚úÖ <strong>Chemin entre ${node1.label} et ${node2.label}</strong>
			(${distance} √©tape${distance > 1 ? 's' : ''}) :<br>${labels.join(" ‚Üí ")}`);


   // grapheAvantChemin = JSON.parse(JSON.stringify(currentDisplayedGraph));
    surlignageActif = "chemin";
    afficherCheminDansGraphe(chemin, storedGraphInitial);
  }

  // ‚úÖ Sinon : comportement classique vedette
else {
    // ‚úÖ Clic sur un n≈ìud : Met √† jour les infos SEULEMENT si c'est un autre n≈ìud
    s.bind('clickNode', function(e) {
        let node = e.data.node;
		
		vedette = e.data.node ;
		highlightNode(vedette.id);
		
		//console.log("üìå Noeud s√©lectionn√© par clic(vedette) :", vedette);
		//console.log("vedette =", vedette, "typeof =", typeof vedette);
		 // ‚úÖ Active les boutons pour g√©n√©rer des sous-graphes
        document.getElementById("show-neighbors-btn").disabled = false;
        document.getElementById("show-syno2-btn").disabled = false;
        document.getElementById("show-adjacency-btn").disabled = false;

        // ‚úÖ Mettre √† jour les infos seulement si on clique sur un NOUVEAU n≈ìud
        if (vedette !== node.id) {
            vedette = node;  // ‚úÖ Stocke le n≈ìud s√©lectionn√©
            
            var infoText = document.getElementById('info-text');

            var infoHTML = `                        						 
                	<p><strong style="font-size: 20px; font-weight: bold; color:red ">${node.label}</strong></p>	
					<p>Variantes: ${node.variantes?.join(', ') || 'Aucune'}</p>
					<p>Nombre de synonymes: ${node["nombre de synonymes"] || '0'}</p>
					<p>Synonymes: ${node.synonymes?.join(', ') || 'Aucun'}</p>
					<p>Antonymes: ${node.antonymes?.join(', ') || 'Aucun'}</p>
                           
					<p>Cliques: ${node.cliques?.map(clique => clique.join(', ')).join('; ') || 'Aucune'}</p>
					<p>Liste10: ${node.liste10?.map(item => item.map(subItem => subItem.join(': ')).join(', ')).join('; ') || 'Aucune'}</p>
				`;

            infoText.innerHTML = infoHTML;
        }
    });

    // ‚úÖ CLIC DANS LE GRAPHE HORS D'UN N≈íUD => Effacer les infos
    s.bind('clickStage', function() {
        vedette = null;  // ‚úÖ R√©initialise la m√©moire du dernier n≈ìud
        document.getElementById('info-text').innerHTML = '<p>Survoler ou Cliquez sur un n≈ìud pour voir les donn√©es associ√©es.</p><p>Cliquer dans le graphe HORS des n≈ìuds pour les cacher.</p><p>Zoom disponible</p>';
    });
  }
 
});
////FIN  CHEMIN ENTRE 2 MOTS




	
<!-- FIN BOUTONS DE LA GESTION DES GRAPHES  -->


/////////////////////// GESTION DES EVENEMENTS ////////////////////


// ‚úÖ Fonction pour trouver le chemin le plus court entre deux mots dans le graphe
function trouverChemin(graph, sourceLabel, targetLabel) {
  const idLabelMap = {};
  const labelIdMap = {};

  graph.nodes.forEach(n => {
    idLabelMap[n.id] = n.label;
    labelIdMap[n.label] = n.id;
  });

  const sourceId = labelIdMap[sourceLabel];
  const targetId = labelIdMap[targetLabel];

  if (!sourceId || !targetId) return null;

  const visited = new Set();
  const queue = [[sourceId]];

  while (queue.length > 0) {
    const path = queue.shift();
    const current = path[path.length - 1];

    if (current === targetId) return path;

    if (visited.has(current)) continue;
    visited.add(current);

    graph.edges.forEach(edge => {
      if (edge.source === current && !visited.has(edge.target)) {
        queue.push([...path, edge.target]);
      } else if (edge.target === current && !visited.has(edge.source)) {
        queue.push([...path, edge.source]);
      }
    });
  }

  return null;
}

  
/////// Fonction pour gerer le CLIC GAUCHE sur les n≈ìuds
 function ClicNodeEvents(s) {
  s.bind('clickNode', function (e) {
    const clickedNode = e.data.node;

    // ‚úÖ MODE CHEMIN ENTRE 2 MOTS
    if (modeCheminActif) {
      if (selectedNode1 && clickedNode.id === selectedNode1.id) {
        selectedNode1 = null;
        s.refresh();
        showNotification("‚ö†Ô∏è S√©lection annul√©e.");
        return;
      }

      if (selectedNode1 && selectedNode1.originalColor)
        selectedNode1.color = selectedNode1.originalColor;

      if (!selectedNode1) {
        if (!clickedNode.originalColor) clickedNode.originalColor = clickedNode.color;
        clickedNode.color = "#1eff00";
        selectedNode1 = clickedNode;
        s.refresh();
        // ‚úÖ 1er mot s√©lectionn√©
		showNotification(`1er mot : <strong>${clickedNode.label}</strong>`);
        return;
      }
	  
	  const node1 = selectedNode1;
      const node2 = clickedNode;
	 node2.color = "#1eff00";
	 s.refresh();
	   // ‚úÖ 2e mot s√©lectionn√©
	   showNotification(`2·µâ mot : <strong>${node2.label}</strong><br>`);
      selectedNode1 = null;
      modeCheminActif = false;
      document.getElementById("btn-mode-chemin").classList.remove("active");

      const chemin = trouverChemin(storedGraphInitial, node1.label, node2.label);
      if (!chemin) {
        showNotification(`‚ùå Aucun chemin entre <strong>${node1.label}</strong> et <strong>${node2.label}</strong>.`);
        s.refresh();
        return;
      }

//grapheAvantChemin = s.graph.export();  // ‚úÖ juste avant d'afficher les couleurs du chemin


	// ‚úÖ Colorer tous les n≈ìuds du chemin
		chemin.forEach(id => {
		const n = s.graph.nodes(id);
			if (n) {
			if (!n.originalColor) n.originalColor = n.color;
			n.color = "#1bcc53";
			}
		});
		
	// ‚úÖ Colorer les ar√™tes du chemin  
		for (let i = 0; i < chemin.length - 1; i++) {
		const source = chemin[i];
		const target = chemin[i + 1];

		s.graph.edges().forEach(edge => {
		const match = (edge.source === source && edge.target === target)
               || (edge.source === target && edge.target === source);
			if (match) {
			if (!edge.originalColor) edge.originalColor = edge.color;
			edge.color = "#1bcc53";
			}
		});
}


s.refresh();

      const distance = chemin.length - 1;
      const labels = chemin.map(id => {
        const n = storedGraphInitial.nodes.find(n => n.id === id);
        return n ? n.label : id;
      });

     

showNotif(`‚úÖ <strong>Chemin, dans le graphe complet, entre ${node1.label} et ${node2.label}</strong> (${distance} √©tape${distance > 1 ? 's' : ''}) :<br>${labels.join(" ‚Üí ")}`);

      //grapheAvantChemin = s.graph.export();

      surlignageActif = "chemin";
      //afficherCheminDansGraphe(chemin, storedGraphInitial);
      return; // ‚õî on sort : pas de gestion classique dans ce mode
    }

    // ‚úÖ MODE NORMAL ‚Äî Affichage vedette + infos
    vedette = clickedNode;
    highlightNode(vedette.id);

    document.getElementById("show-neighbors-btn").disabled = false;
    document.getElementById("show-syno2-btn").disabled = false;
    document.getElementById("show-adjacency-btn").disabled = false;

    var infoText = document.getElementById('info-text');
    var infoHTML = `
      <p><strong style="font-size: 20px; font-weight: bold; color:red ">${clickedNode.label}</strong></p>	
      <p>Variantes: ${clickedNode.variantes?.join(', ') || 'Aucune'}</p>
      <p>Nombre de synonymes: ${clickedNode["nombre de synonymes"] || '0'}</p>
      <p>Synonymes: ${clickedNode.synonymes?.join(', ') || 'Aucun'}</p>
      <p>Antonymes: ${clickedNode.antonymes?.join(', ') || 'Aucun'}</p>
      <p>Cliques: ${clickedNode.cliques?.map(clique => clique.join(', ')).join('; ') || 'Aucune'}</p>
      <p>Liste10: ${clickedNode.liste10?.map(item => item.map(subItem => subItem.join(': ')).join(', ')).join('; ') || 'Aucune'}</p>
    `;
    infoText.innerHTML = infoHTML;
  });

  // ‚úÖ CLIC HORS D‚ÄôUN N≈íUD : RESET
  s.bind('clickStage', function () {
    if (surlignageActif === "chemin" && grapheAvantChemin) {
      displayGraph(grapheAvantChemin);
      grapheAvantChemin = null;
    } else {
      s.graph.nodes().forEach(n => {
        if (n.originalColor) n.color = n.originalColor;
      });
      s.graph.edges().forEach(e => {
        if (e.originalColor) e.color = e.originalColor;
      });
      s.refresh();
    }

    modeCheminActif = false;
    selectedNode1 = null;
    vedette = null;
    surlignageActif = null;

    //document.getElementById('btn-mode-chemin').classList.remove('active');
   // document.getElementById('chemin-resultat').innerHTML = '';
    document.getElementById('info-text').innerHTML = `
      <p>Survoler ou Cliquez sur un n≈ìud pour voir les donn√©es associ√©es.</p>
      <p>Cliquer dans le graphe HORS des n≈ìuds pour les cacher.</p>
      <p>Zoom disponible</p>
    `;
  });
}

  /////// FIN de la fonction pour gerer les evenements au CLIC GAUCHE des n≈ìuds 
 
 ///gestion du CLIC DROIT SUR UN NOEUD
 function RightClickNodeEvents(s) {
  s.bind('rightClickNode', function (e) {
    const node = e.data.node;
    const nodeId = node.id;

    // ‚úÖ R√©initialiser toutes les couleurs
    s.graph.nodes().forEach(n => {
      n.color = n.originalColor || '#ccc';
    });
    s.graph.edges().forEach(edge => {
      edge.color = edge.originalColor || '#999';
    });

    // ‚úÖ Mettre le n≈ìud cliqu√© en rouge
    if (!node.originalColor) node.originalColor = node.color;
    node.color = '#FF0000';

    const neighborLabels = new Set(); // üß† pour √©viter les doublons

    // ‚úÖ Colorer les voisins et les ar√™tes
    s.graph.edges().forEach(edge => {
      if (edge.source === nodeId || edge.target === nodeId) {
        if (!edge.originalColor) edge.originalColor = edge.color;
        edge.color = '#FF0000';

        const neighborId = edge.source === nodeId ? edge.target : edge.source;
        const neighbor = s.graph.nodes(neighborId);
        if (neighbor) {
          if (!neighbor.originalColor) neighbor.originalColor = neighbor.color;
          neighbor.color = '#FF0000';
          neighborLabels.add(neighbor.label); // ‚úÖ enregistrer le label du voisin
        }
      }
    });

    s.refresh();

    const degree = neighborLabels.size;
    const neighborList = Array.from(neighborLabels).sort().join(", ");

    // ‚úÖ Message enrichi avec la liste des voisins
    showNotif(`<strong>${node.label}</strong> a ${degree} lien(s) dans le graphe affich√©.<br><br><em>Liens vers : </em> ${neighborList}`);
  });


  // clic droit hors d‚Äôun n≈ìud ‚Üí r√©initialisation
 s.bind('clickStage', function () {
  s.graph.nodes().forEach(n => {
    if (n.originalColor) n.color = n.originalColor;
  });
  s.graph.edges().forEach(e => {
    if (e.originalColor) e.color = e.originalColor;
  });
  s.refresh();
});

}
///FIN gestion du CLIC DROIT SUR UN NOEUD

  
 /////// Fonction pour gerer les evenements SURVOL DES N≈íUDS
  function SurvolNoeud(s) {
    s.bind('overNode', function(e) {
    var node = e.data.node;
		
        // ‚úÖ Affichage temporaire dans une info-bulle (tooltip)
        var tooltip = document.getElementById('node-tooltip');
        tooltip.innerHTML = `<strong>${node.label}</strong><br>
                            <p>Nombre de synonymes: ${node["nombre de synonymes"] || '0'}</p>
							<p>Synonymes: ${node.synonymes?.join(', ') || 'Aucun'}</p>`;
							
        tooltip.style.display = "block";
        tooltip.style.left = `${e.data.captor.clientX + 10}px`;
        tooltip.style.top = `${e.data.captor.clientY + 10}px`;
    });

    s.bind('outNode', function() {
        var tooltip = document.getElementById('node-tooltip');
        tooltip.style.display = "none";  // ‚úÖ Cache l'info-bulle quand la souris quitte le n≈ìud
    });
}
 /////// FIN de la fonction pour gerer les evenements SURVOL DES N≈íUDS
  
	 

// Charger le graphe lorsque la page est pr√™te
//  window.onload = loadGraph;

 
</script>
<!-- fin du script js----------------------------------------------------------------------------------------------------- -->
  
   
  
</body>
</html>
