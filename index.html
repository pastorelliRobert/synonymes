<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualisation de Graphe avec Sigma.js</title>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/sigma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/plugins/sigma.layout.forceAtlas2.min.js"></script>

 <script src="./bundle.js"></script>
 
 <script>
window.addEventListener("load", function () {
    console.log("📌 Vérification après chargement complet des scripts...");

    console.log("📌 Vérification de sigma :", window.sigma);
    console.log("📌 Vérification de forceatlas2 :", window.forceAtlas2);
    console.log("📌 Vérification de graphology :", window.graphology);
    console.log("📌 Vérification de pandemonium :", window.pandemonium);
    console.log("📌 Vérification de graphology-indices :", window.graphologyIndices);
    console.log("📌 Vérification de graphology-communities-louvain :", window.graphologyCommunitiesLouvain);
});
</script>
 
  <link rel="icon" href="data:,">
 
<!-- STYLE----------------------------------------------------------------------------------------------------- -->
 <style>
 
.container {
    display: flex;
    justify-content: space-between;
    align-items: stretch;  /* ✅ Toutes les colonnes prennent la même hauteur */
    height:90vh;  /* ✅ Utilise toute la hauteur de l'écran */
}

/* ✅ Colonne de gauche */
#left-panel {
    width: 250px;
    padding: 1px;
    border-right: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}


/* ✅ Colonne de droite */
#right-panel {
    width: 250px;
    padding: 1px;
    border-left: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

/* ✅ Zone du graphe - Ajuste la hauteur automatiquement */
#graph-container {
    flex-grow: 1;
	max-height:100vh;  /* ✅ Permet au graphe de prendre la même hauteur que les colonnes */
    border: 1px solid #ccc;
    background: #f9f9f9;
    display: flex;
    align-items: stretch;  /* ✅ Ajuste le graphe à la hauteur de son parent */
	position: relative; /* ✅ Cette ligne est essentielle */
    overflow: hidden;    /* ✅ Pour éviter les débordements */
}

/* ✅ Style du conteneur de recherche */
#search-container {
    padding: 5px;
    border: 2px solid #ddd;
    background: #f9f9f9;
    margin-bottom: 4px;
    border-radius: 2px;
	position: relative
}


/* ✅ Style de la zone de saisie et du bouton */
#node-search {
    width: 90%;
    padding: 8px;
    margin-bottom: 5px;
    border: 2px solid #ccc;
    border-radius: 4px;
}

#search-node-btn {
    width: 90%;
    padding: 8px;
    font-size: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#search-node-btn:hover {
    background-color: #2980b9;
}

#search-initial-btn  {
    width: 90%;
    padding: 8px;
    font-size: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#search-initial-btn:hover {
    background-color: #2980b9;
}


/* ✅ Liste des résultats de recherche */
#search-results {
    list-style-type: none;
    padding: 0;
    margin: 5px 0;
    max-height: 100px;
    overflow-y: auto;
    border: 1px solid #ccc;
    background: white;
    border-radius: 4px;
}

#search-results li {
    padding: 8px;
    cursor: pointer;
    transition: background 0.3s;
    border-bottom: 1px solid #ddd;
}

#search-results li:hover {
    background: #f1f1f1;
}


#info-text {
    flex-grow: 1;
    overflow-y: auto;
    max-height: 150px;
    max-width: 230px;
    word-wrap: break-word;
    padding: 10px;
    border: 1px solid #ccc; /* ✅ Bordure pour démarquer */
    background: #f9f9f9; /* ✅ Fond clair */
    border-radius: 4px; /* ✅ Arrondi des coins */
	margin-bottom: 5px;  /* ✅ Ajoute de l'espace sous cette zone */
}


#info-buttons {
    display: flex;
    flex-direction: column;
    gap: 5px;  /* ✅ Espacement entre les boutons */
	margin-bottom: 6px; 
    padding-top: 10px; /* ✅ Ajoute de l’espace au-dessus des boutons */
}

button {
    width: 90%;  
    padding: 10px;
    font-size: 12px;
    background-color: #3498db; 
    color: white;
    border: none;
    border-radius: 4px; 
    cursor: pointer;
    transition: background 0.3s ease;
	margin-bottom: 10px;  /* Augmente l'espacement sous chaque bouton */
}


/* Effet au survol */
button:hover {
    background-color: #2980b9;
}


#show-neighbors-btn {
    width: 100%;
    padding: 5px;
    font-size: 12px;
    background-color:  #ff9933  ; /* ✅ synonymes  */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#show-neighbors-btn:hover {
    background-color: #d35400;
}

#show-neighbors-btn:disabled {
    background-color: #bdc3c7; /* ✅ Gris quand désactivé */
    cursor: not-allowed;
}

#show-syno2-btn {
    width: 100%;
    padding: 8px;
    font-size: 12px;
    background-color: #e67e22  ; /* ✅ syno2*/
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#show-syno2-btn:hover {
    background-color:  #d35400;
}

#show-syno2-btn:disabled {
    background-color: #bdc3c7; /* ✅ Gris quand désactivé */
    cursor: not-allowed;
}

#show-adjacency-btn {
    width: 100%;
    padding: 8px;
    font-size: 12px;
    background-color: #b35900; /* ✅  bouton adjacence */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
	margin-bottom: 1px;
}

#show-adjacency-btn:hover {
    background-color: #d35400;
}

#show-adjacency-btn:disabled {
    background-color: #bdc3c7; /* ✅ Gris quand désactivé */
    cursor: not-allowed;
}

#graph-management {
    padding: 10px;
    border: 4px solid #2980b9;  /* ✅ Bordure épaisse bleue */
    border-radius: 8px;  /* ✅ Coins arrondis */
    background: #f9f9f9;  /* ✅ Fond clair */
    text-align: center;
    margin-top: 10px;
}

#graph-management h3 {
    margin-top: 0;
    font-size: 12px;
    color: #2980b9;
}
#community-legend {    /* COMMUNAUTES */
    width: auto;
    max-width: 220px; /* ✅ Réduit la largeur du cadre pour 2 colonnes */
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* ✅ Meilleur alignement à gauche */
    padding: 5px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    position: relative;
    top: 1px;
    left: 1px;
    z-index: 10;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
}

/* ✅ Conteneur des pastilles avec 2 colonnes */
#community-items {
    display: flex;
    flex-wrap: wrap;
    max-height: 500px;
    overflow-y: auto;
    gap: 5px;
    justify-content: space-between;
}

/* ✅ Éléments de la légende (adaptés pour 2 colonnes) */
.legend-item {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    transition: all 0.3s ease-in-out;
    width: calc(50% - 10px); /* ✅ Deux colonnes maximum */
    min-width: 90px;
}

/* ✅ Pastille de couleur */
.color-dot {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    transition: transform 0.2s ease-in-out;
}

/* ✅ Effet zoom au survol */
.legend-item:hover .color-dot {
    transform: scale(1.2);
}

/* ✅ Labels des communautés */
.legend-label {
    font-size: 14px;
    font-weight: bold;
}

/* ✅ Style du bouton "Toutes Communautés" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
}

.show-all-button:hover {
    background-color: #2980b9;
}

#hide-legend-zone {
    width: 80%;
    text-align: center;
    padding: 5px;
    background: #a3a3c2;
    color: white;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
}

#hide-legend-zone:hover {
    background: #c0392b;
}

#show-legend-btn {
    padding: 5px;
    background: #2ecc71;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    display: none;
}

#hide-legend-btn {
    width: 100%;
    margin-top: 10px;
    padding: 5px;
    background-color: #bdc3c7;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#hide-legend-btn:hover {
    background-color:  #a3a3c2;
}

#connected-components-legend {   /* CONNEXES */
    width: auto;
    max-width: 220px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    padding: 5px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    position: relative;         
    top: 1px;               
    left: 1px;            
    z-index: 10;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
}


/* ✅ Conteneur avec scroll activé après 10 lignes (2 colonnes × 10 = 20 pastilles) */
#legend-items {
    display: flex;
    flex-wrap: wrap;
    max-height: calc(10 * 36px); /* 36px = hauteur approximative par ligne de pastilles */
    overflow-y: auto;
    gap: 5px;
    justify-content: space-between;
}

/* ✅ Chaque pastille prend la moitié de la ligne = 2 colonnes */
.legend-item {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    transition: all 0.3s ease-in-out;
    width: calc(50% - 10px); 
    min-width: 90px;
    box-sizing: border-box; /* ✅ Pour une meilleure cohérence d’affichage */
}

/* ✅ Pastilles */
.color-dot {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    border: 1px solid #000;
    transition: transform 0.2s ease-in-out;
}

/* ✅ Zoom au survol */
.legend-item:hover .color-dot {
    transform: scale(1.2);
}

.legend-label {
    font-size: 14px;
    font-weight: bold;
}

/* ✅ Style du bouton "Toutes Composantes" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db; /* ✅ Bleu Sigma.js */
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
}

.show-all-button:hover {
    background-color: #2980b9; /* ✅ Bleu foncé au survol */
}

/* ✅ Bouton "TOUTES Communautés" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
    width: 100%;
}

.show-all-button:hover {
    background-color: #2980b9;
}

/* ✅ Bouton "Masquer" */
.hide-legend-button {
    margin-top: 5px;
    background-color: #bdc3c7;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
    width: 100%;
	 display: block; /* ✅ Assurer qu'il est bien affiché */
}

.hide-legend-button:hover {
    background-color: #e74c3c; /* ✅ Rouge au survol */
}

#graph-stats-display {
    position: absolute;
    top: 1px;
    left: 1px;
    background-color: rgba(255, 255, 255, 0.85);
    padding: 4px 8px;
    font-size: 12px;
    border-radius: 4px;
    font-weight: bold;
    z-index: 10;
    border: 1px solid #ccc;
}

 /* ✅ Style pour la notification */
.graph-notification {
    position: absolute;
    top: 1px;
    left: 800px;
    background-color: #33cc33;
    color: #336600;
    border: 2px solid #ccc;
    padding: 8px 12px;
    border-radius: 5px;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    font-size: 14px;
    z-index: 9999;
    display: none;
    max-width: 300px;
}
#graph-message {
  position: fixed;
  top: 60px;
  left: 60px;
  max-width: 400px;
  max-height: 600px;
  overflow-y: auto;
  background-color: #99ddff;
  border: 1px solid #ccc;
  padding: 10px;
  font-size: 14px;
  color: #333;
  z-index: 3000;
  border-radius: 6px;
  box-shadow: 0 0 10px rgba(0,0,0,0.2);
}




  </style>
  <!-- FIN STYLE----------------------------------------------------------------------------------------------------- -->


</head>
<body>

 <h1>Graphe de synonymes (adjectifs).</h1>

<!-- DIV----------------------------------------------------------------------------------------------------- -->

  <div class="container">
  
  <!-- ✅ Colonne de gauche (Infos & Recherche par mot) -->
	<div id="left-panel"> 
		
		<div id="graph-management">
		<h3>Approche individuelle</h3>
		
			<button id="graphe-initial" title="Affiche le graphe de tous les mots existants." style=" background-color:  #66ccff;" >Graphe initial complet</button>
			<div id="info-text">	 
			<p>Survoler un nœud pour voir des données associées.</p>
			<p>Clic gauche sur un nœud pour le sélectionner (vedette) et afficher ici toutes les données associées.</p>
			<p>Clic droit sur un nœud pour des informations.</p>
			 
			<p>Zoom disponible</p>
			</div>
			
			<div id="search-container">
			<input type="text" id="node-search" placeholder="Rechercher un nœud..." />
			<button id="search-initial-btn" title="Liste des mots contenant les caractères saisis ci-dessus, dans le graphe initial complet" >Rechercher dans le graphe initial</button>
			<button id="search-node-btn"   title="Liste des mots contenant les caractères saisis ci-dessus, dans le graphe affiché." >Rechercher dans le graphe affiché</button>
			<ul id="search-results"></ul>
			</div>	
			
			<!-- ✅ boutons pour afficher les graphes de la vedette -->
			<button id="show-neighbors-btn" title="Synonymes (voisins) du mot sélectionné" disabled>Synonymes</button>
			 
			<button id="show-adjacency-btn" title="Relations de synonymie entre les synonymes de rang 1 du mot sélectionné" disabled>Adjacence</button>	
			<div id="info-buttons"></div>
			
			<button id="show-syno2-btn" title="Synonymes de rang 1 et de rang 2 du mot sélectionné" disabled>Synonymes 1 et   2</button>
			
		<h3>Approche globale</h3>
			<button id="completude-btn" title="Relations de synonymie entre tous les mots affichés" style=" background-color: #b35900;" >Complétude</button>
			<button id="extension-btn" title="Ajout des synonymes de tous les mots affichés" style=" background-color: #ff9933;" >Extension</button>
			<button id="show-histo-btn" title="Histogramme du graphe affiché : nombre de liens/nombre de mots" style=" background-color: #99ddff;">Histogramme</button>
		</div>
		
	</div>

	
<!-- ✅ Zone d'affichage du graphe -->	
	<div id="graph-container">
	
	
		<!-- ✅ Notification placée en haut à gauche du conteneur -->
		<div id="graph-stats-display">0 points, 0 liens</div>
		
		<!-- ✅ Notification placée en haut à droite du conteneur -->
		<div id="notification" class="graph-notification">Notification...</div>
	 
		<div id="graph-message" style="display: none;">
			<!-- le message sera injecté ici par JS -->
		</div>
		
	</div>

		<!-- Légende des communautés  -->
		<div id="community-legend"style="display: none;" >
		<h3>Communautés</h3>
		<button id="hide-legend-btn">Masquer</button> <!--  Bouton pour cacher -->
		<div id="legend-items"></div> <!--  Contiendra les pastilles -->
		</div>
	
		 
		<!-- Légende des composantes connexes  -->
		<div id="connected-components-legend" style="display: none;">
		<h3>Composantes connexes</h3>
		<div id="legend-items"></div>  <!--  Contiendra les pastilles -->
		</div>
		
	
	
<!-- ✅ Colonne de droite (gestion des graphes) -->
    <div id="right-panel">

		<div id="graph-management">
			<h3>Gestion des graphes</h3>
			
			
			<button id="store-graph-en-0" title="Enregistre le graphe affiché (supprime l'enregistrement précédent)" style="background-color: #9999ff;">STOCKER</button>
			<button id="show-stored-graph0" title="Affiche le graphe stocké" style="background-color: #9999ff;" >AFFICHER</button>
			
			<button id="store-graph-en-1" title="Enregistre le graphe affiché (ne supprime pas l'enregistrement précédent)" style=" background-color: #0066ff;" >Ajouter au CUMUL</button>
			<button id="subtract-graph-en-1" title="Retire le graphe affiché du CUMUL " style=" background-color: #0066ff;" >Soustraire du CUMUL</button>
			<button id="show-stored-graph1"  style=" background-color:#0066ff;" >Afficher le CUMUL</button>
			<button id="reset-stored-graph-1"style=" background-color: #0066ff;" >Vider le CUMUL</button>
			
			<button id="export-graph"  title="Exporte le fichier correspondant au graphe affiché, au format JSON, dans votre dossier Téléchargement" style=" background-color: #8533ff;" >Exporter le graphe</button>
			<button id="import-graph"  title="Importe un fichier, au format JSON compatible, à partir de votre ordinateur" style=" background-color: #8533ff;" >Importer un graphe</button>
			<input type="file" id="import-file" accept=".json" style="display: none;" />
			<button id="export-label" title="Copie la liste des mots du graphe affiché dans un fichier CSV de votre dossier Téléchargement" style=" background-color: #8533ff;" >Exporter les mots</button>
			<button onclick="exportGraphToPDF()">Exporter le graphe en PDF</button>

		 
			<h3>Traitements sur graphes</h3>	
			
			<button id="show-connected-components-btn" title="Colorie les composantes connexes du graphe affiché (sous ensembles de mots disjoints)">Connexes</button>
			<button id="detect-communities" title="Colorie les sous groupes de mots fortement interconnectés (algorithme de Louvain)">Communautés</button>
			<button id="show-legend-btn" style="display:none;">Afficher la légende</button>
			<button id="toggle-forceatlas2" style="background-color: #00b3b3;" title="Optimisation de la disposition spatiale du graphe affiché " >Arrêter-démarrer ForceAtlas2</button>	
		</div>	
		 
		
	</div>	
<!-- ✅ bouton aide -->	
	<button id="help-btn"
        style="position: fixed; top: 10px; right: 300px;left:400px; width: 60px;
               z-index: 1000; padding: 10px 16px;
               background-color: #33cc33; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;">
   Aide
</button>
<!-- ✅ contenu aide -->	
<div id="help-modal"
     style="display: none; position: fixed; top: 20%; left:20%; width: 30%;
            background: white; border: 1px solid #ccc; padding: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1); font-size: 14px; z-index: 2000;">
  <h2>Aide</h2>
	<p>Affichage et analyse du graphe de mots (2217 adjectifs) liés par la relation de <strong>synonymie</strong>. </p>
	<p>La synonymie est issue du DÉS (Dictionnaire Électronique des Synonymes),</p>
	<p>mis à disposition sur Internet par le laboratoire CRISCO de l’Université de Caen.</p>
	<p> -</p>
	<p>Cette page Web offre quelques outils d'analyse de ce graphe.</p>
	<p>Vous pouvez <strong>survoler</strong> les points (mots) du graphe,</p>
	<p><strong>clic gauche</strong> pour en sélectionner un (vedette), </p>
	<p><strong>clic droit</strong> pour afficher des informations, </p>
	<p>utiliser le <strong>zoom</strong> (molette de la souris). </p>
	<p>- </p>
	<p><strong>Survoler les boutons pour en avoir une courte explication.</strong> </p>
			 
	<button onclick="document.getElementById('help-modal').style.display='none'" 
	style="margin-top: 10px;width: 200px;">Fermer</button>              
</div>

	
<!-- ✅ info bulle au survol de noeud -->		
	<div id="node-tooltip"
	style="position: absolute;background: rgba(0, 0, 0, 0.8);color: white;
	padding: 5px;border-radius: 5px;display: none;font-size: 14px;	z-index: 1000;">				
    </div>

</div>

<!-- FIN DES DIV----------------------------------------------------------------------------------------------------- -->
 
 
<!-- scrip js----------------------------------------------------------------------------------------------------- -->
 <script>
 
//////////////DECLARATION GLOBALE pour une utilisation partout////////////////////////////// 

	let storedGraphInitial = null; //variable de stockage du graphe initial : fichier json
    let storedGraphLouvain = null; //variable de stockage du graphe Louvain
	let isForceAtlas2Running = false;
	let storedGraph0 = { nodes: [], edges: [] }; //variable de stockage du graphe  
	let storedGraph1 = { nodes: [], edges: [] };  // ✅ Initialise un graphe vide
	let baseGraphForComponents = null;  // ✅ Stocke le graphe de référence pour la détection des connexes
	let isFirstComponentDetection = true;  // ✅ Vérifie si c'est le premier calcul des connexes
	let s; // Déclarez `s` dans la portée globale pour qu'elle soit accessible dans toutes les fonctions
	let vedette = null; //stocke l'ID du noeud sélectionné
	let communityColors = {};


//////////////FIN DECLARATION GLOBALE ////////////////////////////// 

//////////<!-- CHARGER LES DONNÉES INITIALES a partir de DATA.JSON -->//////
 async function loadGraph() {
      try {
			<!-- LES DONNÉES xxxxx.JSON SONT DANS LE MEME DOSSIER QUE INDEX.HTML  -- ------->
			const response = await fetch('datafinal.json');
			const data = await response.json();

		// Vérifier que les données contiennent les propriétés nodes et edges
        if (data && data.nodes && data.edges) {
			console.log('✅Les données chargées contiennent bien les propriétés nodes et edges.');
			//couleur présentes dans le fichier json
			//console.log("🎨 Vérification des couleurs des nœuds :", data.nodes.map(n => n.color));
			//console.log("🎨 Vérification des couleurs des arêtes :", data.edges.map(e => e.color));

		// Initialiser Sigma.js
			 s = new sigma (
				{ graph: data, container: 'graph-container',
					settings: {
					drawEdges: false,  // ✅ Désactive complètement l'affichage des arêtes
					// defaultNodeColor: 'blue',
					// nodeHoverColor: 'yellow',
					minNodeSize: 5,  // Taille minimale des nœuds
					maxNodeSize: 5,	// Taille maximale des nœuds
					//minEdgeSize: 0.01,
					//maxEdgeSize: 0.01
					}
				});
		} else {
				console.error('Les données chargées ne contiennent pas les propriétés nodes et edges.');
				}
			<!-- FIN DE CHARGER LES DONNÉES INITIALE -->			
			console.log("✅ Données du graphe initial chargées :", data);
			//console.log("✅ Type de data.nodes :", typeof data.nodes, Array.isArray(data.nodes));
			//console.log("✅ Type de data.edges :", typeof data.edges, Array.isArray(data.edges));
	
	// survol des noeuds
	SurvolNoeud(s);
	
	// Événements au clic des nœuds
	ClicNodeEvents(s);
	
	// ❌ Bloque le menu contextuel
	document.getElementById("graph-container").addEventListener("contextmenu", function (e)
		{
			e.preventDefault(); 
		});
	
	// chargement du graphe initial dans storedGraphInitial	
	storedGraphInitial = storeGraph(s.graph);

	if (!vedette && storedGraphInitial.nodes.length > 0) {
        vedette = storedGraphInitial.nodes[0];  // ✅ Prend le premier nœud du graphe initial
		  console.log("✅`vedette` initialisé automatiquement sur :", vedette.label);
		}
<!-- FIN DU TRY DE CHARGEMENT  -->
     } catch (error) {
					console.error('Erreur lors du chargement du fichier JSON:', error);
					}
	
	//affichage du graphe initial
	 displayGraph (storedGraphInitial);
	
  } 
  /////////////////////<!-- FIN DU CHARGER LES DONNÉES INITIALES a partir de DATA.JSON  -->/////
	
	


///zone de MESSAGES à l'utilisateur //////

///messages à durée déterminée 	courte
function showNotification(message, duration = 2000) {
    const notif = document.getElementById("notification");
    notif.innerText = message;
    notif.style.display = "block";

    setTimeout(() => {
        notif.style.display = "none";
    }, duration);
}

///messages avec bouton "fermer" incorporé
function showNotif(message) {
  const notif = document.getElementById("graph-message");
  if (notif) {
    notif.innerHTML = `
      ${message}
      <br>
      <button onclick="document.getElementById('graph-message').style.display='none'"
              style="margin-top: 10px; padding: 4px 10px; background:#ccc; border:none; border-radius:4px;">
        Fermer
      </button>
    `;
    notif.style.display = "block";
  }
}
////fin MESSAGES ////////////

//AFFICHAGE STATS (nbre points et aretes) coin haut gauche du cadre du graphe
function updateGraphStats(graphData) {
    const nbNodes = graphData.nodes.length;
    const nbEdges = graphData.edges.length;
    const statsDiv = document.getElementById("graph-stats-display"); 
    statsDiv.textContent = `${nbNodes} point${nbNodes > 1 ? 's' : ''}, ${nbEdges/2} lien${nbEdges > 1 ? 's' : ''}`;
}
// FIN AFFICHAGE STATS


///////////// AFFICHAGE DES GRAPHES  ///////	DISPLAYGRAPH   ///////////////////////////
function displayGraph(graphData) {
  if (s) { s.kill(); } // Détruire l'instance actuelle de Sigma.js

	const nodeCount = graphData.nodes.length;
	const isSmallGraph = nodeCount < 50;
	
	console.log("📌 Nb de nœuds reçus dans displayGraph:", graphData.nodes.length);


	// 🎯 Taille et couleur des nœuds
	graphData.nodes.forEach(node => {
		// 🔴 Vedette : toujours en rouge
		if (vedette && node.id === vedette.id) {
		node.color = "#e74c3c";
		}
		// 🎨 Sinon : conserver couleur existante
		node.originalColor = node.color;

		node.size = (vedette && node.id === vedette.id)
		? (isSmallGraph ? 24 : 8)
		: (isSmallGraph ? 10 : 4);
	});


	// 🧊 Couleur des arêtes
	graphData.edges.forEach(edge => {
	if (!edge.color) {
    edge.color = isSmallGraph
      ? "rgba(0, 0, 255, 1)"
      : "rgba(0, 0, 255, 0.3)";
	}
	if (!edge.originalColor) {
    edge.originalColor = edge.color;
	}
});

	// Sauvegarde des couleurs initiales pour restauration ultérieure
	graphData.nodes.forEach(node => {
	if (!node.originalColor) node.originalColor = node.color;
	});
	graphData.edges.forEach(edge => {
	if (!edge.originalColor) edge.originalColor = edge.color;
	});

  // 🚀 Création de l’instance Sigma
  if (graphData) {
    s = new sigma({
      graph: graphData,
      container: 'graph-container',
      settings: {
        minEdgeSize: 0.4,
        maxEdgeSize: 0.4,
       // labelSize: "fixed",
        labelThreshold: isSmallGraph ? 1 : 6,
        labelSizeRatio: isSmallGraph ? 1 : 0.3,
        font: "Arial",
        fontsize: isSmallGraph ? 12 : 6,
        defaultLabelColor: "#000"
		//defaultEdgeColor: "rgba(0, 0, 0, 0)"  // ✅ Couleur transparente
      }
	  
    });
//console.log("isSmallGraph", isSmallGraph );
  
  s.refresh();
	  
	//affiche les stats
	  updateGraphStats(graphData);
	   
	// survol des noeuds
	  SurvolNoeud(s);
	  
	// Afficher des informations au clic gauche des nœuds
      ClicNodeEvents(s);
   
	// Afficher des informations au clic droit des nœuds	 
	   RightClickNodeEvents(s); 
  }
}
  //////////// FIN FONCTION POUR AFFICHER UN GRAPHE  
  
  
   // Charger le graphe lorsque la page est prête
    window.onload = loadGraph;
		

<!-- BOUTONS DE l'APPROCHE INDIVIDUELLE  -->	

//// RECHERCHE D'UN NOEUD DANS LE GRAPHE AFFICHÉ////////////////////////////////////////////
document.getElementById("search-node-btn").addEventListener("click", function() {
    let searchTerm = document.getElementById("node-search").value.toLowerCase().trim();
    let resultsContainer = document.getElementById("search-results");
    resultsContainer.innerHTML = "";  // ✅ Efface les résultats précédents

    let foundNodes = s.graph.nodes().filter(node => node.label.toLowerCase().includes(searchTerm));

    if (foundNodes.length > 0) {
        foundNodes.forEach(node => {
            let listItem = document.createElement("li");
            listItem.innerHTML = `<strong>${node.label}</strong>`;
            listItem.style.cursor = "pointer";
            listItem.style.padding = "5px";
            listItem.style.borderBottom = "1px solid #ddd";
            
			listItem.addEventListener("click", function() {
				highlightNode(node.id);  // ✅ Met en évidence le nœud sélectionné
				selectedNodeId = node.id;  // ✅ Stocke l'ID du nœud sélectionné
				
				vedette = node  ;     // ✅ Stocke le nœud sélectionné via recherche
		//console.log("📌 Noeud sélectionné via recherche dans affiché :", vedette);
			
			// ✅ Active les boutons
				document.getElementById("show-neighbors-btn").disabled = false; 
				document.getElementById("show-syno2-btn").disabled = false;
				document.getElementById("show-adjacency-btn").disabled = false; // ✅ Active le bouton "Graphe d'adjacence"
			
			
			resultsContainer.innerHTML = "";  // ✅ Masque la liste après sélection
            });

            resultsContainer.appendChild(listItem);
        });
    } else {
        resultsContainer.innerHTML = "<li>Aucun nœud trouvé.</li>";
    }
});

function highlightNode(nodeId) {
    s.graph.nodes().forEach(node => {
        node.color = (node.id === nodeId) ? "#e74c3c" : "#3498db"; // 🔴 Rouge pour le nœud trouvé, 🔵 Bleu pour les autres
    });
    s.refresh();  // ✅ Met à jour l'affichage du graphe
}
//// FIN de RECHERCHE D'UN NOEUD DANS LE GRAPHE AFFICHÉ/////////////////////////////////////


// 🔍 RECHERCHE D'UN NOEUD DANS LE GRAPHE INITIAL (TOUS les nœuds)////////////////////////
document.getElementById("search-initial-btn").addEventListener("click", function() {
    let searchTerm = document.getElementById("node-search").value.toLowerCase().trim();
    let resultsContainer = document.getElementById("search-results");
    resultsContainer.innerHTML = "";  // ✅ Efface les résultats précédents

    let foundNodes = storedGraphInitial.nodes.filter(node => node.label.toLowerCase().includes(searchTerm));

    if (foundNodes.length > 0) {
        foundNodes.forEach(node => {
            let listItem = document.createElement("li");
            listItem.innerHTML = `<strong>${node.label}</strong>`;
            listItem.style.cursor = "pointer";
            listItem.style.padding = "5px";
            listItem.style.borderBottom = "1px solid #ddd";

            listItem.addEventListener("click", function() {
                highlightNode(node.id);  // ✅ Met en évidence le nœud sélectionné dans le graphe affiché
                vedette = node ;  // ✅ Stocke tout l'objet du nœud sélectionné
               		    
    //console.log("📌 Noeud sélectionné via recherche dans initial :", vedette);
		
                // ✅ Active les boutons
                document.getElementById("show-neighbors-btn").disabled = false; 
                document.getElementById("show-syno2-btn").disabled = false;
                document.getElementById("show-adjacency-btn").disabled = false;

                resultsContainer.innerHTML = "";  // ✅ Masque la liste après sélection
            });

            resultsContainer.appendChild(listItem);
        });
    } else {
        resultsContainer.innerHTML = "<li>Aucun nœud trouvé.</li>";
    }
});
// 🔍 FIN Recherche d'un noeud dans le graphe initial (TOUS les nœuds)////////////////////////


//////////// GRAPHE DES SYNONYMES = VOISINS de la vedette /////////// 
// CLIC sur le bouton "synonymes" => afficher les voisins de la vedette (graphe)
document.getElementById("show-neighbors-btn").addEventListener("click", function () {
  if (!vedette) {
    showNotification("❌ Aucun nœud sélectionné !");
    return;
  }
  console.log("📌graphe des voisins pour la vedette :", vedette.id);


  // ✅ Filtrer toutes les arêtes contenant le nœud sélectionné
  let subGraphEdges = storedGraphInitial.edges.filter(
  edge => edge.source === vedette.id || edge.target === vedette.id  );

  // ✅ Extraire les nœuds impliqués dans ces arêtes
  let neighborIds = new Set();
  subGraphEdges.forEach(edge => {
    neighborIds.add(edge.source);
    neighborIds.add(edge.target);
  });

  // ✅ Inclure les nœuds du graphe initial
  let subGraphNodes = storedGraphInitial.nodes.filter(node => neighborIds.has(node.id));

	let subGraph = { nodes: subGraphNodes, edges: subGraphEdges };
	// ✅ Vérification dans la console avant affichage
    //console.log("📌 Sous-graphe Syno1 généré :", { nodes: subGraphNodes, edges: subGraphEdges });

  
     vedette.color =  "#e74c3c"  ; // 🔴 Rouge pour la vedette
    
	console.log("vedette.color", vedette.color);
	// ✅ Appliquer les couleurs pour forcer vedette rouge, autres en bleu
	subGraphNodes.forEach(node => {
	node.color = (node.id === vedette.id) ? "#e74c3c" : "#3498db";
	});


	// ✅ Afficher le sous-graphe
	displayGraph(subGraph);
});
//// fin de calcul et affichage du graphe des VOISINS = SYNONYMES
  
  
////fonction pour calculer et afficher le graphe SYNO2 d'une VEDETTE
document.getElementById("show-syno2-btn").addEventListener("click", function() {
    if (!vedette) {
        showNotification("❌ Aucun nœud sélectionné !");
        return;
    }
	//console.log("📌 Génération du graphe des SYNO2 pour :", vedette);

    // ✅ Étape 1 : Trouver les voisins directs (niveau 1)
    let level1Neighbors = new Set();
    storedGraphInitial.edges.forEach(edge => {
        if (edge.source === vedette.id) level1Neighbors.add(edge.target);
        if (edge.target === vedette.id) level1Neighbors.add(edge.source);
    });

    // ✅ Étape 2 : Trouver les voisins des voisins (niveau 2)
    let level2Neighbors = new Set();
    level1Neighbors.forEach(neighborId => {
        storedGraphInitial.edges.forEach(edge => {
            if (edge.source === neighborId && edge.target !== vedette.id) level2Neighbors.add(edge.target);
            if (edge.target === neighborId && edge.source !== vedette.id) level2Neighbors.add(edge.source);
        });
    });

    // ✅ Étape 3 : Construire le sous-graphe "syno2"
    let allSyno2Nodes = new Set([...level1Neighbors, ...level2Neighbors, vedette.id]);

	 let subGraphNodes = storedGraphInitial.nodes.filter(node => allSyno2Nodes.has(node.id)).map(node => {
        // ✅ Lire les attributs directement depuis storedGraphInitial
        let originalNode = storedGraphInitial.nodes.find(n => n.id === node.id) || { "nombre de synonymes": 0, "synonymes": [] };
        return {
            ...node,
            "nombre de synonymes": originalNode["nombre de synonymes"],  // ✅ Ajoute les synonymes
            "synonymes": originalNode["synonymes"]
        };
    });

    let subGraphEdges = storedGraphInitial.edges.filter(edge => allSyno2Nodes.has(edge.source) && allSyno2Nodes.has(edge.target));

	let subGraph = { nodes: subGraphNodes, edges: subGraphEdges };
	 
    // ✅ Vérification dans la console avant affichage
    //console.log("📌 Sous-graphe Syno2 généré :", { nodes: subGraphNodes, edges: subGraphEdges });

    // ✅ Afficher le sous-graphe "syno2"
    displayGraph( subGraph );
});
////FIN fonction   GRAPHE SYNO2 D'UNE VEDETTE
  

//// Graphe ADJACENCE /////////////////////////////////////////////
document.getElementById("show-adjacency-btn").addEventListener("click", function() {
    if (!vedette) {
        showNotification("❌ Aucun nœud sélectionné !");
        return;
    }

    //console.log("📌 Génération du graphe d'adjacence pour :", vedette);

    // ✅ Étape 1 : Trouver les voisins directs (niveau 1)
    let level1Neighbors = new Set();
    storedGraphInitial.edges.forEach(edge => {
        if (edge.source === vedette.id) level1Neighbors.add(edge.target);
        if (edge.target === vedette.id) level1Neighbors.add(edge.source);
    });

    // ✅ Étape 2 : Trouver les voisins des voisins (niveau 2)
    let level2Neighbors = new Set();
    level1Neighbors.forEach(neighborId => {
        storedGraphInitial.edges.forEach(edge => {
            if (edge.source === neighborId && edge.target !== vedette.id) level2Neighbors.add(edge.target);
            if (edge.target === neighborId && edge.source !== vedette.id) level2Neighbors.add(edge.source);
        });
    });

    // ✅ Étape 3 : Construire le sous-graphe Syno2
    let allSyno2Nodes = new Set([...level1Neighbors, ...level2Neighbors, vedette.id]);

    let subGraphNodes = storedGraphInitial.nodes.filter(node => allSyno2Nodes.has(node.id));

    // ✅ Créer un Set des IDs des nœuds valides pour éviter l'erreur
    let validNodeIds = new Set(subGraphNodes.map(node => node.id));

    // ✅ Filtrer les arêtes pour ne garder que celles qui connectent des nœuds existants
    let subGraphEdges = storedGraphInitial.edges.filter(edge =>
        validNodeIds.has(edge.source) && validNodeIds.has(edge.target)
    );

    // ✅ Étape 4 : Garder uniquement `vedette` et ses voisins directs **avec leurs connexions**
    let adjacencyNodes = new Set([...level1Neighbors, vedette.id]);  // ✅ On garde `vedette` et ses voisins directs
    let finalNodes = storedGraphInitial.nodes.filter(node => adjacencyNodes.has(node.id));  // ✅ Récupérer les nœuds valides

    let finalEdges = subGraphEdges.filter(edge =>  // ✅ Vérification supplémentaire pour éviter les erreurs
        adjacencyNodes.has(edge.source) && adjacencyNodes.has(edge.target)
    );

    let adjacencyGraph = { nodes: finalNodes, edges: finalEdges };

    //console.log("📌 Graphe d'adjacence généré :", adjacencyGraph);

    // ✅ Vérification avant affichage
    //console.log("📌 Vérification des nœuds :", adjacencyGraph.nodes);
    //console.log("📌 Vérification des arêtes :", adjacencyGraph.edges);

    // ✅ Afficher le Graphe d'adjacence
    displayGraph(adjacencyGraph);


    // ✅ Supprimer l’ancien bouton s’il existe déjà
    const existingBtn = document.getElementById("remove-vedette-links-btn");
    if (existingBtn) existingBtn.remove();

    // ✅ Créer dynamiquement le bouton
    const btn = document.createElement("button");
    btn.id = "remove-vedette-links-btn";
    btn.textContent = "Adjacence sans liens avec la vedette";
    btn.classList.add("hide-vedette-edges-btn");
    
	btn.style.height = "15px";
	btn.style.width = "200px";
	btn.style.marginTop = "1px"; /* ✅  espace au-dessus du bouton */
	btn.style.fontSize = "11px";
    btn.style.backgroundColor = "#ffd9b3";
    btn.style.color = "black";
    btn.style.border = "none";
    btn.style.padding = "2px";
    btn.style.borderRadius = "5px";
    btn.style.cursor = "pointer";

    document.getElementById("info-buttons").appendChild(btn);

    btn.addEventListener("click", function () {
        const edgesToRemove = s.graph.edges().filter(edge =>
            edge.source === vedette.id || edge.target === vedette.id
        );
        edgesToRemove.forEach(edge => {
            s.graph.dropEdge(edge.id);
        });
        s.refresh();
        showNotif(` ✅ Liens avec "${vedette.label}" supprimés.`);
        btn.remove(); // ✅ Disparaît après usage
    });
	
});
//// FIN Graphe ADJACENCE //////////////////////////////////


//////COMPLETUDE du graphe affiché
//fonction associée au bouton "Complétude"
document.getElementById("completude-btn").addEventListener("click", completeGraphEdgesFromInitial);

function completeGraphEdgesFromInitial() {
    if (!s || s.graph.nodes().length === 0) {
        console.warn("❌ Aucun graphe affiché pour la complétude.");
        return;
    }
    const currentNodes = s.graph.nodes();
    const currentEdges = s.graph.edges();
    const currentNodeIds = new Set(currentNodes.map(n => n.id));

    // 🔍 Construire un ensemble d'arêtes existantes (source+target ou target+source)
    const existingEdgeKeys = new Set(
        currentEdges.map(e => {
            const a = [e.source, e.target].sort().join("↔");
            return a;
        })
    );
    const completedEdges = [];
    storedGraphInitial.edges.forEach(edge => {
        if (
            currentNodeIds.has(edge.source) &&
            currentNodeIds.has(edge.target)
        ) {
            const edgeKey = [edge.source, edge.target].sort().join("↔");

            // ✅ Si l’arête est déjà présente, on la garde telle quelle
            if (existingEdgeKeys.has(edgeKey)) {
                completedEdges.push(edge);
            }
            // ✅ Sinon, on ajoute une nouvelle arête en gris
            else {
                completedEdges.push({
                    ...edge,
                    color: "#7f8c8d"  // 🎨 Gris pour les nouvelles arêtes
                });
            }
        }
    });
    const completedGraph = {
        nodes: [...currentNodes],
        edges: completedEdges
    };
    console.log("📌 Arêtes totales :", completedEdges.length/2);    
	displayGraph(completedGraph);
	
}
//////FIN COMPLETUDE du graphe affiché

	
///////EXTENSION ajout des syno au graphe affiché	///////////////
// fonction associée au bouton "Extension"
document.getElementById("extension-btn").addEventListener("click", function () {
    extendGraph();
});

function extendGraph() {
    //console.log("📌 Début de l'extension du graphe...");

    // ✅ Vérifier si un graphe est affiché
    if (!s || s.graph.nodes().length === 0) {
        console.warn("❌ Aucun graphe affiché. Impossible d'étendre.");
        return;
    }
    // ✅ Récupérer les nœuds et arêtes du **graphe affiché** (A)
    let baseNodes = [...s.graph.nodes()];
    let baseEdges = [...s.graph.edges()];
    
    let baseNodeIds = new Set(baseNodes.map(node => node.id)); // 🔹 Ensemble des IDs des nœuds existants (A)

   // console.log(`📌 Nœuds initiaux du graphe affiché :`, baseNodeIds.size);
   // console.log(`📌 Arêtes initiales du graphe affiché :`, baseEdges.length/2);
    //console.log(`📌 IDs des nœuds initiaux :`, baseNodeIds);

    // ✅ Trouver les synonymes (voisins) des nœuds du graphe affiché dans `storedGraphInitial`
    let newNodes = new Set(); // 🔹 Stocke les synonymes à ajouter (B - A)
    let newEdges = []; // 🔹 Stocke les nouvelles arêtes

    baseNodes.forEach(node => {
        let nodeId = node.id;
        
        // 🔍 Récupérer les voisins (= synonymes) via les arêtes dans le graphe initial
        let synonyms = storedGraphInitial.edges
            .filter(edge => edge.source === nodeId || edge.target === nodeId) // ✅ Garde les arêtes connectées à `nodeId`
            .map(edge => edge.source === nodeId ? edge.target : edge.source); // 🔄 Récupère l’autre extrémité

        synonyms.forEach(synonym => {
            if (!baseNodeIds.has(synonym)) {  // ✅ Ne garder que les synonymes **absents** de A
                newNodes.add(synonym);		
            }
        });
    });

    //console.log(`📌 Synonymes uniques ajoutés (B - A) :`, newNodes.size);

    // ✅ Ajouter les nouvelles arêtes entre les synonymes et les nœuds initiaux
    storedGraphInitial.edges.forEach(edge => {
        if (
            (baseNodeIds.has(edge.source) && newNodes.has(edge.target)) ||
            (baseNodeIds.has(edge.target) && newNodes.has(edge.source))
        ) {
            newEdges.push(edge); // ✅ Ajoute uniquement les arêtes valides
        }
    });
    console.log(`📌 Nouvelles arêtes ajoutées :`, newEdges.length/2);

    // ✅ Générer le graphe étendu
    let extendedGraph = {
        nodes: [...baseNodes], // 🔹 On commence avec A
        edges: [...baseEdges, ...newEdges] // 🔹 On ajoute les nouvelles arêtes
    };

    // ✅ Ajouter les nouveaux synonymes au graphe avec une couleur différente
    newNodes.forEach(synonym => {
        let originalNode = storedGraphInitial.nodes.find(n => n.id === synonym);
        if (!originalNode) return;
		
        // 🔹 Ajouter les coordonnées du nœud s'il existe dans `storedGraphInitial`
        extendedGraph.nodes.push({
            id: synonym,
            label: originalNode.label ,
			"nombre de synonymes": originalNode["nombre de synonymes"], 
			synonymes: originalNode["synonymes"],
            color: "#8e44ad", // 🎨 Couleur spéciale pour les synonymes (violet)
            size: 1, // 📌 Taille plus petite
            x: originalNode.x || Math.random() * 100, // 🔄 Position aléatoire si absente
            y: originalNode.y || Math.random() * 100
        });
    });
    // ✅ Afficher le nouveau graphe étendu
	 displayGraph (extendedGraph);	
}		 
///////FIN EXTENSION graphe des syno du graphe affiché	///////////////

	
// Fonction pour calculer l'HISTOGRAMME du graphe affiché
function calculateHistogram(nodes, edges) {
    const histogram = {};
    nodes.forEach(node => {
        const degree = edges.filter(edge =>
            edge.source === node.id || edge.target === node.id
        ).length/2;
		 
        if (!histogram[degree]) {
            histogram[degree] = { count: 0, ids: [] };
        }
        histogram[degree].count++;
        histogram[degree].ids.push(node.label);
    });
    return histogram;
}
// Fonction pour formater l'HISTOGRAMME en une chaîne lisible
function formatHistogram(histogram) {
    let formattedMessage = "Histogramme du graphe affiché <br> nombre de liens : nombre de mots (mots dans ce cas)<br>";

    for (const degree in histogram) {
        formattedMessage += `${degree}: ${histogram[degree].count} `;
        if (histogram[degree].ids.length > 0) {
            formattedMessage += ` (${histogram[degree].ids.slice(0, 100).join(', ')})`;
        }
        formattedMessage += "<br>";
    }
    return formattedMessage;
}
// Gestionnaire d'événement pour le bouton
document.getElementById("show-histo-btn").addEventListener("click", function() {
    if (!s) {
        showNotification("❌ Aucun graphe affiché !");
        return;
    }
    // Récupérer les nœuds et arêtes du graphe affiché
    const nodes = s.graph.nodes();
    const edges = s.graph.edges();

    // Calculer l'histogramme
    const histogram = calculateHistogram(nodes, edges);

    // Afficher l'histogramme dans la console
   // console.log("✅ Histogramme du graphe affiché :", histogram);
	
	// Formater l'histogramme en message lisible
    const message = formatHistogram(histogram);
	//console.log("✅ Histogramme du graphe affiché formaté:", message);
    // Afficher l'histogramme dans la zone de notification
    showNotif(message);
});
// FIN Fonction pour calculer l'HISTOGRAMME du graphe affiché

<!-- FIN BOUTONS DE l'APPROCHE INDIVIDUELLE  -->	


<!-- BOUTONS DE LA GESTION DES GRAPHES  -->

// STOCK CUMUL IMPORT EXPORT 

// Fonction pour STOCKER et afficher un graphe en remplacement de celui stocké précédemment
  
	//copie du graphe affiché 
	function storeGraph(graph) 
	{
		let nodes = typeof graph.nodes === "function" ? graph.nodes() : Object.values(graph.nodes);
		let edges = typeof graph.edges === "function" ? graph.edges() : Object.values(graph.edges);
		//console.log("📌 Vérification des attributs des nœuds AVANT stockage :", nodes);

		return {
        nodes: nodes.map(node => ({
            id: node.id,
            label: node.label,
            x: node.x,
            y: node.y,
            size: node.size,
            color: node.color,
            antonymes: node.antonymes || [],   
            variantes: node.variantes || [],
            cliques: node.cliques || [],
            "nombre de synonymes": node["nombre de synonymes"] || 0,   
            "synonymes": node.synonymes || [],  
            //liste10: node.liste10 || []      // NE PAS  Conserver les listes
			})),
        edges: edges.map(edge => ({
            id: edge.id,
            source: edge.source,
            target: edge.target,
            size: edge.size,
            color: edge.color
			}))
		};
	}

	// gestion du bouton "STOKER le graphe affiché "
	document.getElementById("store-graph-en-0").addEventListener("click", function() {
    if (s.graph.nodes().length > 0) {
        storedGraph0 = storeGraph(s.graph);
        //console.log("✅ Graphe affiché stocké par l'utilisateur :", storedGraph0);
		showNotification('✅ Graphe stocké');
    } else {
        console.warn(" Impossible de stocker : aucun nœud dans le graphe.");
    }
});

// gestion du bouton "AFFICHER le graphe STOCKÉ "
    document.getElementById('show-stored-graph0').addEventListener('click', function() {
		if (storedGraph0 && storedGraph0.nodes.length > 0 && storedGraph0.edges.length > 0) { 
		console.log(" nbr nodes dans storedGraph0", storedGraph0.nodes.length);
		displayGraph(storedGraph0);
		} else {
			showNotification('⚠️ Pas de graphe stocké');
		}
	});
	
////////////// Fin de la fonction pour stocker et afficher un graphe


///////////////CUMUL DES GRAPHES//////////////////////////////////

// gestion du bouton AJOUTER AU CUMUL des graphes
	document.getElementById("store-graph-en-1").addEventListener("click", function() {
    if (s.graph.nodes().length > 0) {
        let newGraph = storeGraph(s.graph);  // ✅ Graphe actuel

        if (!storedGraph1 || !storedGraph1.nodes) {  
            storedGraph1 = newGraph;  // ✅ Premier graphe stocké normalement
			showNotification ("✅ Premier graphe ajouté au CUMUL");
        } else {
            // ✅ Vérifier si le graphe actuel est réellement différent avant d'ajouter
            let existingNodes = new Map(storedGraph1.nodes.map(node => [node.id, node])); 
            let existingEdges = new Map(storedGraph1.edges.map(edge => [edge.id, edge])); 

            let isNewGraph = false;

            newGraph.nodes.forEach(node => {
                if (!existingNodes.has(node.id)) {
                    existingNodes.set(node.id, node);
                    isNewGraph = true;
                }
            });

            newGraph.edges.forEach(edge => {
                if (!existingEdges.has(edge.id)) {
                    existingEdges.set(edge.id, edge);
                    isNewGraph = true;
                }
            });

            if (isNewGraph) {
                storedGraph1 = {
                    nodes: Array.from(existingNodes.values()),
                    edges: Array.from(existingEdges.values())
                };
                showNotification("✅ Nouveau graphe ajouté au CUMUL");
            } else {
                showNotification("⚠️ Aucun changement dans la composition des noeuds et arêtes détecté dans le graphe, stockage ignoré.");
            }
        }
    } else {
        console.warn("⚠️ Impossible de stocker : aucun nœud dans le graphe.");
    }
});
//  FIN   gestion du bouton AJOUTER AU CUMUL

// SOUSTRACTION du graphe affiché du CUMUL /////////
document.getElementById("subtract-graph-en-1").addEventListener("click", function () {
    if (!storedGraph1 || !storedGraph1.nodes || storedGraph1.nodes.length === 0) {
        showNotification("❌ Aucun graphe CUMULÉ à modifier !");
        return;
    }

    if (!s || s.graph.nodes().length === 0) {
        showNotification("❌ Aucun graphe affiché à soustraire !");
        return;
    }

    const displayedNodeIds = new Set(s.graph.nodes().map(node => node.id));

    // 1️⃣ Supprimer les nœuds affichés du cumul
    const remainingNodes = storedGraph1.nodes.filter(node => !displayedNodeIds.has(node.id));

    // 2️⃣ Supprimer les arêtes qui touchent un nœud supprimé
    const remainingNodeIds = new Set(remainingNodes.map(node => node.id));
    const remainingEdges = storedGraph1.edges.filter(edge =>
        remainingNodeIds.has(edge.source) && remainingNodeIds.has(edge.target)
    );

    // 3️⃣ Mettre à jour le CUMUL
    storedGraph1 = {
        nodes: remainingNodes,
        edges: remainingEdges
    };

    console.log("📌 Graphe affiché retiré du CUMUL. Nœuds restants :", remainingNodes.length);
    showNotification("✅ Le graphe affiché a été retiré du CUMUL.");
});
// FIN SOUSTRACTION du graphe affiché du CUMUL /////////

// VIDER LE CUMUL DES GRAPHES
	document.getElementById("reset-stored-graph-1").addEventListener("click", function()
	{
		{
			if (storedGraph1 && storedGraph1.nodes.length > 0 && storedGraph1.edges.length > 0) 
			{
			if (confirm("❗ Confirmer le vidage du cumul ? Cette action est irréversible."))		
			
			storedGraph1 = { nodes: [], edges: [] };  // ✅ Réinitialisation complète
			console.log("✅ Graphe stocké dans le cumul réinitialisé :", storedGraph1);
			if (s) {
				s.graph.clear();  // ✅ Effacer l'affichage du graphe
				s.refresh();  // ✅ Rafraîchir Sigma.js
			}
			showNotification("✅ Le cumul des graphes stockés a été éffacé !");			
			}
			else
			{
			showNotification('⚠️ Pas de graphe stocké');	
			};
		};
	});
// FIN VIDER LE CUMUL DES GRAPHES//////////

// AFFICHER LE CUMUL   ////////////// 
    document.getElementById('show-stored-graph1').addEventListener('click', function()
		{
		if (storedGraph1 && storedGraph1.nodes.length > 0 && storedGraph1.edges.length > 0) { 
		displayGraph(storedGraph1);
		} else {
			showNotification('⚠️ Pas de graphe stocké');
		}
	});
/////// FIN AFFICHER LE CUMUL ///

////////////// fonction pour EXPORTER un graphe   
document.getElementById("export-graph").addEventListener("click", function() {
    if (!s) {
        showNotification("❌ Aucun graphe à exporter !");
        return;
    }
	
	// ✅ Récupérer les nœuds et arêtes du graphe affiché
    let graphData = {
        nodes: s.graph.nodes().map(node => ({
            id: node.id,
            label: node.label,
            x: node.x,
            y: node.y,
            size: node.size,
            color: node.color,
            antonymes: node.antonymes || [],
            variantes: node.variantes || [],
            cliques: node.cliques || [],
            liste10: node.liste10 || []
        })),
        edges: s.graph.edges().map(edge => ({
            id: edge.id,
            source: edge.source,
            target: edge.target,
            size: edge.size,
            color: edge.color
        }))
    };

    // ✅ Convertir en JSON
    let jsonString = JSON.stringify(graphData, null, 4);

    // ✅ Créer un blob et un lien de téléchargement
    let blob = new Blob([jsonString], { type: "application/json" });
    let a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    //a.download = "graphe_export.json";  // 📌 Nom du fichier exporté
	let fileName = prompt("Nom pour le fichier exporté, au format JSON, dans le dossier : Téléchargement", "graphe_export.json");
	if (!fileName) return;  // utilisateur a annulé
	a.download = fileName.endsWith(".json") ? fileName : fileName + ".json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    console.log("✅ Exportation réussie !");
});
////////////// FIN fonction pour EXPORTER un graphe   


////////// fonction pour IMPORTER un graphe
// 📌 Quand on clique sur le bouton, déclencher l'ouverture du sélecteur de fichier
document.getElementById("import-graph").addEventListener("click", () => {
    document.getElementById("import-file").click();
});

// 📌 Gérer la sélection d’un fichier JSON
document.getElementById("import-file").addEventListener("change", function (event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();

    reader.onload = function (e) {
        try {
            const importedGraph = JSON.parse(e.target.result);

            // Vérification de base
            if (!importedGraph.nodes || !importedGraph.edges) {
                console.error("❌ Format de graphe invalide.");
                showNotification("Le fichier sélectionné n’est pas un graphe JSON valide.");
                return;
            }

            console.log("📥 Graphe importé :", importedGraph);

            // ✅ Afficher le graphe importé (fonction existante)
			displayGraph(importedGraph);
        } catch (err) {
            console.error("❌ Erreur lors de la lecture du fichier JSON :", err);
            showNotification("Erreur lors de l’import du fichier JSON.");
        }
    };

    reader.readAsText(file);
});
////////// FIN fonction pour IMPORTER un graphe
	

/////////////fontion pour EXPORTER LES MOTS la liste des labels ///////////////////
document.getElementById("export-label").addEventListener("click", function () {
    if (!s || s.graph.nodes().length === 0) {
        alert("❌ Aucun graphe affiché !");
        return;
    }

    // 1. Récupérer les labels
    let labels = s.graph.nodes().map(node => node.label);

    // 2. Trier les labels par ordre alphabétique
    labels.sort((a, b) => a.localeCompare(b, 'fr', { sensitivity: 'base' }));

    // 3. Construire le contenu CSV (une ligne, séparée par des virgules)
   //mots séparés par une ,
   const csvContent = labels.join(","); 
   //labels.join("\n") un mot par ligne

    // 4. Demander le nom du fichier à l'utilisateur
    const fileName = prompt("Nom du fichier CSV à enregistrer dans le dossier : téléchargement  ", "mots_du_graphe.csv");
    if (!fileName) return;

    // 5. Créer et déclencher le téléchargement
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = fileName.endsWith(".csv") ? fileName : fileName + ".csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    console.log("✅ Labels exportés :", labels.length);
});
/////////////FIN fontion pour EXPORTER LA LISTE DES MOTS ///////////////////


function exportGraphToPDF() {
  const container = document.getElementById('graph-container');

  html2canvas(container).then(canvas => {
    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'pt',
      format: [canvas.width, canvas.height]
    });
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
    pdf.save("graphe.pdf");
  });
}


// FIN STOCK CUMUL IMPORT EXPORT ///////////////////////



	
////////// TRAITEMENTS sur graphes  ////////////////////////////////
	
/////// COMPOSANTES CONNEXES //////////////////////////////////////	

// ✅ Génère une couleur unique pour chaque composante
function getColor(index) {
    const colors = [
        "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6", 
        "#1abc9c", "#e67e22", "#d35400", "#34495e", "#95a5a6"
    ];
    return colors[index % colors.length]; // ✅ Réutilise les mêmes couleurs pour chaque composante
}

///////////bouton composantes connexes  
document.getElementById("show-connected-components-btn").addEventListener("click", function() {
    detectConnectedComponents();
});

//////////calcul des composantes CONNEXES
function detectConnectedComponents() {
  
  if (isFirstComponentDetection) {  
        baseGraphForComponents = {  // ✅ Stocke le graphe affiché au premier appel seulement
            nodes: [...s.graph.nodes()],  
            edges: [...s.graph.edges()]
        };
        isFirstComponentDetection = false;  // ✅ Désactive le stockage pour les appels suivants
    }
	else 
	{ 						//	displayGraph (coloredGraph );
	}

   // let nodes = baseGraphForComponents.nodes;  // ✅ Toujours utiliser le même graphe de référence
   // let edges = baseGraphForComponents.edges;

  let nodes = s.graph.nodes();  // ✅ Toujours utiliser le graphe AFFICHÉ
  let edges = s.graph.edges();


    //console.log("📌 Utilisation du graphe affiché pour les composantes :", nodes.length, "nœuds,", edges.length/2, "arêtes");

    // ✅ Construire la liste d'adjacence
    let adjacencyList = {};
    nodes.forEach(node => adjacencyList[node.id] = []);
    
    edges.forEach(edge => {
        adjacencyList[edge.source].push(edge.target);
        adjacencyList[edge.target].push(edge.source);
    });

    // ✅ Détection des composantes connexes via DFS
    let visited = new Set();
    connectedComponents = [];  // ✅ Réinitialise la liste des composantes

    function dfs(nodeId, component) {
        visited.add(nodeId);
        component.push(nodeId);
        adjacencyList[nodeId].forEach(neighbor => {
            if (!visited.has(neighbor)) {
                dfs(neighbor, component);
            }
        });
    }
    nodes.forEach(node => {
        if (!visited.has(node.id)) {
            let component = [];
            dfs(node.id, component);
            connectedComponents.push(component);
        }
    });

    // ✅ Appliquer une couleur différente à chaque composante connexe
	connectedComponents.forEach((component, index) => {
    let color = getColor(index);  // ✅ Utilise la même fonction que la légende
    component.forEach(nodeId => {
        let node = s.graph.nodes(nodeId);
        if (node) node.color = color;
    });
});

    // ✅ Sauvegarde le graphe coloré pour pouvoir le réafficher plus tard
    coloredGraph = { nodes: [...s.graph.nodes()], edges: [...s.graph.edges()] };
 
 console.log("📌 Composantes connexes détectées :", connectedComponents);
 
    // ✅ Rafraîchir l'affichage pour voir toutes les composantes colorées
    s.refresh();
	
	updateConnectedComponentsUI(connectedComponents);
	
//////////APPEL DE LA LEGENDE

// ✅ Mise à jour complète de la légende avant l'affichage
updateConnectedComponentsUI(connectedComponents);
// ✅ Forcer l'affichage de la légende après le calcul des composantes
setTimeout(() => {
let legendContainer = document.getElementById("connected-components-legend");
if (legendContainer) {
    legendContainer.style.display = "block"; // ✅ Assure que la légende est visible
 }
}, 100); // ✅ Petit délai pour que le DOM soit bien mis à jour

}
//////////FIN calcul des composantes CONNEXES

///fonction pour avoir des couleurs
function getColor(index) {
    const colors = [
        "#3498db", "#e74c3c", "#2ecc71", "#f1c40f", "#9b59b6",
        "#1abc9c", "#e67e22", "#d35400", "#34495e", "#95a5a6"
    ];
    return colors[index % colors.length]; // ✅ Assigne une couleur parmi la liste
}

///////////creation dynamique des boutons de CONNEXES
function updateConnectedComponentsUI(components) {

	let legendContainer = document.getElementById("connected-components-legend");

   // ✅ Afficher la légende
    legendContainer.style.display = "block";

    let legendItemsContainer = document.getElementById("connected-components-legend");
	if (legendContainer) {
    legendContainer.style.display = "block"; // ✅ La légende s'affiche dès le premier clic
	 legendContainer.innerHTML = "<h3>Composantes connexes</h3> <div id='legend-items'></div>";
}

    connectedComponents.forEach((component, index) => {
        let color = getColor(index); // 🎨 Fonction qui génère une couleur pour chaque composante
		let nodeCount = component.length; // ✅ Récupère le nombre de nœuds dans la composante

        // ✅ Création d'une pastille de couleur
        let legendItem = document.createElement("div");
        legendItem.classList.add("legend-item");
        legendItem.innerHTML = `
            <span class="color-dot" style="background-color: ${color};"></span>
            <span class="legend-label">C ${index + 1} (${nodeCount})</span> <!-- ✅ Ajoute le nombre de nœuds -->
        `;

		// ✅ Ajuste dynamiquement le nombre de colonnes en fonction du nombre de pastilles
		legendItemsContainer.style.columnCount = Math.ceil(connectedComponents.length / 15); 	

        // ✅ Ajoute un événement au clic
        legendItem.addEventListener("click", function () {
            console.log(`📌 Affichage de la composante ${index + 1} avec ${nodeCount} nœuds`);
            displayComponentGraph(index);
        });

        legendItemsContainer.appendChild(legendItem);
    });

    // ✅ Ajouter un bouton pour afficher toutes les composantes
    let showAllButton = document.createElement("button");
    showAllButton.textContent = "TOUTES";
    showAllButton.style.marginTop = "10px";
    showAllButton.style.backgroundColor = "#3498db";  // Bleu Sigma.js
    showAllButton.style.color = "white";
    showAllButton.style.border = "none";
    showAllButton.style.padding = "8px";
    showAllButton.style.borderRadius = "5px";
    showAllButton.style.cursor = "pointer";
    showAllButton.style.fontSize = "14px";
    showAllButton.style.transition = "background 0.3s ease-in-out";

    // ✅ Changement de couleur au survol
    showAllButton.addEventListener("mouseover", function () {
        showAllButton.style.backgroundColor = "#2980b9"; // Bleu foncé
    });
    showAllButton.addEventListener("mouseout", function () {
        showAllButton.style.backgroundColor = "#3498db"; // Bleu d'origine
    });

    // ✅ Ajoute l'événement de clic pour afficher toutes les composantes
    showAllButton.addEventListener("click", function () {
        console.log("📌 Affichage de toutes les composantes");
         
		displayGraph(coloredGraph);
    });

    // ✅ Ajouter le bouton au conteneur avant le bouton "Masquer"
    legendContainer.appendChild(showAllButton);

    // ✅ Ajouter un bouton pour masquer la legende des connexes
    let hideButton = document.createElement("button");
    hideButton.textContent = "Masquer";
    hideButton.style.marginTop = "10px";
    hideButton.style.backgroundColor = "#bdc3c7";  
    hideButton.style.cursor = "pointer";
	 
	// Ajouter un gestionnaire d'événements pour changer la couleur au survol du bouton masquer
	hideButton.addEventListener("mouseover", function() {
    hideButton.style.backgroundColor = "#FF0000"; // Rouge
	});
	hideButton.addEventListener("mouseout", function() {
    hideButton.style.backgroundColor = "#bdc3c7"; // Couleur d'origine
	});

    hideButton.addEventListener("click", function () {
        legendContainer.style.display = "none";
    });

    legendContainer.appendChild(hideButton);
}
///////////FIN creation dynamique des boutons CONNEXES

///////////////////affichage des CONNEXES
function displayComponentGraph(index) {
 
    let componentNodeIds = new Set(connectedComponents[index]);

    let subGraphNodes = coloredGraph.nodes.filter(node => componentNodeIds.has(node.id));

	// ✅ Appliquer la couleur correcte à chaque nœud
    let color = getColor(index);
    subGraphNodes.forEach(node => {
        node.color = color; // 🎨 Applique la couleur correspondant à la légende
    });
   
   // ✅ Vérification des arêtes : Garde uniquement celles qui connectent les nœuds de la composante
    let subGraphEdges = storedGraphInitial.edges.filter(edge =>
        componentNodeIds.has(edge.source) && componentNodeIds.has(edge.target)
    );
	
    console.log(`📌 Affichage de la composante ${index + 1}:`, subGraphNodes.length, "nœuds et", subGraphEdges.length/2, "arêtes");

    let componentGraph = { nodes: subGraphNodes, edges: subGraphEdges };

     //affiche les stats
	   updateGraphStats(componentGraph );
	      
        // ✅ Effacer l'ancien graphe et recharger uniquement la composante sélectionnée
        s.graph.clear();  // ✅ Efface complètement le graphe actuel
        s.graph.read(componentGraph);  // ✅ Charge les nouveaux nœuds et arêtes
        s.refresh();  // ✅ Rafraîchir l'affichage pour forcer Sigma.js à afficher les nouvelles données
		
		// ✅ Vérification des nœuds et arêtes après le chargement
		// console.log("📌 Nœuds affichés :", s.graph.nodes().length);
		// console.log("📌 Arêtes affichées :", s.graph.edges().length);
		console.log("✅ Composante affichée :", s.graph.nodes().length, "nœuds et", s.graph.edges().length, "arêtes");
}
///////////////////FIN affichage des connexes
/////// FIN COMPOSANTES CONNEXES //////////////////////////////////////		
	
	

///////// FONCTION  calcul COMMUNAUTES SUR LE GRAPHE AFFICHÉ //////////
function detectCommunitiesOnCurrentGraph() {
    if (!s || s.graph.nodes().length === 0) {
        showNotification("❌ Aucun graphe affiché pour calculer les communautés !");
        return;
    }

    //  Créer un graphe graphology à partir du graphe affiché
    const graph = new graphology.Graph();

    // Ajouter les nœuds
    s.graph.nodes().forEach(node => {
        graph.addNode(node.id, { label: node.label });
    });

    // Ajouter les arêtes
    s.graph.edges().forEach(edge => {
        if (graph.hasNode(edge.source) && graph.hasNode(edge.target)) {
            graph.addEdge(edge.source, edge.target);
        }
    });
	
	//console.log("📌 Vérification de graphology :", window.graphology); 
	//console.log("📌 Vérification de graphology-communities-louvain :", window.graphologyCommunitiesLouvain);
	//console.log("📌 Propriétés disponibles :", Object.keys(window.graphologyCommunitiesLouvain));


	// Appliquer l'algorithme de Louvain  ///////////////////
		window.graphologyCommunitiesLouvain.assign(graph ,{
			resolution: 1,  // ✅ Augmente la sensibilité au regroupement
			rng: Math.random, // ✅ Randomisation pour éviter les blocages
		});  
	///////////////////////////////////////////////////////////////////////
  
	//  Vérifier après assign() que les communautés sont bien ajoutées dans graph
	console.log("📌 Communautés détectées A :", Object.fromEntries(s.graph.nodes().map(node => [node.id, node.community])));
		//console.log("📌 Nombre de nœuds dans s.graph avant stockage :", s.graph.nodes().length);
		//console.log("📌 Nombre d’arêtes dans s.graph avant stockage :", s.graph.edges().length);

	//  Vérification détaillée
	const communityData = window.graphologyCommunitiesLouvain.detailed(graph);
	//console.log("📌 Détails des communautés :", communityData);

	//  Récupérer les communautés depuis le graphe
	const communities = {};
	graph.forEachNode((node, attributes) => {
    communities[node] = attributes.community;
	});
	//console.log("📌 Communautés détectées :", communities);

    //  Ajouter la communauté comme attribut de chaque nœud pour Sigma.js
    s.graph.nodes().forEach(node => {
        node.community = communities[node.id] || 0;  //0 si non détecté
    });

    //  Assigner une couleur différente à chaque communauté
    const colorPalette = [
        "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6",
        "#1abc9c", "#e67e22", "#95a5a6", "#34495e", "#8e44ad"
    ];

   s.graph.nodes().forEach(node => {
       node.color = colorPalette[node.community % colorPalette.length] || "#bdc3c7";
    });
		 
    //  Rafraîchir le graphe pour afficher les couleurs des communautés
    s.refresh();
 
	//  Stocker  le graphe avec les communautés et les couleurs dans  storedGraphLouvain
		storedGraphLouvain = { 
		nodes: [...s.graph.nodes()], 
		edges: [...s.graph.edges()] 
		};

	window.graphologyCommunitiesLouvain.assign(graph );

	updateCommunityLegend();  //  Mettre à jour la légende après assignation

	console.log("📌 Stockage dans storedGraphLouvain (après affectation des  communauté) effectué !", storedGraphLouvain);
	
	//console.log("📌 Nœuds dans le graphe affiché :", s.graph.nodes().length);
	//console.log("📌 Nœuds dans storedGraphLouvain :", storedGraphLouvain.nodes.length);
	//console.log("📌 Arêtes dans storedGraphLouvain :", storedGraphLouvain.edges.length/2);
	//console.log("📌 Vérification des attributs des nœuds dans storedGraphLouvain :",
	// storedGraphLouvain.nodes.map(n => ({ id: n.id, community: n.community }))
	//);

	updateCommunityLegend();  //  Mettre à jour la légende après assignation

	//s.graph.nodes().forEach(node => {
	// if (node.community === 0) {
	//     console.warn(`⚠️ Nœud classé 0 : ${node.id} (degré : ${s.graph.degree(node.id)})`);
	// }
	//});
	
}

// 📌 Associer la fonction au bouton "Communautés"
document.getElementById("detect-communities").addEventListener("click", function() {
    detectCommunitiesOnCurrentGraph();
});

/////////// gérer l’affichage du bouton et réafficher la légende 
document.getElementById("show-legend-btn").addEventListener("click", function() {
    let legendContainer = document.getElementById("community-legend");
    legendContainer.style.display = "block";
    this.style.display = "none"; //  Cacher le bouton après affichage
});

///////////////////////////////////////
   function displayCommunity(communityId) {
    console.log(`📌 Affichage de la communauté ${communityId}`);

    //  Vérifier que le graphe initial est bien stocké
    if (!storedGraphLouvain) {
        console.error("❌ ERREUR : le graphe n'est pas défini !");
        return;
    }
	
	//console.log("📌 storedGraphLouvain avant filtrage des communautés " ,storedGraphLouvain );
	//console.log("📌 attributs des nœuds dans storedGraphLouvain avant filtrage des communautés",
    // storedGraphLouvain.nodes.map(n => ({ id: n.id, community: n.community, color: n.color }));
	//console.log(`📌 Type de communityId :`, typeof communityId, `Valeur :`, communityId);
	//  Afficher un exemple de node pour voir son format exact
	//console.log(`📌 Exemple de nœud dans storedGraphLouvain :`, storedGraphLouvain.nodes[0]);

	communityId = Number(communityId); //  Convertit en nombre 
	
	//  Utiliser le graphe initial pour FILTRER les communautés
    let subGraphNodes = storedGraphLouvain.nodes.filter(node => node.community === communityId);
    let nodeIds = new Set(subGraphNodes.map(n => n.id));  

    //console.log(" Nœuds sélectionnés :", subGraphNodes);

    //  Filtrer les arêtes pour ne conserver que celles entre ces nœuds
    let subGraphEdges = storedGraphLouvain.edges.filter(edge => 
        nodeIds.has(edge.source) && nodeIds.has(edge.target)
    );

	//console.log(`📌 Vérification des nœuds trouvés pour communauté ${communityId} :`,
    subGraphNodes.map(n => ({ id: n.id, community: n.community }));

    //console.log(" Arêtes sélectionnées :", subGraphEdges);

    //  Vérifier que des arêtes existent
    if (subGraphEdges.length === 0) {
        console.warn(`⚠️ Aucun edge trouvé pour la communauté ${communityId}`);
    }
	
	//  Trouver la couleur de la pastille associée à la communauté sélectionnée
	let legendItems = document.querySelectorAll(".legend-item");
	 
	let color = communityColors[communityId] || "#3498db";
	
	legendItems.forEach(item => {
    let label = item.querySelector(".legend-label").textContent;
    if (label.includes(`C${communityId} (`)) {
        color = item.querySelector(".color-dot").style.backgroundColor;
    }
	//console.log(` Couleur détectée pour communauté ${communityId} :`, color);
	//console.log(" Contenu exact des labels :", Array.from(legendItems).map(item =>
	//item.querySelector(".legend-label").textContent
 
});

	//  Appliquer la couleur aux nœuds
	subGraphNodes.forEach(node => {
    node.color = color;
});

    let communityGraph = { nodes: subGraphNodes, edges: subGraphEdges };
	// console.log(`📌 Graphe de la communauté ${communityId} généré :`, communityGraph);
	//console.log(`📌 Couleur assignée à la communauté ${communityId}:`, color);
	//console.log("📌 Nœuds colorés :", subGraphNodes.map(n => ({ id: n.id, color: n.color })));

    //  Afficher uniquement cette communauté
	
	console.log(`📌 Affichage de la communauté ${communityId} (${subGraphNodes.length} nœuds)`);

	displayGraph(communityGraph); 
	 
}

//////////////////////////////////////// LEGENDE  COMMUNAUTÉS
function updateCommunityLegend() {
    let legendContainer = document.getElementById("community-legend");
	let legendItemsContainer = document.getElementById("legend-items");

//legendItemsContainer.style.columnCount = Math.ceil(connectedComponents.length / 15); // ✅ Ajuste le nombre de colonnes


	//  Afficher la légende lorsqu'on détecte les communautés
    legendContainer.style.display = "block";
	
    // Vider l'ancienne légende
    legendContainer.innerHTML = "<h3>Communautés</h3><div id='community-items'></div>";
	
   legendItemsContainer = document.getElementById("community-items");

    //  Créer les pastilles pour chaque communauté
    let communityCounts = {};  // 📌 Stocke la population de chaque communauté

    storedGraphLouvain.nodes.forEach(node => {
        let communityId = node.community;
        if (!communityCounts[communityId]) communityCounts[communityId] = 0;
        communityCounts[communityId]++;
    });

    Object.entries(communityCounts).forEach(([communityId, count], index) => {
         
let color = getColor(index);
communityColors[communityId] = color; // 🔥 enregistre la couleur

        let legendItem = document.createElement("div");
        legendItem.classList.add("legend-item");
        legendItem.innerHTML = `
            <span class="color-dot" style="background-color: ${color};"></span>
            <span class="legend-label">C${communityId} (${count})</span>
        `;

        legendItem.addEventListener("click", function () {
            console.log(`📌 Affichage de la communauté ${communityId} avec ${count} nœuds`);
            displayCommunity(communityId);
        });

        legendItemsContainer.appendChild(legendItem);
    });

    //  Ajuste dynamiquement le nombre de colonnes
    legendItemsContainer.style.columnCount = Math.ceil(Object.keys(communityCounts).length / 15);

    //  Ajouter un bouton pour afficher toutes les communautés
    let showAllButton = document.createElement("button");
    showAllButton.textContent = "TOUTES";
    showAllButton.classList.add("show-all-button");
	
	showAllButton.addEventListener("click", function () {
       // console.log("📌 Affichage de toutes les communautés");
        
		 displayGraph(storedGraphLouvain);
    });
	
	//  Ajouter un bouton pour masquer la légende des communautés
    let hideButton = document.createElement("button");
    hideButton.textContent = "Masquer";
    hideButton.classList.add("hide-legend-button");

    hideButton.addEventListener("click", function () {
        legendContainer.style.display = "none"; //  Cache la légende lorsqu'on clique sur "Masquer"
    });
	

    legendContainer.appendChild(showAllButton);
	legendContainer.appendChild(hideButton);
}
///////// FIN FONCTION POUR APPLIQUER L'ALGORITHME DE LOUVAIN COMMUNAUTES SUR LE GRAPHE AFFICHÉ //////////
	
	
///////////GRAPHE de spatialisation des noeuds FORCEATLAS2 //////////////////  
function startForceAtlas2(data)
	{
	s.graph.nodes().forEach(node => {
    if (node.x === undefined || node.y === undefined) {
        console.error(`⚠️ Problème de coordonnées pour le nœud ${node.id} (${node.label})`);
    }
});	
				s.startForceAtlas2({
									worker: true,
									barnesHutOptimize: true,
									barnesHutTheta: 0.5,
									scalingRatio: 2,
									gravity: 4
									});
	// Arrêter ForceAtlas2 après 5 secondes
		setTimeout(() => {
			if (isForceAtlas2Running)
			{
			//console.log("✅ Contenu de s.graph :", s.graph);
			//console.log("✅ Type de s.graph.nodes :", typeof s.graph.nodes, Array.isArray(s.graph.nodes));
			//console.log("✅ Type de s.graph.edges :", typeof s.graph.edges, Array.isArray(s.graph.edges));

			s.stopForceAtlas2();  // fonction defini dans sigmajs
			console.log('ForceAtlas2 arrêté automatiquement après 5 secondes.');
		
			//console.log("✅ Graphe après ForceAtlas2 :", s.graph);
			//console.log("✅ Type de s.graph.nodes :", typeof s.graph.nodes, Array.isArray(s.graph.nodes));
			//console.log("✅ Type de s.graph.edges :", typeof s.graph.edges, Array.isArray(s.graph.edges));
			
		// ✅ Récupérer le graphe affiché sous forme JSON
        let currentGraph = {
            nodes: [...s.graph.nodes()],
            edges: [...s.graph.edges()]
        };

        // ✅ Réafficher le graphe actuel
		  
		displayGraph(currentGraph);
		 
			}
		}, 10000); // 10000 millisecondes = 10 secondes	
		 
	}	 	
///////////FIN graphe de spatialisation Forceatlas2 //////////////////
	
<!-- FIN BOUTONS DE LA GESTION DES GRAPHES  -->


/////////////////////// GESTION DES EVENEMENTS ////////////////////
  
/////// Fonction pour gerer les evenements CLIC GAUCHE des nœuds
 function ClicNodeEvents(s) {
     

    // ✅ Clic sur un nœud : Met à jour les infos SEULEMENT si c'est un autre nœud
    s.bind('clickNode', function(e) {
        let node = e.data.node;
		
		vedette = e.data.node ;
		console.log("📌 Noeud sélectionné par clic(vedette) :", vedette);
		console.log("vedette =", vedette, "typeof =", typeof vedette);
		 // ✅ Active les boutons pour générer des sous-graphes
        document.getElementById("show-neighbors-btn").disabled = false;
        document.getElementById("show-syno2-btn").disabled = false;
        document.getElementById("show-adjacency-btn").disabled = false;

        // ✅ Mettre à jour les infos seulement si on clique sur un NOUVEAU nœud
        if (vedette !== node.id) {
            vedette = node;  // ✅ Stocke le nœud sélectionné
            
            var infoText = document.getElementById('info-text');

            var infoHTML = `<h3>Vedette</h3>                       						 
                <p><strong style="font-size: 18px; font-weight: bold;">${node.label}</strong></p>	
				<p>Variantes: ${node.variantes?.join(', ') || 'Aucune'}</p>
				<p>Nombre de synonymes: ${node["nombre de synonymes"] || '0'}</p>
				<p>Synonymes: ${node.synonymes?.join(', ') || 'Aucun'}</p>
				<p>Antonymes: ${node.antonymes?.join(', ') || 'Aucun'}</p>
                           
				<p>Cliques: ${node.cliques?.map(clique => clique.join(', ')).join('; ') || 'Aucune'}</p>
				<p>Liste10: ${node.liste10?.map(item => item.map(subItem => subItem.join(': ')).join(', ')).join('; ') || 'Aucune'}</p>
							`;

            infoText.innerHTML = infoHTML;
        }
    });

    // ✅ CLIC DANS LE GRAPHE HORS D'UN NŒUD => Effacer les infos
    s.bind('clickStage', function() {
        vedette = null;  // ✅ Réinitialise la mémoire du dernier nœud
        document.getElementById('info-text').innerHTML = '<p>Survoler un nœud pour voir des données associées.</p><p>Clic gauche sur un nœud pour le sélectionner (vedette) et afficher ici toutes les données associées.</p><p>Clic droit sur un nœud pour des informations.</p><p>Zoom disponible</p>';
    });
}
  /////// FIN de la fonction pour gerer les evenements au CLIC GAUCHE des nœuds 
 
 function RightClickNodeEvents(s) {
  s.bind('rightClickNode', function (e) {
    const node = e.data.node;
    const nodeId = node.id;

    // ✅ Réinitialiser toutes les couleurs
    s.graph.nodes().forEach(n => {
      n.color = n.originalColor || '#ccc';
    });
    s.graph.edges().forEach(edge => {
      edge.color = edge.originalColor || '#999';
    });

    // ✅ Mettre le nœud cliqué en rouge
    if (!node.originalColor) node.originalColor = node.color;
    node.color = '#FF0000';

    const neighborLabels = new Set(); // 🧠 pour éviter les doublons

    // ✅ Colorer les voisins et les arêtes
    s.graph.edges().forEach(edge => {
      if (edge.source === nodeId || edge.target === nodeId) {
        if (!edge.originalColor) edge.originalColor = edge.color;
        edge.color = '#FF0000';

        const neighborId = edge.source === nodeId ? edge.target : edge.source;
        const neighbor = s.graph.nodes(neighborId);
        if (neighbor) {
          if (!neighbor.originalColor) neighbor.originalColor = neighbor.color;
          neighbor.color = '#FF0000';
          neighborLabels.add(neighbor.label); // ✅ enregistrer le label du voisin
        }
      }
    });

    s.refresh();

    const degree = neighborLabels.size;
    const neighborList = Array.from(neighborLabels).sort().join(", ");

    // ✅ Message enrichi avec la liste des voisins
    showNotif(`<strong>${node.label}</strong> a ${degree} lien(s) dans le graphe affiché.<br><br><em>Liens avec : </em> ${neighborList}`);
  });


  // clic droit hors d’un nœud → réinitialisation
 s.bind('clickStage', function () {
  s.graph.nodes().forEach(n => {
    if (n.originalColor) n.color = n.originalColor;
  });
  s.graph.edges().forEach(e => {
    if (e.originalColor) e.color = e.originalColor;
  });
  s.refresh();
});

}

  
 /////// Fonction pour gerer les evenements SURVOL DES NŒUDS
  function SurvolNoeud(s) {
    s.bind('overNode', function(e) {
    var node = e.data.node;
		
        // ✅ Affichage temporaire dans une info-bulle (tooltip)
        var tooltip = document.getElementById('node-tooltip');
        tooltip.innerHTML = `<strong>${node.label}</strong><br>
                            <p>Nombre de synonymes: ${node["nombre de synonymes"] || '0'}</p>
							<p>Synonymes: ${node.synonymes?.join(', ') || 'Aucun'}</p>`;
							
        tooltip.style.display = "block";
        tooltip.style.left = `${e.data.captor.clientX + 10}px`;
        tooltip.style.top = `${e.data.captor.clientY + 10}px`;
    });

    s.bind('outNode', function() {
        var tooltip = document.getElementById('node-tooltip');
        tooltip.style.display = "none";  // ✅ Cache l'info-bulle quand la souris quitte le nœud
    });
}
 /////// FIN de la fonction pour gerer les evenements SURVOL DES NŒUDS
  

// Gestion bouton pour alterner  DÉMARRER/ARRÊTER FORCEATLAS2
    document.getElementById('toggle-forceatlas2').addEventListener('click', function() {
      if (isForceAtlas2Running) {
        s.stopForceAtlas2();
        this.textContent = 'Démarrer ForceAtlas2';
      } else {
        startForceAtlas2(s);
        this.textContent = 'Arrêter ForceAtlas2';
      }
      isForceAtlas2Running = !isForceAtlas2Running;
    });
//  FIN  Gestion bouton pour alterner  DÉMARRER/ARRÊTER FORCEATLAS2


// gestion du bouton "GRAPHE INITIAL" 
// qui affiche le graphe initial stocké en storedGraphInitial
    document.getElementById('graphe-initial').addEventListener('click', function() {
	if (storedGraphInitial && storedGraphInitial.nodes.length > 0 && storedGraphInitial.edges.length > 0) { 
 
 
	displayGraph (storedGraphInitial);

} else {
    showNotification('⚠️ Pas de graphe initial stocké');
}
	});
// FIN gestion du bouton "GRAPHE INITIAL" 	


	
	
	 

// Charger le graphe lorsque la page est prête
//  window.onload = loadGraph;

 
  ///// ▶️ Activation du panneau d'aide au clic sur le bouton "Aide"
  window.addEventListener("DOMContentLoaded", () => {
    const helpBtn = document.getElementById("help-btn");
    const helpModal = document.getElementById("help-modal");

    if (helpBtn && helpModal) {
      helpBtn.addEventListener("click", () => {
        helpModal.style.display = "block";
      });
    }
  });
 



</script>
<!-- fin du script js----------------------------------------------------------------------------------------------------- -->
  
   
  
</body>
</html>
