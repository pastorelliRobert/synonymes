<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualisation de Graphe avec Sigma.js</title>

 <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
	
  
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/sigma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/plugins/sigma.layout.forceAtlas2.min.js"></script>

 <script src="./bundle.js"></script>
 
 <script>
window.addEventListener("load", function () {
    console.log("📌 Vérification après chargement complet des scripts...");

    console.log("📌 Vérification de sigma :", window.sigma);
    console.log("📌 Vérification de forceatlas2 :", window.forceAtlas2);
    console.log("📌 Vérification de graphology :", window.graphology);
    console.log("📌 Vérification de pandemonium :", window.pandemonium);
    console.log("📌 Vérification de graphology-indices :", window.graphologyIndices);
    console.log("📌 Vérification de graphology-communities-louvain :", window.graphologyCommunitiesLouvain);
});
</script>
 
  <link rel="icon" href="data:,">
 
<!-- STYLE----------------------------------------------------------------------------------------------------- -->
 <style>
 
.container {
    display: flex;
    justify-content: space-between;
    align-items: stretch;  /* ✅ Toutes les colonnes prennent la même hauteur */
    height:90vh;  /* ✅ Utilise toute la hauteur de l'écran */
}

/* ✅ Colonne de gauche */
#left-panel {
    width: 250px;
    padding: 1px;
    border-right: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}


/* ✅ Colonne de droite */
#right-panel {
    width: 250px;
    padding: 1px;
    border-left: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

/* ✅ Zone du graphe - Ajuste la hauteur automatiquement */
#graph-container {
    flex-grow: 1;
	max-height:100vh;  /* ✅ Permet au graphe de prendre la même hauteur que les colonnes */
    border: 1px solid #ccc;
    background: #f9f9f9;
    display: flex;
    align-items: stretch;  /* ✅ Ajuste le graphe à la hauteur de son parent */
	position: relative; /* ✅ Cette ligne est essentielle pour que les enfants absolus s’alignent par rapport à lui */
    overflow: hidden;    /* ✅ Pour éviter les débordements */
}

/* ✅ Style du conteneur de recherche */
#search-container {
    padding: 5px;
    border: 2px solid #ddd;
    background: #f9f9f9;
    margin-bottom: 4px;
    border-radius: 2px;
	position: relative
}


/* ✅ Style de la zone de saisie et du bouton */
#node-search {
    width: 90%;
    padding: 6px;
    margin-bottom: 5px;
    border: 2px solid #ccc;
    border-radius: 4px;
}

#search-node-btn {
    width: 90%;
    padding: 6px;
    font-size: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#search-node-btn:hover {
    background-color: #2980b9;
}

#search-initial-btn  {
    width: 90%;
    padding: 6px;
    font-size: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#search-initial-btn:hover {
    background-color: #2980b9;
}


/* ✅ Liste des résultats de recherche */
#search-results {
    list-style-type: none;
    padding: 0;
    margin: 5px 0;
    max-height: 100px;
    overflow-y: auto;
    border: 1px solid #ccc;
    background: white;
    border-radius: 4px;
}

#search-results li {
    padding: 8px;
    cursor: pointer;
    transition: background 0.3s;
    border-bottom: 1px solid #ddd;
}

#search-results li:hover {
    background: #f1f1f1;
}


#info-text {
    flex-grow: 1;
    overflow-y: auto;
    max-height: 110px;
    max-width: 230px;
    word-wrap: break-word;
    padding: 10px;
    border: 1px solid #ccc; /* ✅ Bordure pour démarquer */
    background: #f9f9f9; /* ✅ Fond clair */
    border-radius: 4px; /* ✅ Arrondi des coins */
	margin-bottom: 5px;  /* ✅ Ajoute de l'espace sous cette zone */
}


#info-buttons {
    display: flex;
    flex-direction: column;
    gap: 5px;  /* ✅ Espacement entre les boutons */
	margin-bottom: 6px; 
    padding-top: 10px; /* ✅ Ajoute de l’espace au-dessus des boutons */
}

button {
    width: 90%;  
    padding: 10px;
    font-size: 12px;
    background-color: #3498db; 
    color: white;
    border: none;
    border-radius: 4px; 
    cursor: pointer;
    transition: background 0.3s ease;
	margin-bottom: 10px;  /* Augmente l'espacement sous chaque bouton */
}


/* Effet au survol */
button:hover {
    background-color: #2980b9;
}


#show-neighbors-btn {
    width: 100%;
    padding: 5px;
    font-size: 12px;
    background-color:  #ff9933  ; /* ✅ synonymes  */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#show-neighbors-btn:hover {
    background-color: #d35400;
}

#show-neighbors-btn:disabled {
    background-color: #bdc3c7; /* ✅ Gris quand désactivé */
    cursor: not-allowed;
}

#show-syno2-btn {
    width: 100%;
    padding: 8px;
    font-size: 12px;
    background-color: #e67e22  ; /* ✅ syno2*/
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#show-syno2-btn:hover {
    background-color:  #d35400;
}

#show-syno2-btn:disabled {
    background-color: #bdc3c7; /* ✅ Gris quand désactivé */
    cursor: not-allowed;
}

#show-adjacency-btn {
    width: 100%;
    padding: 8px;
    font-size: 12px;
    background-color: #b35900; /* ✅  bouton adjacence */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
	margin-bottom: 1px;
}

#show-adjacency-btn:hover {
    background-color: #d35400;
}

#show-adjacency-btn:disabled {
    background-color: #bdc3c7; /* ✅ Gris quand désactivé */
    cursor: not-allowed;
}

#graph-management {
    padding: 10px;
    border: 4px solid #2980b9;  /* ✅ Bordure épaisse bleue */
    border-radius: 8px;  /* ✅ Coins arrondis */
    background: #f9f9f9;  /* ✅ Fond clair */
    text-align: center;
    margin-top: 1px;
}

#graph-management h3 {
    margin-top: 0;
    font-size: 12px;
    color: #2980b9;
}
#community-legend {    /* COMMUNAUTES */
    width: auto;
    max-width: 115px; /* ✅ Réduit la largeur du cadre pour 1 colonne */
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* ✅ Meilleur alignement à gauche */
    padding: 5px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    position:  relative;
    top: 1px;
	left : 1px ;
    z-index: 10;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
}

/* ✅ Conteneur des pastilles avec 2 colonnes */
#community-items {  
	display: flex;
    flex-wrap: wrap;
    max-height: 500px;
    overflow-y: auto;
    gap: 5px;
   justify-content: space-between;
}

/* ✅ Éléments de la légende (adaptés pour 2 colonnes) */
.legend-item {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    transition: all 0.3s ease-in-out;
    width: calc(50% - 10px); /* ✅ Deux colonnes maximum */
    min-width: 90px;
}



/* ✅ Pastille de couleur */
.color-dot {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    transition: transform 0.2s ease-in-out;
}

/* ✅ Effet zoom au survol */
.legend-item:hover .color-dot {
    transform: scale(1.2);
}

/* ✅ Labels des communautés */
.legend-label {
    font-size: 14px;
    font-weight: bold;
}

/* ✅ Style du bouton "Toutes Communautés" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
}

.show-all-button:hover {
    background-color: #2980b9;
}

#hide-legend-zone {
    width: 80%;
    text-align: center;
    padding: 5px;
    background: #a3a3c2;
    color: white;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
}

#hide-legend-zone:hover {
    background: #c0392b;
}

#show-legend-btn {
    padding: 5px;
    background: #2ecc71;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    display: none;
}

#hide-legend-btn {
    width: 100%;
    margin-top: 10px;
    padding: 5px;
    background-color: #bdc3c7;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#hide-legend-btn:hover {
    background-color:  #a3a3c2;
}

#connected-components-legend {  /* CONNEXES */
    width: auto;
    max-width:180px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    padding: 5px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    position: relative;        
    top: 1px;              /* ✅ décalage depuis le haut de la page */
    left: 1px;
    z-index: 10 ;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
	/*  hauteur fixe + scroll */
    max-height: 500px;
    overflow-y: auto;
	 overflow-x: hidden;
	
}

#connected-components-legend .legend-item {
    width: 100% !important;
    min-width: 100px !important;
    box-sizing: border-box;
}


/* ✅ Conteneur   */
#legend-items {
	display: flex;
    flex-wrap: wrap;
    max-height: 500px;
    overflow-y: auto;
    gap: 5px;
    justify-content: space-between;
}

/* ✅ Chaque pastille prend la moitié de la ligne = 2 colonnes */
.legend-item {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    transition: all 0.3s ease-in-out;
    width: calc(50% - 10px); 
    min-width: 90px;
    box-sizing: border-box; /* ✅ Pour une meilleure cohérence d’affichage */
}

/* ✅ Pastilles */
.color-dot {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    border: 1px solid #000;
    transition: transform 0.2s ease-in-out;
}

/* ✅ Zoom au survol */
.legend-item:hover .color-dot {
    transform: scale(1.2);
}

.legend-label {
    font-size: 14px;
    font-weight: bold;
}

/* ✅ Style du bouton "Toutes Composantes" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db; /* ✅ Bleu Sigma.js */
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
}

.show-all-button:hover {
    background-color: #2980b9; /* ✅ Bleu foncé au survol */
}

/* ✅ Bouton "TOUTES Communautés" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
    width: 100%;
}

.show-all-button:hover {
    background-color: #2980b9;
}

/* ✅ Bouton "Masquer" */
.hide-legend-button {
    margin-top: 5px;
    background-color: #bdc3c7;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
    width: 100%;
	 display: block; /* ✅ Assurer qu'il est bien affiché */
}

.hide-legend-button:hover {
    background-color: #e74c3c; /* ✅ Rouge au survol */
}

#graph-stats-display {
    position: absolute;
    top: 1px;
    left: 1px;
    background-color: rgba(255, 255, 255, 0.85);
    padding: 4px 8px;
    font-size: 12px;
    border-radius: 4px;
    font-weight: bold;
    z-index: 10;
    border: 1px solid #ccc;
}

 /* ✅ Style pour la notification */
.graph-notification {
    position: absolute;
    top: 5px;
    left: 400px;
    background-color: #33cc33;
    color: #336600;
    border: 2px solid #ccc;
    padding: 8px 12px;
    border-radius: 5px;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    font-size: 14px;
    z-index: 9999;
    display: none;
    max-width: 300px;
}
#graph-message {
  position: fixed;
  top: 60px;
  left: 60px;
  max-width: 400px;
  max-height: 600px;
  overflow-y: auto;
  background-color: #99ddff;
  border: 1px solid #ccc;
  padding: 10px;
  font-size: 14px;
  color: #333;
  z-index: 3000;
  border-radius: 6px;
  box-shadow: 0 0 10px rgba(0,0,0,0.2);
}

#btn-mode-chemin {
  background-color: #ff9933;
  color: white;
  border: none;
  padding: 6px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 12px;
  transition: background 0.3s ease-in-out;
  margin-top: 10px;
}

#btn-mode-chemin.active {
  background-color: #1bcc53;
  font-size: 12px;
}



  </style>
  <!-- FIN STYLE----------------------------------------------------------------------------------------------------- -->


</head>
<body>

 <h1>Graphe de synonymes ( 2217 adjectifs)</h1>

<!-- DIV----------------------------------------------------------------------------------------------------- -->

  <div class="container">
  
  <!-- ✅ Colonne de gauche (Infos & Recherche par mot) -->
	<div id="left-panel"> 
		
		<div id="graph-management">
		<h3>Approche individuelle</h3>
		
			
			<div id="info-text">	 
			<p>Survoler ou Cliquez sur un nœud pour voir les données associées.</p>
			<p>Cliquer dans le graphe HORS des nœuds pour les cacher.</p>
			<p>Zoom disponible</p>
			</div>
			
			<div id="search-container">
			<input type="text" id="node-search" placeholder="Rechercher un nœud..." />
			<button id="search-initial-btn">Rechercher dans le graphe initial</button>
			<button id="search-node-btn">Rechercher dans le graphe affiché</button>
			<ul id="search-results"></ul>
			</div>	
			
			<!-- ✅ boutons pour afficher les graphes de la vedette -->
			<button id="show-neighbors-btn" title="Synonymes de rang 1 (voisins) du mot sélectionné" disabled>Synonymes 1</button>
			 
			<button id="show-adjacency-btn" title="Relations de synonymie entre les synonymes de rang 1 du mot sélectionné" disabled>Adjacence</button>	
			<div id="info-buttons"></div>
			
			<button id="show-syno2-btn" title="Synonymes de rang 1 (voisins, bleus) et 2 (oranges) du mot sélectionné" disabled>Synonymes 1 et 2</button>
			
			<button id="btn-mode-chemin"title="Affiche le chemin de synonymie, dans le graphe complet, entre 2 mots sélectionnés" >Chemin entre deux mots</button>
				 

		<h3>Approche globale</h3>
			<button id="completude-btn" title="Toutes les relations de synonymie entre les mots affichés" style=" background-color: #b35900;" >Complétude</button>
			<button id="extension-btn" title="Ajout des synonymes de tous les mots affichés" style=" background-color: #ff9933;" >Extension</button>
			<button id="export-matrix-btn" title="Ce bouton crée un tableau dont les cases (i,j) indiquent si les mots i et j affichés dans le graphe sont synonymes dans la base de synonymie complète (graphe initial). Si les mots i et j sont synonymes, la case (i,j) qui les croise contient 1, même s’ils ne sont pas reliés dans le graphe affiché. S’ils ne sont pas synonymes, la case contient 0."  style=" background-color: #66ccff;" >Exporter matrice de synonymie</button>
			<button id="export-path-btn" title="Ce bouton crée un tableau dont les cases (i,j) indiquent la distance (nombre minimum de liens pour aller d’un mot à un autre) entre les mots i et j affichés, en utilisant tous les liens de synonymie de la base complète (graphe initial). Si deux mots sont synonymes dans la base leur distance est 1 ; s’ils sont reliés par un chemin de synonymie comportant d’autres (2, 3, n) mots intermédiaires, la distance est 2, 3, n. S’il n’existe aucun lien entre eux dans la base, la case contient -1."  style=" background-color: #66ccff;" >Exporter matrice des distances</button>
		</div>
		
	</div>

	
<!-- ✅ Zone d'affichage du graphe -->	
	<div id="graph-container">
	
	
	<!-- ✅ Notification placée en haut à gauche du conteneur -->
		<div id="graph-stats-display">0 points, 0 liens</div>
		
		<!-- ✅ Notification placée en haut à droite du conteneur -->
		<div id="notification" class="graph-notification">Notification...</div>
	 
		<div id="graph-message" style="display: none;">
			<!-- le message sera injecté ici par JS -->
		</div>
	</div>
			<!-- Légende des communautés  -->
		<div id="community-legend"style="display: none;" >
		<h3>Communautés</h3>
		<button id="hide-legend-btn">Masquer</button> <!-- 📌 Bouton pour cacher -->
		<div id="legend-items"></div> <!-- 📌 Contiendra les pastilles -->
		</div>
			<!-- Légende des composantes connexes  -->
		<div id="connected-components-legend" style="display: none;">
		<h3>Composantes connexes</h3>
		<div id="legend-items"></div>  <!--  Contiendra les pastilles -->
		</div>
	
	
<!-- ✅ Colonne de droite (gestion des graphes) -->
    <div id="right-panel">

		<div id="graph-management">
			<h3>Gestion des graphes</h3>
			
			
			<button id="store-graph-en-0" title="Enregistre le graphe affiché (supprime l'enregistrement précédent)" style=" background-color: #6666ff;">STOCKER</button>
			<button id="show-stored-graph0" title="Affiche le graphe stocké" style=" background-color: #6666ff;" >AFFICHER</button>
			
			<button id="store-graph-en-1" title="Enregistre le graphe affiché (ne supprime pas l'enregistrement précédent)"style=" background-color: #0066ff;" >Ajouter au CUMUL</button>
			<button id="subtract-graph-en-1" title="Retire le graphe affiché du CUMUL " style=" background-color: #0066ff;" >Soustraire du CUMUL</button>
			<button id="show-stored-graph1"style=" background-color:#0066ff;" >Afficher le CUMUL</button>
			<button id="reset-stored-graph-1"style=" background-color: #0066ff;" >Vider le CUMUL</button>
			
			<button id="export-graph" title="Exporte le fichier correspondant au graphe affiché, au format JSON, dans votre dossier Téléchargement" style=" background-color: #66ccff;" >Exporter le graphe</button>
			<button onclick="exportGraphToPDF()" title="Exporte le graphe affiché au format PDF dans votre dossier de Téléchargement" style=" background-color: #66ccff;">Exporter le graphe en PDF</button>
			<button id="import-graph" title="Importe un fichier, au format JSON compatible, à partir de votre ordinateur"  style=" background-color: #cc99ff;" >Importer un graphe</button>
			<input type="file" id="import-file" accept=".json" style="display: none;" />
			<button id="export-label"  title="Copie la liste des mots du graphe affiché dans un fichier CSV de votre dossier Téléchargement" style=" background-color: #66ccff;" >Exporter les mots</button>
			 
   
			<button id="btn-importer-mots" title="Importe et affiche les mots d'un fichier, au format CSV sur votre ordinateur, contenant une liste de mots séparés par une virgule " style=" background-color: #cc99ff;" >Importer des mots</button>
			 <input type="file" id="file-mots-import" accept=".csv" style="display: none;">
			
		 
			<h3>Traitements sur graphes</h3>	
			
			<button id="show-connected-components-btn" title="Colorie les composantes connexes du graphe affiché (sous ensembles disjoints de mots)">Connexes</button>
			<button id="detect-communities" title="Colorie les sous groupes de mots fortement interconnectés (algorithme de Louvain)">Communautés</button>
			<button id="show-legend-btn" style="display:none;">Afficher la légende</button>
			<button id="toggle-forceatlas2" title="Optimisation de la disposition spatiale du graphe affiché " >Arrêter-démarrer ForceAtlas2</button>	
			


		</div>	
		 
		
	</div>	
	
<!-- ✅ boutons vert clair en dessus du graphe   -->	
	
<!-- ✅ bouton graphe initial -->	
	<button id="graphe-initial" 
	title="Affiche le graphe initial complet"
	style=" position: fixed; top: 10px; right:200px; left:550px; width: 120px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Graphe initial</button>
	
<!-- ✅ bouton Rafraîchir l'affichage  -->		
	<button id="refresh-graph-btn" 
	title="Corrige les défauts de l'affichage"
	style="position: fixed; top: 10px; right: 200px;left:700px; width: 150px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Rafraîchir l'affichage</button>
	
	
<!-- ✅ bouton Histogramme -->	
	<button id="show-histo-btn"
	title="Histogramme du graphe affiché : nombre de liens/nombre de mots"
	style=" position: fixed; top: 10px; right:200px; left:1000px; width: 100px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Histogramme</button>	
	
	
<!-- ✅ bouton aide -->	
	<button id="help-btn"
        style="position: fixed; top: 10px; right: 300px;left:420px; width: 60px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Aide</button>
	
<!-- ✅ contenu aide -->	
	<div id="help-modal"
     style="display: none; position: fixed; top: 20%; left:20%; width: 37%;
            background: white; border: 1px solid #ccc; padding: 20px;fontSize = "28px";
            box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 2000;">
	<h2>Aide</h2>
	<p>Affichage et analyse de graphes de mots liés par la relation de <strong>synonymie</strong>. </p>
	<p>La synonymie est issue du DÉS (Dictionnaire Électronique des Synonymes),</p>
	<p>mis à disposition sur Internet par le laboratoire CRISCO de l’Université de Caen.</p>
	<p>Dans cette page, les mots retenus sont les adjectifs du DÉS ayant au moins 2 synonymes (2217 en cohérence).</p>
	<p> -</p>
	<p>Vous pouvez <strong>survoler</strong> les points (mots) du graphe,</p>
	<p><strong>clic gauche</strong> pour en sélectionner un (vedette), </p>
	<p><strong>clic droit</strong> pour afficher les informations associées.</p>
	<p><strong>Clic gauche sur le fond du graphe</strong> pour réinitialiser l'affichage,</p>
	<p>utiliser le <strong>zoom</strong> (molette de la souris) pour modifier la taille de l'affichage (visibilité des mots). </p>
	<p>- </p>
	<p><strong>Survoler les boutons pour en avoir une courte explication.</strong> </p>
			 
	<button onclick="document.getElementById('help-modal').style.display='none'" 
	style="margin-top: 10px;width: 200px;"
	>Fermer</button>   
</div>

	
<!-- ✅ info bulle au survol de noeud -->		
	<div id="node-tooltip"
	style="position: absolute;background: rgba(0, 0, 0, 0.8);color: white;
	padding: 5px;border-radius: 5px;display: none;font-size: 14px;	z-index: 1000;">				
    </div>

</div>

<!-- FIN DES DIV----------------------------------------------------------------------------------------------------- -->
 
 
<!-- scrip js----------------------------------------------------------------------------------------------------- -->
 <script>
 
//////////////DECLARATION GLOBALE pour une utilisation partout////////////////////////////// 

	let storedGraphInitial = null; //variable de stockage du graphe initial : fichier json
    let storedGraphLouvain = null; //variable de stockage du graphe Louvain
	let isForceAtlas2Running = false;
	let storedGraph0 = { nodes: [], edges: [] }; //variable de stockage du graphe  
	let storedGraph1 = { nodes: [], edges: [] };  // ✅ Initialise un graphe vide
	let baseGraphForComponents = null;  // ✅ Stocke le graphe de référence pour la détection des connexes
	let isFirstComponentDetection = true;  // ✅ Vérifie si c'est le premier calcul des connexes
	let s; // Déclarez `s` dans la portée globale pour qu'elle soit accessible dans toutes les fonctions
	let vedette = null; //stocke l'ID du noeud sélectionné
	let communityColors = {};
let lastGraphDisplayed = null;
let lastDisplayOptions = {};


//////////////FIN DECLARATION GLOBALE ////////////////////////////// 

//////////<!-- CHARGER LES DONNÉES INITIALES a partir de DATA.JSON -->//////
 async function loadGraph() {
      try {
			<!-- LES DONNÉES xxxxx.JSON SONT DANS LE MEME DOSSIER QUE INDEX.HTML  -- ------->
			const response = await fetch('datafinal.json');
			const data = await response.json();

		// Vérifier que les données contiennent les propriétés nodes et edges
        if (data && data.nodes && data.edges) {
			console.log('✅Les données chargées contiennent bien les propriétés nodes et edges.');
			//couleur présentes dans le fichier json
			//console.log("🎨 Vérification des couleurs des nœuds :", data.nodes.map(n => n.color));
			//console.log("🎨 Vérification des couleurs des arêtes :", data.edges.map(e => e.color));

		// Initialiser Sigma.js
			 s = new sigma (
				{ graph: data, container: 'graph-container',
					settings: {
					drawEdges: false,  // ✅ Désactive complètement l'affichage des arêtes
					// defaultNodeColor: 'blue',
					// nodeHoverColor: 'yellow',
					minNodeSize: 5,  // Taille minimale des nœuds
					maxNodeSize: 5,	// Taille maximale des nœuds
					//minEdgeSize: 0.01,
					//maxEdgeSize: 0.01
					}
				});
		} else {
				console.error('Les données chargées ne contiennent pas les propriétés nodes et edges.');
				}
			<!-- FIN DE CHARGER LES DONNÉES INITIALE -->			
			console.log("✅ Données du graphe initial chargées :", data);
			//console.log("✅ Type de data.nodes :", typeof data.nodes, Array.isArray(data.nodes));
			//console.log("✅ Type de data.edges :", typeof data.edges, Array.isArray(data.edges));
	
	// survol des noeuds
	SurvolNoeud(s);
	
	// Événements au clic des nœuds
	ClicNodeEvents(s);
	
	// ❌ Bloque le menu contextuel
	document.getElementById("graph-container").addEventListener("contextmenu", function (e)
		{
			e.preventDefault(); 
		});
	
	// chargement du graphe initial dans storedGraphInitial	
	storedGraphInitial = storeGraph(s.graph);

	if (!vedette && storedGraphInitial.nodes.length > 0) {
        vedette = storedGraphInitial.nodes[1169];  // ✅ Prend le nœud 1169 = innomable du graphe initial
		  console.log("✅`vedette` initialisé automatiquement sur :", vedette.label);
		}
<!-- FIN DU TRY DE CHARGEMENT  -->
     } catch (error) {
					console.error('Erreur lors du chargement du fichier JSON:', error);
					}
	
	//affichage du graphe initial
	 displayGraph (storedGraphInitial, { initialgraph: true }  );
	
  } 
  /////////////////////<!-- FIN DU CHARGER LES DONNÉES INITIALES a partir de DATA.JSON  -->/////
	
	


///zone de MESSAGES à l'utilisateur //////

///messages à durée déterminée 	courte
function showNotification(message, duration = 3000) {
    const notif = document.getElementById("notification");
   notif.innerHTML = message; // ✅ HTML interprété
    notif.style.display = "block";

    setTimeout(() => {
        notif.style.display = "none";
    }, duration);
}

///messages avec bouton "fermer" incorporé
function showNotif(message) {
  const notif = document.getElementById("graph-message");
  if (notif) {
    notif.innerHTML = `
      ${message}
      <br>
      <button onclick="document.getElementById('graph-message').style.display='none'"
              style="margin-top: 10px; padding: 4px 10px; background:#ccc; border:none; border-radius:4px;">
        Fermer
      </button>
    `;
    notif.style.display = "block";
  }
}
////fin MESSAGES ////////////

//AFFICHAGE STATS (nbre points et aretes) coin haut gauche du cadre du graphe
function updateGraphStats(graphData) {
    const nbNodes = graphData.nodes.length;
    const nbEdges = graphData.edges.length;
    const statsDiv = document.getElementById("graph-stats-display"); 
    statsDiv.textContent = `${nbNodes} point${nbNodes > 1 ? 's' : ''}, ${nbEdges/2} lien${nbEdges > 1 ? 's' : ''}`;
}
// FIN AFFICHAGE STATS 

//RAFRAICHIR pour effacer les traces des survols
document.getElementById("refresh-graph-btn").addEventListener("click", () => {
  if (s) {
    // 🔁 Lire le graphe affiché actuellement (avec positions à jour)
    const currentGraph = {
      nodes: s.graph.nodes().map(n => ({ ...n })),
      edges: s.graph.edges().map(e => ({ ...e }))
    };

    //console.log("🔁 Réaffichage du graphe courant avec ses positions actuelles");
    displayGraph(currentGraph, lastDisplayOptions); // ou options par défaut
  }
});
//FIN de RAFRAICHIR


///////////// AFFICHAGE DES GRAPHES  ///////	DISPLAYGRAPH   ///////////////////////////
function displayGraph(graphData, options = {}) {
   const {
    rescale = true,        // recadrer le graphe 
    initialgraph = false  //  ne pas randomiser le graphe 
  } = options;

  if (rescale) {
    rescaleGraphLayout(graphData, 0.8);
  }
 
 if (s) {   // Détruire l'instance actuelle de Sigma.js
  s.unbind('overNode');
  s.unbind('outNode');
  s.refresh(); // force le redraw sans survol
  s.kill();
}

lastGraphDisplayed = graphData;
lastDisplayOptions = options;


  const nodeCount = graphData.nodes.length  ;
  //  Définir la catégorie du graphe
  let sizeClass = nodeCount < 200 ? "small"
                  : nodeCount <= 400 ? "medium"
                  : "big";

  //console.log(" DISPLAYGRAPH Type de graphe :", sizeClass, " Nœuds :", nodeCount, "rescale :",rescale, "initialgraph :",initialgraph); 

// redisposer aleatoirement les grands graphes sauf le graphe initial
  if ( !initialgraph && nodeCount> 400) {
	applyRandomLayout(graphData);
	}

//  Définir les tailles des nœuds pour chaque catégorie de graphe
const nodeSizes = {
  small: { vedette: 12, normal: 6 },
  medium: { vedette: 8, normal: 4 },
  big: { vedette: 4, normal: 2 }
};

//  Définir les paramètres d’affichage des tailles dans Sigma
const settingsSizes = {
  small: { minNode: 2, maxNode: 16 },
  medium: { minNode: 2, maxNode: 12 },
  big: { minNode: 0.5, maxNode: 6 }
};

	//  Vérifie si la vedette est présente dans ce sous-graphe
	const vedetteInGraph = vedette && graphData.nodes.some(n => n.id === vedette.id);
	//console.log ("displaygraph : vedette présente  ", vedetteInGraph, "label", vedette.label);

  //  Appliquer couleur et taille aux nœuds
  graphData.nodes.forEach(node => {
    if (vedette && node.id === vedette.id) {
      node.color = "#e74c3c"; // 🔴 vedette
      node.size = nodeSizes[sizeClass].vedette;
		// console.log("displaygraph : vedette", node.label, "Size:", node.size, "Color:", node.color);
    } else {
      node.size = nodeSizes[sizeClass].normal;
		//console.log("displaygraph: NON vedette", node.label, "Size:", node.size, "Color:", node.color);
    }
    node.originalColor = node.color;
  });
	
 //  Couleur et sauvegarde des arêtes
  graphData.edges.forEach(edge => {
    if (!edge.color) {
      edge.color = sizeClass === "big"
        ? "rgba(0, 0, 255, 0.2)"
        : "rgba(0, 0, 255, 0.6)";
    }
    if (!edge.originalColor) edge.originalColor = edge.color;
  });

 // Sauvegarde des couleurs initiales pour restauration ultérieure
	graphData.nodes.forEach(node => {
		if (!node.originalColor) node.originalColor = node.color;
		});
	graphData.edges.forEach(edge => {
		if (!edge.originalColor) edge.originalColor = edge.color;
		});
 
 //  Paramètres Sigma adaptés
  const settings = {
    minNodeSize: settingsSizes[sizeClass].minNode,
    maxNodeSize: settingsSizes[sizeClass].maxNode,
    minEdgeSize: 0.4,
    maxEdgeSize: 1.2,
    font: "Arial",
    fontsize: sizeClass === "small" ? 20: (sizeClass === "medium" ? 14 : 10),
    defaultLabelColor: "#000"
  };


// fonction pour recalibrer laffichage du graphe dans 80% du container
function rescaleGraphLayout(graphData, scale = 0.8) {
  //  Récupère les extrêmes des coordonnées
  const xs = graphData.nodes.map(n => n.x);
  const ys = graphData.nodes.map(n => n.y);

  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);

  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;

  const rangeX = maxX - minX;
  const rangeY = maxY - minY;
  const maxRange = Math.max(rangeX, rangeY);

  //  Applique un zoom centrant et réducteur sur tous les nœuds
  graphData.nodes.forEach(node => {
    node.x = ((node.x - centerX) / maxRange) * scale;
    node.y = ((node.y - centerY) / maxRange) * scale;
  });
}

rescaleGraphLayout(graphData, 0.8);

function applyRandomLayout(graphData, range = 1) {
  graphData.nodes.forEach(node => {
    node.x = (Math.random() - 0.5) * range;
    node.y = (Math.random() - 0.5) * range;
  });
}


//  Création du graphe
    s = new sigma({
      graph: graphData,
      container: 'graph-container',
      settings: settings
    });
    s.refresh();
	
  
	//affiche les stats
	  updateGraphStats(graphData);	   
	// survol des noeuds
	  SurvolNoeud(s);  
	// Afficher des informations au clic gauche des nœuds
      ClicNodeEvents(s);
	// Afficher des informations au clic droit des nœuds	 
	   RightClickNodeEvents(s); 
  }
  //////////// FIN FONCTION POUR AFFICHER UN GRAPHE  
  
  
   // Charger le graphe lorsque la page est prête
    window.onload = loadGraph;
		

<!-- BOUTONS DE l'APPROCHE INDIVIDUELLE  -->	

//// RECHERCHE D'UN NOEUD DANS LE GRAPHE AFFICHÉ////////////////////////////////////////////
document.getElementById("search-node-btn").addEventListener("click", function() {
    let searchTerm = document.getElementById("node-search").value.toLowerCase().trim();
    let resultsContainer = document.getElementById("search-results");
    resultsContainer.innerHTML = "";  // ✅ Efface les résultats précédents

    let foundNodes = s.graph.nodes().filter(node => node.label.toLowerCase().includes(searchTerm));

    if (foundNodes.length > 0) {
        foundNodes.forEach(node => {
            let listItem = document.createElement("li");
            listItem.innerHTML = `<strong>${node.label}</strong>`;
            listItem.style.cursor = "pointer";
            listItem.style.padding = "5px";
            listItem.style.borderBottom = "1px solid #ddd";
            
			listItem.addEventListener("click", function() {
				highlightNode(node.id);  // ✅ Met en évidence le nœud sélectionné
				selectedNodeId = node.id;  // ✅ Stocke l'ID du nœud sélectionné
				
				vedette = node  ;     // ✅ Stocke le nœud sélectionné via recherche
		//console.log("📌 Noeud sélectionné via recherche dans affiché :", vedette);
			
			// ✅ Active les boutons
				document.getElementById("show-neighbors-btn").disabled = false; 
				document.getElementById("show-syno2-btn").disabled = false;
				document.getElementById("show-adjacency-btn").disabled = false; // ✅ Active le bouton "Graphe d'adjacence"
			
			
			resultsContainer.innerHTML = "";  // ✅ Masque la liste après sélection
            });

            resultsContainer.appendChild(listItem);
        });
    } else {
        resultsContainer.innerHTML = "<li>Aucun nœud trouvé.</li>";
    }
});

function highlightNode(nodeId) {
    s.graph.nodes().forEach(node => {
        node.color = (node.id === nodeId) ? "#e74c3c" : "#3498db"; // 🔴 Rouge pour le nœud trouvé, 🔵 Bleu pour les autres
		node.size = (node.id === nodeId) ? "20" : "8" ;
    });
    s.refresh();  // ✅ Met à jour l'affichage du graphe
}
//// FIN de RECHERCHE D'UN NOEUD DANS LE GRAPHE AFFICHÉ/////////////////////////////////////


// 🔍 RECHERCHE D'UN NOEUD DANS LE GRAPHE INITIAL (TOUS les nœuds)////////////////////////
document.getElementById("search-initial-btn").addEventListener("click", function() {
    let searchTerm = document.getElementById("node-search").value.toLowerCase().trim();
    let resultsContainer = document.getElementById("search-results");
    resultsContainer.innerHTML = "";  // ✅ Efface les résultats précédents

    let foundNodes = storedGraphInitial.nodes.filter(node => node.label.toLowerCase().includes(searchTerm));

    if (foundNodes.length > 0) {
        foundNodes.forEach(node => {
            let listItem = document.createElement("li");
            listItem.innerHTML = `<strong>${node.label}</strong>`;
            listItem.style.cursor = "pointer";
            listItem.style.padding = "5px";
            listItem.style.borderBottom = "1px solid #ddd";

            listItem.addEventListener("click", function() {
                highlightNode(node.id);  // ✅ Met en évidence le nœud sélectionné dans le graphe affiché
				
				vedette = node ;  // ✅ Stocke tout l'objet du nœud sélectionné
               		    
    //console.log("📌 Noeud sélectionné via recherche dans initial :", vedette);
		
                // ✅ Active les boutons
                document.getElementById("show-neighbors-btn").disabled = false; 
                document.getElementById("show-syno2-btn").disabled = false;
                document.getElementById("show-adjacency-btn").disabled = false;

                resultsContainer.innerHTML = "";  // ✅ Masque la liste après sélection
            });

            resultsContainer.appendChild(listItem);
        });
    } else {
        resultsContainer.innerHTML = "<li>Aucun nœud trouvé.</li>";
    }
});
// 🔍 FIN Recherche d'un noeud dans le graphe initial (TOUS les nœuds)////////////////////////


//////////// GRAPHE DES SYNONYMES = VOISINS de la vedette /////////// 
// CLIC sur le bouton "synonymes" => afficher les voisins de la vedette (graphe)
document.getElementById("show-neighbors-btn").addEventListener("click", function () {
  if (!vedette) {
    showNotification("❌ Aucun nœud sélectionné !");
    return;
  }
 // console.log("📌graphe des voisins pour la vedette :", vedette.label);


  // ✅ Filtrer toutes les arêtes contenant le nœud sélectionné
  let subGraphEdges = storedGraphInitial.edges.filter(
  edge => edge.source === vedette.id || edge.target === vedette.id  );

  // ✅ Extraire les nœuds impliqués dans ces arêtes
  let neighborIds = new Set();
  subGraphEdges.forEach(edge => {
    neighborIds.add(edge.source);
    neighborIds.add(edge.target);
  });

  // ✅ Inclure les nœuds du graphe initial
  let subGraphNodes = storedGraphInitial.nodes.filter(node => neighborIds.has(node.id));

	let subGraph = { nodes: subGraphNodes, edges: subGraphEdges };
	// ✅ Vérification dans la console avant affichage
    //console.log("📌 Sous-graphe Syno1 généré :", { nodes: subGraphNodes, edges: subGraphEdges });

  
     vedette.color =  "#e74c3c"  ; // 🔴 Rouge pour la vedette
    
	//console.log("vedette.color", vedette.color);
	// ✅ Appliquer les couleurs pour forcer vedette rouge, autres en bleu
	subGraphNodes.forEach(node => {
	node.color = (node.id === vedette.id) ? "#e74c3c" : "#3498db";
	});


	// ✅ Afficher le sous-graphe
	displayGraph(subGraph);
});
//// fin de calcul et affichage du graphe des VOISINS = SYNONYMES
  
  
////fonction pour calculer et afficher le graphe SYNO2 d'une VEDETTE
document.getElementById("show-syno2-btn").addEventListener("click", function() {
    if (!vedette) {
        showNotification("❌ Aucun nœud sélectionné !");
        return;
    }
	//console.log("📌 Génération du graphe des SYNO2 pour :", vedette);

    // ✅ Étape 1 : Trouver les voisins directs (niveau 1)
    let level1Neighbors = new Set();
    storedGraphInitial.edges.forEach(edge => {
        if (edge.source === vedette.id) level1Neighbors.add(edge.target);
        if (edge.target === vedette.id) level1Neighbors.add(edge.source);
    });

    // ✅ Étape 2 : Trouver les voisins des voisins (niveau 2)
    let level2Neighbors = new Set();
    level1Neighbors.forEach(neighborId => {
        storedGraphInitial.edges.forEach(edge => {
            if (edge.source === neighborId && edge.target !== vedette.id) level2Neighbors.add(edge.target);
            if (edge.target === neighborId && edge.source !== vedette.id) level2Neighbors.add(edge.source);
        });
    });

   // ✅ Étape 3 : Construire le sous-graphe "syno2"
let allSyno2Nodes = new Set([...level1Neighbors, ...level2Neighbors, vedette.id]);

// ▶️ Création des nœuds du sous-graphe avec couleur selon niveau
let subGraph  = { nodes: [], edges: [] };

allSyno2Nodes.forEach(nodeId => {
    const originalNode = storedGraphInitial.nodes.find(n => n.id === nodeId);
    if (originalNode) {
        let color = "#000000"; // couleur par défaut
        if (nodeId === vedette.id) color = "#FFD700"; // vedette : jaune
        else if (level1Neighbors.has(nodeId)) color = "#1f77b4"; // niveau 1 : bleu
        else if (level2Neighbors.has(nodeId)) color = "#ff7f0e"; // niveau 2 : orange

        subGraph.nodes.push({
            ...originalNode,
            color: color
        });
    }
});

// ▶️ Ajouter les arêtes entre les nœuds du sous-graphe
storedGraphInitial.edges.forEach(edge => {
    if (allSyno2Nodes.has(edge.source) && allSyno2Nodes.has(edge.target)) {
        subGraph.edges.push({ ...edge });
    }
});

    // ✅ Afficher le sous-graphe "syno2"
    displayGraph( subGraph );
});
////FIN fonction   GRAPHE SYNO2 D'UNE VEDETTE
  

//// Graphe ADJACENCE /////////////////////////////////////////////
document.getElementById("show-adjacency-btn").addEventListener("click", function() {
    if (!vedette) {
        showNotification("❌ Aucun nœud sélectionné !");
        return;
    }

    //console.log("📌 Génération du graphe d'adjacence pour :", vedette);

    // ✅ Étape 1 : Trouver les voisins directs (niveau 1)
    let level1Neighbors = new Set();
    storedGraphInitial.edges.forEach(edge => {
        if (edge.source === vedette.id) level1Neighbors.add(edge.target);
        if (edge.target === vedette.id) level1Neighbors.add(edge.source);
    });

    // ✅ Étape 2 : Trouver les voisins des voisins (niveau 2)
    let level2Neighbors = new Set();
    level1Neighbors.forEach(neighborId => {
        storedGraphInitial.edges.forEach(edge => {
            if (edge.source === neighborId && edge.target !== vedette.id) level2Neighbors.add(edge.target);
            if (edge.target === neighborId && edge.source !== vedette.id) level2Neighbors.add(edge.source);
        });
    });

    // ✅ Étape 3 : Construire le sous-graphe Syno2
    let allSyno2Nodes = new Set([...level1Neighbors, ...level2Neighbors, vedette.id]);

    let subGraphNodes = storedGraphInitial.nodes.filter(node => allSyno2Nodes.has(node.id));

    // ✅ Créer un Set des IDs des nœuds valides pour éviter l'erreur
    let validNodeIds = new Set(subGraphNodes.map(node => node.id));

    // ✅ Filtrer les arêtes pour ne garder que celles qui connectent des nœuds existants
    let subGraphEdges = storedGraphInitial.edges.filter(edge =>
        validNodeIds.has(edge.source) && validNodeIds.has(edge.target)
    );

    // ✅ Étape 4 : Garder uniquement `vedette` et ses voisins directs **avec leurs connexions**
    let adjacencyNodes = new Set([...level1Neighbors, vedette.id]);  // ✅ On garde `vedette` et ses voisins directs
    let finalNodes = storedGraphInitial.nodes.filter(node => adjacencyNodes.has(node.id));  // ✅ Récupérer les nœuds valides

    let finalEdges = subGraphEdges.filter(edge =>  // ✅ Vérification supplémentaire pour éviter les erreurs
        adjacencyNodes.has(edge.source) && adjacencyNodes.has(edge.target)
    );

    let adjacencyGraph = { nodes: finalNodes, edges: finalEdges };

    //console.log("📌 Graphe d'adjacence généré :", adjacencyGraph);

    // ✅ Vérification avant affichage
    //console.log("📌 Vérification des nœuds :", adjacencyGraph.nodes);
    //console.log("📌 Vérification des arêtes :", adjacencyGraph.edges);

    // ✅ Afficher le Graphe d'adjacence
    displayGraph(adjacencyGraph);


    // ✅ Supprimer l’ancien bouton s’il existe déjà
    const existingBtn = document.getElementById("remove-vedette-links-btn");
    if (existingBtn) existingBtn.remove();

    // ✅ Créer dynamiquement le bouton
    const btn = document.createElement("button");
    btn.id = "remove-vedette-links-btn";
    btn.textContent = "Adjacence sans liens avec la vedette";
    btn.classList.add("hide-vedette-edges-btn");
    
	btn.style.height = "15px";
	btn.style.width = "200px";
	btn.style.marginTop = "1px"; /* ✅  espace au-dessus du bouton */
	btn.style.fontSize = "11px";
    btn.style.backgroundColor = "#ffd9b3";
    btn.style.color = "black";
    btn.style.border = "none";
    btn.style.padding = "2px";
    btn.style.borderRadius = "5px";
    btn.style.cursor = "pointer";

    document.getElementById("info-buttons").appendChild(btn);

    btn.addEventListener("click", function () {
        const edgesToRemove = s.graph.edges().filter(edge =>
            edge.source === vedette.id || edge.target === vedette.id
        );
        edgesToRemove.forEach(edge => {
            s.graph.dropEdge(edge.id);
        });
        s.refresh();
        showNotif(` ✅ Liens avec "${vedette.label}" supprimés.`);
        btn.remove(); // ✅ Disparaît après usage
    });
	
});
//// FIN Graphe ADJACENCE //////////////////////////////////


//////COMPLETUDE du graphe affiché
//fonction associée au bouton "Complétude"
document.getElementById("completude-btn").addEventListener("click", completeGraphEdgesFromInitial);

function completeGraphEdgesFromInitial() {
    if (!s || s.graph.nodes().length === 0) {
        console.warn("❌ Aucun graphe affiché pour la complétude.");
        return;
    }
    const currentNodes = s.graph.nodes();
    const currentEdges = s.graph.edges();
    const currentNodeIds = new Set(currentNodes.map(n => n.id));

    // 🔍 Construire un ensemble d'arêtes existantes (source+target ou target+source)
    const existingEdgeKeys = new Set(
        currentEdges.map(e => {
            const a = [e.source, e.target].sort().join("↔");
            return a;
        })
    );
    const completedEdges = [];
    storedGraphInitial.edges.forEach(edge => {
        if (
            currentNodeIds.has(edge.source) &&
            currentNodeIds.has(edge.target)
        ) {
            const edgeKey = [edge.source, edge.target].sort().join("↔");

            // ✅ Si l’arête est déjà présente, on la garde telle quelle
            if (existingEdgeKeys.has(edgeKey)) {
                completedEdges.push(edge);
            }
            // ✅ Sinon, on ajoute une nouvelle arête en gris
            else {
                completedEdges.push({
                    ...edge,
                    color: "#7f8c8d"  // 🎨 Gris pour les nouvelles arêtes
                });
            }
        }
    });
    const completedGraph = {
        nodes: [...currentNodes],
        edges: completedEdges
    };
    //console.log("📌 Arêtes totales :", completedEdges.length/2);    
	displayGraph(completedGraph);
	
}
//////FIN COMPLETUDE du graphe affiché

	
///////EXTENSION ajout des syno au graphe affiché	///////////////
// fonction associée au bouton "Extension"
document.getElementById("extension-btn").addEventListener("click", function () {
    extendGraph();
});

function extendGraph() {
    //console.log("📌 Début de l'extension du graphe...");

    // ✅ Vérifier si un graphe est affiché
    if (!s || s.graph.nodes().length === 0) {
        console.warn("❌ Aucun graphe affiché. Impossible d'étendre.");
        return;
    }
    // ✅ Récupérer les nœuds et arêtes du **graphe affiché** (A)
    let baseNodes = [...s.graph.nodes()];
    let baseEdges = [...s.graph.edges()];
    
    let baseNodeIds = new Set(baseNodes.map(node => node.id)); // 🔹 Ensemble des IDs des nœuds existants (A)

   // console.log(`📌 Nœuds initiaux du graphe affiché :`, baseNodeIds.size);
   // console.log(`📌 Arêtes initiales du graphe affiché :`, baseEdges.length/2);
    //console.log(`📌 IDs des nœuds initiaux :`, baseNodeIds);

    // ✅ Trouver les synonymes (voisins) des nœuds du graphe affiché dans `storedGraphInitial`
    let newNodes = new Set(); // 🔹 Stocke les synonymes à ajouter (B - A)
    let newEdges = []; // 🔹 Stocke les nouvelles arêtes

    baseNodes.forEach(node => {
        let nodeId = node.id;
        
        // 🔍 Récupérer les voisins (= synonymes) via les arêtes dans le graphe initial
        let synonyms = storedGraphInitial.edges
            .filter(edge => edge.source === nodeId || edge.target === nodeId) // ✅ Garde les arêtes connectées à `nodeId`
            .map(edge => edge.source === nodeId ? edge.target : edge.source); // 🔄 Récupère l’autre extrémité

        synonyms.forEach(synonym => {
            if (!baseNodeIds.has(synonym)) {  // ✅ Ne garder que les synonymes **absents** de A
                newNodes.add(synonym);		
            }
        });
    });

    //console.log(`📌 Synonymes uniques ajoutés (B - A) :`, newNodes.size);

    // ✅ Ajouter les nouvelles arêtes entre les synonymes et les nœuds initiaux
    storedGraphInitial.edges.forEach(edge => {
        if (
            (baseNodeIds.has(edge.source) && newNodes.has(edge.target)) ||
            (baseNodeIds.has(edge.target) && newNodes.has(edge.source))
        ) {
            newEdges.push(edge); // ✅ Ajoute uniquement les arêtes valides
        }
    });
    //console.log(`📌 Nouvelles arêtes ajoutées :`, newEdges.length/2);

    // ✅ Générer le graphe étendu
    let extendedGraph = {
        nodes: [...baseNodes], // 🔹 On commence avec A
        edges: [...baseEdges, ...newEdges] // 🔹 On ajoute les nouvelles arêtes
    };

    // ✅ Ajouter les nouveaux synonymes au graphe avec une couleur différente
    newNodes.forEach(synonym => {
        let originalNode = storedGraphInitial.nodes.find(n => n.id === synonym);
        if (!originalNode) return;
		
        // 🔹 Ajouter les coordonnées du nœud s'il existe dans `storedGraphInitial`
        extendedGraph.nodes.push({
            id: synonym,
            label: originalNode.label ,
			"nombre de synonymes": originalNode["nombre de synonymes"], 
			synonymes: originalNode["synonymes"],
            color: "#8e44ad", // 🎨 Couleur spéciale pour les synonymes (violet)
            size: 1, // 📌 Taille plus petite
            x: originalNode.x || Math.random() * 100, // 🔄 Position aléatoire si absente
            y: originalNode.y || Math.random() * 100
        });
    });
    // ✅ Afficher le nouveau graphe étendu
	 displayGraph (extendedGraph);	
}		 
///////FIN EXTENSION graphe des syno du graphe affiché	///////////////

	
// Fonction pour calculer l'HISTOGRAMME du graphe affiché
function calculateHistogram(nodes, edges) {
    const histogram = {};
    nodes.forEach(node => {
        const degree = edges.filter(edge =>
            edge.source === node.id || edge.target === node.id
        ).length/2;
		 
        if (!histogram[degree]) {
            histogram[degree] = { count: 0, ids: [] };
        }
        histogram[degree].count++;
        histogram[degree].ids.push(node.label);
    });
    return histogram;
}
// Fonction pour formater l'HISTOGRAMME en une chaîne lisible
function formatHistogram(histogram) {
    let formattedMessage = "Histogramme du graphe affiché <br> nombre de liens : nombre de mots (mots dans ce cas)<br>";

    for (const degree in histogram) {
        formattedMessage += `${degree}: ${histogram[degree].count} `;
        if (histogram[degree].ids.length > 0) {
            formattedMessage += ` (${histogram[degree].ids.slice(0, 100).join(', ')})`;
        }
        formattedMessage += "<br>";
    }
    return formattedMessage;
}
// Gestionnaire d'événement pour le bouton
document.getElementById("show-histo-btn").addEventListener("click", function() {
    if (!s) {
        showNotification("❌ Aucun graphe affiché !");
        return;
    }
    // Récupérer les nœuds et arêtes du graphe affiché
    const nodes = s.graph.nodes();
    const edges = s.graph.edges();

    // Calculer l'histogramme
    const histogram = calculateHistogram(nodes, edges);

    // Afficher l'histogramme dans la console
   // console.log("✅ Histogramme du graphe affiché :", histogram);
	
	// Formater l'histogramme en message lisible
    const message = formatHistogram(histogram);
	//console.log("✅ Histogramme du graphe affiché formaté:", message);
    // Afficher l'histogramme dans la zone de notification
    showNotif(message);
});
// FIN Fonction pour calculer l'HISTOGRAMME du graphe affiché

///// ▶️ Activation du panneau d'AIDE au clic sur le bouton "Aide"
document.getElementById("help-btn").addEventListener("click", () => {
  const helpModal = document.getElementById("help-modal");
  if (helpModal) {
    helpModal.style.display = "block";
  }
});
///// FIN Activation du panneau d'AIDE au clic sur le bouton "Aide"

// gestion du bouton "GRAPHE INITIAL" 
// qui affiche le graphe initial stocké en storedGraphInitial
    document.getElementById('graphe-initial').addEventListener('click', function() {
	if (storedGraphInitial && storedGraphInitial.nodes.length > 0 && storedGraphInitial.edges.length > 0) { 
 
	displayGraph (storedGraphInitial, { initialgraph: true });
} else {
    showNotification('⚠️ Pas de graphe initial stocké');
}
	});
// FIN gestion du bouton "GRAPHE INITIAL" 	


// Gestion bouton pour alterner  DÉMARRER/ARRÊTER FORCEATLAS2
    document.getElementById('toggle-forceatlas2').addEventListener('click', function() {
      if (isForceAtlas2Running) {
        s.stopForceAtlas2();
        this.textContent = 'Démarrer ForceAtlas2';
      } else {
        startForceAtlas2(s);
        this.textContent = 'Arrêter ForceAtlas2';
      }
      isForceAtlas2Running = !isForceAtlas2Running;
    });
//  FIN  Gestion bouton pour alterner  DÉMARRER/ARRÊTER FORCEATLAS2


<!-- FIN BOUTONS DE l'APPROCHE INDIVIDUELLE  -->	


<!-- BOUTONS DE LA GESTION DES GRAPHES  -->

// STOCK CUMUL IMPORT EXPORT 

// Fonction pour STOCKER et afficher un graphe en remplacement de celui stocké précédemment
  
	//copie du graphe affiché 
	function storeGraph(graph) 
	{
		let nodes = typeof graph.nodes === "function" ? graph.nodes() : Object.values(graph.nodes);
		let edges = typeof graph.edges === "function" ? graph.edges() : Object.values(graph.edges);
		//console.log("📌 Vérification des attributs des nœuds AVANT stockage :", nodes);

		return {
        nodes: nodes.map(node => ({
            id: node.id,
            label: node.label,
            x: node.x,
            y: node.y,
            size: node.size,
            color: node.color,
            antonymes: node.antonymes || [],   
            variantes: node.variantes || [],
            cliques: node.cliques || [],
            "nombre de synonymes": node["nombre de synonymes"] || 0,   
            "synonymes": node.synonymes || [],  
            //liste10: node.liste10 || []      // NE PAS  Conserver les listes
			})),
        edges: edges.map(edge => ({
            id: edge.id,
            source: edge.source,
            target: edge.target,
            size: edge.size,
            color: edge.color
			}))
		};
	}

	// gestion du bouton "STOKER le graphe affiché "
	document.getElementById("store-graph-en-0").addEventListener("click", function() {
    if (s.graph.nodes().length > 0) {
        storedGraph0 = storeGraph(s.graph);
        //console.log("✅ Graphe affiché stocké par l'utilisateur :", storedGraph0);
		showNotification('✅ Graphe stocké');
    } else {
        console.warn(" Impossible de stocker : aucun nœud dans le graphe.");
    }
});

// gestion du bouton "AFFICHER le graphe STOCKÉ "
    document.getElementById('show-stored-graph0').addEventListener('click', function() {
		if (storedGraph0 && storedGraph0.nodes.length > 0 && storedGraph0.edges.length > 0) { 
		displayGraph(storedGraph0);
		} else {
			showNotification('⚠️ Pas de graphe stocké');
		}
	});
	
////////////// Fin de la fonction pour stocker et afficher un graphe


////////////// fonction pour EXPORTER un graphe   
document.getElementById("export-graph").addEventListener("click", function() {
    if (!s) {
        showNotification("❌ Aucun graphe à exporter !");
        return;
    }
	
	// ✅ Récupérer les nœuds et arêtes du graphe affiché
    let graphData = {
        nodes: s.graph.nodes().map(node => ({
            id: node.id,
            label: node.label,
            x: node.x,
            y: node.y,
            size: node.size,
            color: node.color,
			synonymes: node.synonymes || [],
			["nombre de synonymes"]: node["nombre de synonymes"],
            antonymes: node.antonymes || [],
            variantes: node.variantes || [],
            cliques: node.cliques || [],
            liste10: node.liste10 || []
        })),
        edges: s.graph.edges().map(edge => ({
            id: edge.id,
            source: edge.source,
            target: edge.target,
            size: edge.size,
            color: edge.color
        }))
    };

    // ✅ Convertir en JSON
    let jsonString = JSON.stringify(graphData, null, 4);

    // ✅ Créer un blob et un lien de téléchargement
    let blob = new Blob([jsonString], { type: "application/json" });
    let a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    //a.download = "graphe_export.json";  // 📌 Nom du fichier exporté
	let fileName = prompt("Nom pour le fichier exporté, au format JSON, dans le dossier : Téléchargement", "graphe_export.json");
	if (!fileName) return;  // utilisateur a annulé
	a.download = fileName.endsWith(".json") ? fileName : fileName + ".json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    //console.log("✅ Exportation réussie !");
});
////////////// FIN fonction pour EXPORTER un graphe   


////////// fonction pour IMPORTER un graphe
// 📌 Quand on clique sur le bouton, déclencher l'ouverture du sélecteur de fichier
document.getElementById("import-graph").addEventListener("click", () => {
    document.getElementById("import-file").click();
});

// 📌 Gérer la sélection d’un fichier JSON
document.getElementById("import-file").addEventListener("change", function (event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();

    reader.onload = function (e) {
        try {
            const importedGraph = JSON.parse(e.target.result);
			
			// ✅ REFUSER LES GRAPHES MARQUÉS COMME "RÉDUIT"
			//if (importedGraph.type === "reduit") {
			//showNotification("❌ Ce fichier est un graphe réduit. Il ne peut pas être importé dans cette page.");
			//return;
			//}

            // Vérification de base
            if (!importedGraph.nodes || !importedGraph.edges) {
                console.error("❌ Format de graphe invalide.");
                showNotification("Le fichier sélectionné n’est pas un graphe JSON valide.");
                return;
            }

           // console.log("📥 Graphe importé :", importedGraph);

            // ✅ Afficher le graphe importé (fonction existante)
			displayGraph(importedGraph);
        } catch (err) {
            console.error("❌ Erreur lors de la lecture du fichier JSON :", err);
            showNotification("Erreur lors de l’import du fichier JSON.");
        }
    };

    reader.readAsText(file);
});
////////// FIN fonction pour IMPORTER un graphe


///////////////CUMUL DES GRAPHES//////////////////////////////////

// gestion du bouton "stoker le graphe affiché en 1" CUMUL DES GRAPHES
	document.getElementById("store-graph-en-1").addEventListener("click", function() {
    if (s.graph.nodes().length > 0) {
        let newGraph = storeGraph(s.graph);  // ✅ Graphe actuel

        if (!storedGraph1 || !storedGraph1.nodes) {  
            storedGraph1 = newGraph;  // ✅ Premier graphe stocké normalement
			showNotification ("✅ Premier graphe ajouté au CUMUL");
        } else {
            // ✅ Vérifier si le graphe actuel est réellement différent avant d'ajouter
            let existingNodes = new Map(storedGraph1.nodes.map(node => [node.id, node])); 
            let existingEdges = new Map(storedGraph1.edges.map(edge => [edge.id, edge])); 

            let isNewGraph = false;

            newGraph.nodes.forEach(node => {
                if (!existingNodes.has(node.id)) {
                    existingNodes.set(node.id, node);
                    isNewGraph = true;
                }
            });

            newGraph.edges.forEach(edge => {
                if (!existingEdges.has(edge.id)) {
                    existingEdges.set(edge.id, edge);
                    isNewGraph = true;
                }
            });

            if (isNewGraph) {
                storedGraph1 = {
                    nodes: Array.from(existingNodes.values()),
                    edges: Array.from(existingEdges.values())
                };
                showNotification("✅ Nouveau graphe ajouté au CUMUL");
            } else {
                showNotification("⚠️ Aucun changement dans la composition des noeuds et arêtes détecté dans le graphe, stockage ignoré.");
            }
        }
    } else {
        console.warn("⚠️ Impossible de stocker : aucun nœud dans le graphe.");
    }
});
//  FIN  gestion du bouton "stoker le graphe affiché en 1" CUMUL DES GRAPHES

// soustraction du graphe affiché du CUMUL /////////
document.getElementById("subtract-graph-en-1").addEventListener("click", function () {
    if (!storedGraph1 || !storedGraph1.nodes || storedGraph1.nodes.length === 0) {
        showNotification("❌ Aucun graphe CUMULÉ à modifier !");
        return;
    }

    if (!s || s.graph.nodes().length === 0) {
        showNotification("❌ Aucun graphe affiché à soustraire !");
        return;
    }

    const displayedNodeIds = new Set(s.graph.nodes().map(node => node.id));

    // 1️⃣ Supprimer les nœuds affichés du cumul
    const remainingNodes = storedGraph1.nodes.filter(node => !displayedNodeIds.has(node.id));

    // 2️⃣ Supprimer les arêtes qui touchent un nœud supprimé
    const remainingNodeIds = new Set(remainingNodes.map(node => node.id));
    const remainingEdges = storedGraph1.edges.filter(edge =>
        remainingNodeIds.has(edge.source) && remainingNodeIds.has(edge.target)
    );

    // 3️⃣ Mettre à jour le CUMUL
    storedGraph1 = {
        nodes: remainingNodes,
        edges: remainingEdges
    };

    //console.log("📌 Graphe affiché retiré du CUMUL. Nœuds restants :", remainingNodes.length);
    showNotification("✅ Le graphe affiché a été retiré du CUMUL.");
});
// FIN soustraction du graphe affiché du CUMUL /////////


// VIDER LE CUMUL DES GRAPHES
	document.getElementById("reset-stored-graph-1").addEventListener("click", function()
	{
		{
			if (storedGraph1 && storedGraph1.nodes.length > 0 && storedGraph1.edges.length > 0) 
			{
			if (confirm("❗ Confirmer le vidage du cumul ? Cette action est irréversible."))		
			
			storedGraph1 = { nodes: [], edges: [] };  // ✅ Réinitialisation complète
			//console.log("✅ Graphe stocké dans le cuml réinitialisé :", storedGraph1);
			if (s) {
				s.graph.clear();  // ✅ Effacer l'affichage du graphe
				s.refresh();  // ✅ Rafraîchir Sigma.js
			}
			showNotification("✅ Le cumul des graphes stockés a été éffacé !");			
			}
			else
			{
			showNotification('⚠️ Pas de graphe stocké');	
			};
		};
	});
// FIN VIDER LE CUMUL DES GRAPHES//////////

// AFFICHER LE CUMUL  "Afficher le(s) Graphe(s) Stocké(s) en 1" 
    document.getElementById('show-stored-graph1').addEventListener('click', function()
		{
		if (storedGraph1 && storedGraph1.nodes.length > 0 && storedGraph1.edges.length > 0) { 
		displayGraph(storedGraph1);
		} else {
			showNotification('⚠️ Pas de graphe stocké');
		}
	});
/////// FIN AFFICHER LE CUMUL ///	

/////////////fontion pour EXPORTER LA LISTE DES LABELS ///////////////////
document.getElementById("export-label").addEventListener("click", function () {
    if (!s || s.graph.nodes().length === 0) {
        alert("❌ Aucun graphe affiché !");
        return;
    }

    // 1. Récupérer les labels
    let labels = s.graph.nodes().map(node => node.label);

    // 2. Trier les labels par ordre alphabétique
    labels.sort((a, b) => a.localeCompare(b, 'fr', { sensitivity: 'base' }));

    // 3. Construire le contenu CSV (une ligne, séparée par des virgules)
   //mots séparés par une ,
   const csvContent = labels.join(","); 
   //labels.join("\n") un mot par ligne

    // 4. Demander le nom du fichier à l'utilisateur
    const fileName = prompt("Nom du fichier CSV à enregistrer dans le dossier : téléchargement  ", "mots_du_graphe.csv");
    if (!fileName) return;

    // 5. Créer et déclencher le téléchargement
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = fileName.endsWith(".csv") ? fileName : fileName + ".csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    //console.log("✅ Labels exportés :", labels.length);
});
/////////////FIN fontion pour EXPORTER LA LISTE DES LABELS ///////////////////

function exportGraphToPDF() {
  const container = document.getElementById('graph-container');

  html2canvas(container).then(canvas => {
    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'pt',
      format: [canvas.width, canvas.height]
    });
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
    pdf.save("graphe.pdf");
  });
}


// FIN STOCK CUMUL IMPORT EXPORT ///////////////////////



	
////////// TRAITEMENTS sur graphes  ////////////////////////////////
	
/////// COMPOSANTES CONNEXES //////////////////////////////////////	

// ✅ Génère une couleur unique pour chaque composante
function getColor(index) {
    const colors = [
        "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6", 
        "#1abc9c", "#e67e22", "#d35400", "#34495e", "#95a5a6"
    ];
    return colors[index % colors.length]; // ✅ Réutilise les mêmes couleurs pour chaque composante
}

///////////bouton composantes connexes  
document.getElementById("show-connected-components-btn").addEventListener("click", function() {
    detectConnectedComponents();
});

//////////calcul des composantes CONNEXES
function detectConnectedComponents() {
  
  if (isFirstComponentDetection) {  
        baseGraphForComponents = {  // ✅ Stocke le graphe affiché au premier appel seulement
            nodes: [...s.graph.nodes()],  
            edges: [...s.graph.edges()]
        };
        isFirstComponentDetection = false;  // ✅ Désactive le stockage pour les appels suivants
    }
	else 
	{ 						//	displayGraph (coloredGraph );
	}

   // let nodes = baseGraphForComponents.nodes;  // ✅ Toujours utiliser le même graphe de référence
   // let edges = baseGraphForComponents.edges;

  let nodes = s.graph.nodes();  // ✅ Toujours utiliser le graphe AFFICHÉ
  let edges = s.graph.edges();


    //console.log("📌 Utilisation du graphe affiché pour les composantes :", nodes.length, "nœuds,", edges.length/2, "arêtes");

    // ✅ Construire la liste d'adjacence
    let adjacencyList = {};
    nodes.forEach(node => adjacencyList[node.id] = []);
    
    edges.forEach(edge => {
        adjacencyList[edge.source].push(edge.target);
        adjacencyList[edge.target].push(edge.source);
    });

    // ✅ Détection des composantes connexes via DFS
    let visited = new Set();
    connectedComponents = [];  // ✅ Réinitialise la liste des composantes

    function dfs(nodeId, component) {
        visited.add(nodeId);
        component.push(nodeId);
        adjacencyList[nodeId].forEach(neighbor => {
            if (!visited.has(neighbor)) {
                dfs(neighbor, component);
            }
        });
    }
    nodes.forEach(node => {
        if (!visited.has(node.id)) {
            let component = [];
            dfs(node.id, component);
            connectedComponents.push(component);
        }
    });

    // ✅ Appliquer une couleur différente à chaque composante connexe
	connectedComponents.forEach((component, index) => {
    let color = getColor(index);  // ✅ Utilise la même fonction que la légende
    component.forEach(nodeId => {
        let node = s.graph.nodes(nodeId);
        if (node) node.color = color;
    });
});

    // ✅ Sauvegarde le graphe coloré pour pouvoir le réafficher plus tard
    coloredGraph = { nodes: [...s.graph.nodes()], edges: [...s.graph.edges()] };
 
 //console.log("📌 Composantes connexes détectées :", connectedComponents);
 
    // ✅ Rafraîchir l'affichage pour voir toutes les composantes colorées
    s.refresh();
	
	updateConnectedComponentsUI(connectedComponents);
	
//////////APPEL DE LA LEGENDE

// ✅ Mise à jour complète de la légende avant l'affichage
updateConnectedComponentsUI(connectedComponents);
// ✅ Forcer l'affichage de la légende après le calcul des composantes
setTimeout(() => {
let legendContainer = document.getElementById("connected-components-legend");
if (legendContainer) {
    legendContainer.style.display = "block"; // ✅ Assure que la légende est visible
 }
}, 100); // ✅ Petit délai pour que le DOM soit bien mis à jour

}
//////////FIN calcul des composantes CONNEXES

///fonction pour avoir des couleurs
function getColor(index) {
    const colors = [
        "#3498db", "#e74c3c", "#2ecc71", "#f1c40f", "#9b59b6",
        "#1abc9c", "#e67e22", "#d35400", "#34495e", "#95a5a6"
    ];
    return colors[index % colors.length]; // ✅ Assigne une couleur parmi la liste
}

///////////creation dynamique des boutons de CONNEXES
function updateConnectedComponentsUI(components) {

	let legendContainer = document.getElementById("connected-components-legend");

   // ✅ Afficher la légende
    legendContainer.style.display = "block";

    let legendItemsContainer = document.getElementById("connected-components-legend");
	if (legendContainer) {
    legendContainer.style.display = "block"; // ✅ La légende s'affiche dès le premier clic
	 legendContainer.innerHTML = "<h3>Composantes connexes</h3> <div id='legend-items'></div>";
}

    connectedComponents.forEach((component, index) => {
        let color = getColor(index); // 🎨 Fonction qui génère une couleur pour chaque composante
		let nodeCount = component.length; // ✅ Récupère le nombre de nœuds dans la composante

        // ✅ Création d'une pastille de couleur
        let legendItem = document.createElement("div");
        legendItem.classList.add("legend-item");
        legendItem.innerHTML = `
            <span class="color-dot" style="background-color: ${color};"></span>
            <span class="legend-label">C ${index + 1} (${nodeCount})</span> <!-- ✅ Ajoute le nombre de nœuds -->
        `;

		// ✅ Ajuste dynamiquement le nombre de colonnes en fonction du nombre de pastilles
		legendItemsContainer.style.columnCount = Math.ceil(connectedComponents.length / 15); 	

        // ✅ Ajoute un événement au clic
        legendItem.addEventListener("click", function () {
           // console.log(`📌 Affichage de la composante ${index + 1} avec ${nodeCount} nœuds`);
            displayComponentGraph(index);
        });

        legendItemsContainer.appendChild(legendItem);
    });

    // ✅ Ajouter un bouton pour afficher toutes les composantes
    let showAllButton = document.createElement("button");
    showAllButton.textContent = "TOUTES";
    showAllButton.style.marginTop = "10px";
    showAllButton.style.backgroundColor = "#3498db";  // Bleu Sigma.js
    showAllButton.style.color = "white";
    showAllButton.style.border = "none";
    showAllButton.style.padding = "8px";
    showAllButton.style.borderRadius = "5px";
    showAllButton.style.cursor = "pointer";
    showAllButton.style.fontSize = "14px";
    showAllButton.style.transition = "background 0.3s ease-in-out";

    // ✅ Changement de couleur au survol
    showAllButton.addEventListener("mouseover", function () {
        showAllButton.style.backgroundColor = "#2980b9"; // Bleu foncé
    });
    showAllButton.addEventListener("mouseout", function () {
        showAllButton.style.backgroundColor = "#3498db"; // Bleu d'origine
    });

    // ✅ Ajoute l'événement de clic pour afficher toutes les composantes
    showAllButton.addEventListener("click", function () {
       // console.log("📌 Affichage de toutes les composantes");
         
		displayGraph(coloredGraph);
    });

    // ✅ Ajouter le bouton au conteneur avant le bouton "Masquer"
    legendContainer.appendChild(showAllButton);

    // ✅ Ajouter un bouton pour masquer la legende des connexes
    let hideButton = document.createElement("button");
    hideButton.textContent = "Masquer";
    hideButton.style.marginTop = "10px";
    hideButton.style.backgroundColor = "#bdc3c7";  
    hideButton.style.cursor = "pointer";
	 
	// Ajouter un gestionnaire d'événements pour changer la couleur au survol du bouton masquer
	hideButton.addEventListener("mouseover", function() {
    hideButton.style.backgroundColor = "#FF0000"; // Rouge
	});
	hideButton.addEventListener("mouseout", function() {
    hideButton.style.backgroundColor = "#bdc3c7"; // Couleur d'origine
	});

    hideButton.addEventListener("click", function () {
        legendContainer.style.display = "none";
    });

    legendContainer.appendChild(hideButton);
}
///////////FIN creation dynamique des boutons CONNEXES

///////////////////affichage des CONNEXES
function displayComponentGraph(index) {
 
    let componentNodeIds = new Set(connectedComponents[index]);

    let subGraphNodes = coloredGraph.nodes.filter(node => componentNodeIds.has(node.id));

	// ✅ Appliquer la couleur correcte à chaque nœud
    let color = getColor(index);
    subGraphNodes.forEach(node => {
        node.color = color; // 🎨 Applique la couleur correspondant à la légende
    });
   
   // ✅ Vérification des arêtes : Garde uniquement celles qui connectent les nœuds de la composante
    let subGraphEdges = storedGraphInitial.edges.filter(edge =>
        componentNodeIds.has(edge.source) && componentNodeIds.has(edge.target)
    );
	
  //  console.log(`📌 Affichage de la composante ${index + 1}:`, subGraphNodes.length, "nœuds et", subGraphEdges.length/2, "arêtes");

    let componentGraph = { nodes: subGraphNodes, edges: subGraphEdges };

     //affiche les stats
	   updateGraphStats(componentGraph );
	      
        // ✅ Effacer l'ancien graphe et recharger uniquement la composante sélectionnée
        s.graph.clear();  // ✅ Efface complètement le graphe actuel
        s.graph.read(componentGraph);  // ✅ Charge les nouveaux nœuds et arêtes
        s.refresh();  // ✅ Rafraîchir l'affichage pour forcer Sigma.js à afficher les nouvelles données
		
		// ✅ Vérification des nœuds et arêtes après le chargement
		// console.log("📌 Nœuds affichés :", s.graph.nodes().length);
		// console.log("📌 Arêtes affichées :", s.graph.edges().length);
		//console.log("✅ Composante affichée :", s.graph.nodes().length, "nœuds et", s.graph.edges().length, "arêtes");
}
///////////////////FIN affichage des connexes
/////// FIN COMPOSANTES CONNEXES //////////////////////////////////////		
	
	

///////// FONCTION  calcul COMMUNAUTES SUR LE GRAPHE AFFICHÉ //////////
function detectCommunitiesOnCurrentGraph() {
    if (!s || s.graph.nodes().length === 0) {
        showNotification("❌ Aucun graphe affiché pour calculer les communautés !");
        return;
    }

    //  Créer un graphe graphology à partir du graphe affiché
    const graph = new graphology.Graph();

    // Ajouter les nœuds
    s.graph.nodes().forEach(node => {
        graph.addNode(node.id, { label: node.label });
    });

    // Ajouter les arêtes
    s.graph.edges().forEach(edge => {
        if (graph.hasNode(edge.source) && graph.hasNode(edge.target)) {
            graph.addEdge(edge.source, edge.target);
        }
    });
	
	//console.log("📌 Vérification de graphology :", window.graphology); 
	//console.log("📌 Vérification de graphology-communities-louvain :", window.graphologyCommunitiesLouvain);
	//console.log("📌 Propriétés disponibles :", Object.keys(window.graphologyCommunitiesLouvain));


	// Appliquer l'algorithme de Louvain  ///////////////////
		window.graphologyCommunitiesLouvain.assign(graph ,{
			resolution: 1,  // ✅ Augmente la sensibilité au regroupement
			rng: Math.random, // ✅ Randomisation pour éviter les blocages
		});  
	///////////////////////////////////////////////////////////////////////
  
	//  Vérifier après assign() que les communautés sont bien ajoutées dans graph
	//console.log("📌 Communautés détectées A :", Object.fromEntries(s.graph.nodes().map(node => [node.id, node.community])));
		//console.log("📌 Nombre de nœuds dans s.graph avant stockage :", s.graph.nodes().length);
		//console.log("📌 Nombre d’arêtes dans s.graph avant stockage :", s.graph.edges().length);

	//  Vérification détaillée
	const communityData = window.graphologyCommunitiesLouvain.detailed(graph);
	//console.log("📌 Détails des communautés :", communityData);

	//  Récupérer les communautés depuis le graphe
	const communities = {};
	graph.forEachNode((node, attributes) => {
    communities[node] = attributes.community;
	});
	//console.log("📌 Communautés détectées :", communities);

    //  Ajouter la communauté comme attribut de chaque nœud pour Sigma.js
    s.graph.nodes().forEach(node => {
        node.community = communities[node.id] || 0;  //0 si non détecté
    });

    //  Assigner une couleur différente à chaque communauté
    const colorPalette = [
        "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6",
        "#1abc9c", "#e67e22", "#95a5a6", "#34495e", "#8e44ad"
    ];

   s.graph.nodes().forEach(node => {
       node.color = colorPalette[node.community % colorPalette.length] || "#bdc3c7";
    });
		 
    //  Rafraîchir le graphe pour afficher les couleurs des communautés
    s.refresh();
 
	//  Stocker  le graphe avec les communautés et les couleurs dans  storedGraphLouvain
		storedGraphLouvain = { 
		nodes: [...s.graph.nodes()], 
		edges: [...s.graph.edges()] 
		};

	window.graphologyCommunitiesLouvain.assign(graph );

	updateCommunityLegend();  //  Mettre à jour la légende après assignation

	//console.log("📌 Stockage dans storedGraphLouvain (après affectation des  communauté) effectué !", storedGraphLouvain);
	
	//console.log("📌 Nœuds dans le graphe affiché :", s.graph.nodes().length);
	//console.log("📌 Nœuds dans storedGraphLouvain :", storedGraphLouvain.nodes.length);
	//console.log("📌 Arêtes dans storedGraphLouvain :", storedGraphLouvain.edges.length/2);
	//console.log("📌 Vérification des attributs des nœuds dans storedGraphLouvain :",
	// storedGraphLouvain.nodes.map(n => ({ id: n.id, community: n.community }))
	//);

	updateCommunityLegend();  //  Mettre à jour la légende après assignation

	//s.graph.nodes().forEach(node => {
	// if (node.community === 0) {
	//     console.warn(`⚠️ Nœud classé 0 : ${node.id} (degré : ${s.graph.degree(node.id)})`);
	// }
	//});
	
}

// 📌 Associer la fonction au bouton "Communautés"
document.getElementById("detect-communities").addEventListener("click", function() {
    detectCommunitiesOnCurrentGraph();
});

/////////// gérer l’affichage du bouton et réafficher la légende 
document.getElementById("show-legend-btn").addEventListener("click", function() {
    let legendContainer = document.getElementById("community-legend");
    legendContainer.style.display = "block";
    this.style.display = "none"; //  Cacher le bouton après affichage
});

///////////////////////////////////////
   function displayCommunity(communityId) {
   // console.log(`📌 Affichage de la communauté ${communityId}`);

    //  Vérifier que le graphe initial est bien stocké
    if (!storedGraphLouvain) {
        console.error("❌ ERREUR : le graphe n'est pas défini !");
        return;
    }
	
	//console.log("📌 storedGraphLouvain avant filtrage des communautés " ,storedGraphLouvain );
	//console.log("📌 attributs des nœuds dans storedGraphLouvain avant filtrage des communautés",
     storedGraphLouvain.nodes.map(n => ({ id: n.id, community: n.community, color: n.color }));
	//console.log(`📌 Type de communityId :`, typeof communityId, `Valeur :`, communityId);
	//  Afficher un exemple de node pour voir son format exact
	//console.log(`📌 Exemple de nœud dans storedGraphLouvain :`, storedGraphLouvain.nodes[0]);

	communityId = Number(communityId); //  Convertit en nombre 
	
	//  Utiliser le graphe initial pour FILTRER les communautés
    let subGraphNodes = storedGraphLouvain.nodes.filter(node => node.community === communityId);
    let nodeIds = new Set(subGraphNodes.map(n => n.id));  

    //console.log(" Nœuds sélectionnés :", subGraphNodes);

    //  Filtrer les arêtes pour ne conserver que celles entre ces nœuds
    let subGraphEdges = storedGraphLouvain.edges.filter(edge => 
        nodeIds.has(edge.source) && nodeIds.has(edge.target)
    );

	//console.log(`📌 Vérification des nœuds trouvés pour communauté ${communityId} :`,
    subGraphNodes.map(n => ({ id: n.id, community: n.community }));

    //console.log(" Arêtes sélectionnées :", subGraphEdges);

    //  Vérifier que des arêtes existent
    if (subGraphEdges.length === 0) {
        console.warn(`⚠️ Aucun edge trouvé pour la communauté ${communityId}`);
    }
	
	//  Trouver la couleur de la pastille associée à la communauté sélectionnée
	let legendItems = document.querySelectorAll(".legend-item");
	 
	let color = communityColors[communityId] || "#3498db";
	
	legendItems.forEach(item => {
    let label = item.querySelector(".legend-label").textContent;
    if (label.includes(`C${communityId} (`)) {
        color = item.querySelector(".color-dot").style.backgroundColor;
    }
	//console.log(` Couleur détectée pour communauté ${communityId} :`, color);
	//console.log(" Contenu exact des labels :", Array.from(legendItems).map(item =>
	//item.querySelector(".legend-label").textContent
 
});

	//  Appliquer la couleur aux nœuds
	subGraphNodes.forEach(node => {
    node.color = color;
});

    let communityGraph = { nodes: subGraphNodes, edges: subGraphEdges };
	// console.log(`📌 Graphe de la communauté ${communityId} généré :`, communityGraph);
	//console.log(`📌 Couleur assignée à la communauté ${communityId}:`, color);
	//console.log("📌 Nœuds colorés :", subGraphNodes.map(n => ({ id: n.id, color: n.color })));

    //  Afficher uniquement cette communauté
	
	//console.log(`📌 Affichage de la communauté ${communityId} (${subGraphNodes.length} nœuds)`);

	displayGraph(communityGraph); 
	 
}

//////////////////////////////////////// LEGENDE  COMMUNAUTÉS
function updateCommunityLegend() {
    let legendContainer = document.getElementById("community-legend");
	let legendItemsContainer = document.getElementById("legend-items");

//legendItemsContainer.style.columnCount = Math.ceil(connectedComponents.length / 15); // ✅ Ajuste le nombre de colonnes


	//  Afficher la légende lorsqu'on détecte les communautés
    legendContainer.style.display = "block";
	
    // Vider l'ancienne légende
    legendContainer.innerHTML = "<h3>Communautés</h3><div id='community-items'></div>";
	
   legendItemsContainer = document.getElementById("community-items");

    //  Créer les pastilles pour chaque communauté
    let communityCounts = {};  // 📌 Stocke la population de chaque communauté

    storedGraphLouvain.nodes.forEach(node => {
        let communityId = node.community;
        if (!communityCounts[communityId]) communityCounts[communityId] = 0;
        communityCounts[communityId]++;
    });

    Object.entries(communityCounts).forEach(([communityId, count], index) => {
         
let color = getColor(index);
communityColors[communityId] = color; // 🔥 enregistre la couleur

        let legendItem = document.createElement("div");
        legendItem.classList.add("legend-item");
        legendItem.innerHTML = `
            <span class="color-dot" style="background-color: ${color};"></span>
            <span class="legend-label">C${communityId} (${count})</span>
        `;

        legendItem.addEventListener("click", function () {
          //  console.log(`📌 Affichage de la communauté ${communityId} avec ${count} nœuds`);
            displayCommunity(communityId);
        });

        legendItemsContainer.appendChild(legendItem);
    });

    //  Ajuste dynamiquement le nombre de colonnes
    legendItemsContainer.style.columnCount = Math.ceil(Object.keys(communityCounts).length / 15);

    //  Ajouter un bouton pour afficher toutes les communautés
    let showAllButton = document.createElement("button");
    showAllButton.textContent = "TOUTES";
    showAllButton.classList.add("show-all-button");
	
	showAllButton.addEventListener("click", function () {
       // console.log("📌 Affichage de toutes les communautés");
        
		 displayGraph(storedGraphLouvain);
    });
	
	//  Ajouter un bouton pour masquer la légende des communautés
    let hideButton = document.createElement("button");
    hideButton.textContent = "Masquer";
    hideButton.classList.add("hide-legend-button");

    hideButton.addEventListener("click", function () {
        legendContainer.style.display = "none"; //  Cache la légende lorsqu'on clique sur "Masquer"
    });
	

    legendContainer.appendChild(showAllButton);
	legendContainer.appendChild(hideButton);
}
///////// FIN FONCTION POUR APPLIQUER L'ALGORITHME DE LOUVAIN COMMUNAUTES SUR LE GRAPHE AFFICHÉ //////////
	
	
///////////GRAPHE de spatialisation des noeuds FORCEATLAS2 //////////////////  
function startForceAtlas2(data)
{
	s.graph.nodes().forEach(node => {
    if (node.x === undefined || node.y === undefined) {
        console.error(`⚠️ Problème de coordonnées pour le nœud ${node.id} (${node.label})`);
		}
	});	
	
	// repositionememt des nodes avant calcul
	s.graph.nodes().forEach(node => {
		node.x = Math.random();
		node.y = Math.random();
	});

				s.startForceAtlas2({
									worker: true,
									barnesHutOptimize: true,
									barnesHutTheta: 0.5,
									scalingRatio: 2,
									gravity: 4
									});
	// Arrêter ForceAtlas2 après 5 secondes
		setTimeout(() => {
			if (isForceAtlas2Running)
			{
			//console.log("✅ Contenu de s.graph :", s.graph);
			//console.log("✅ Type de s.graph.nodes :", typeof s.graph.nodes, Array.isArray(s.graph.nodes));
			//console.log("✅ Type de s.graph.edges :", typeof s.graph.edges, Array.isArray(s.graph.edges));

			s.stopForceAtlas2();  // fonction defini dans sigmajs
			//console.log('ForceAtlas2 arrêté automatiquement après 5 secondes.');
		
			//console.log("✅ Graphe après ForceAtlas2 :", s.graph);
			//console.log("✅ Type de s.graph.nodes :", typeof s.graph.nodes, Array.isArray(s.graph.nodes));
			//console.log("✅ Type de s.graph.edges :", typeof s.graph.edges, Array.isArray(s.graph.edges));
			
		// ✅ Récupérer le graphe affiché sous forme JSON
        let currentGraph = {
            nodes: [...s.graph.nodes()],
            edges: [...s.graph.edges()]
        };

        // ✅ Réafficher le graphe actuel
		  
		displayGraph(currentGraph , { rescale: false } );
		 
			}
		}, 5000); // 5000 millisecondes = 5 secondes	
		 
	}	 	
///////////FIN graphe de spatialisation Forceatlas2 //////////////////


////   MATRICE BINAIRE

function exportMatrice() {

  // ▶️ Construire liste des adjectifs avec +0 synonymes
 
const synonymEdges = s.graph.edges();


  const synonymMap = new Map();

  synonymEdges.forEach(e => {
    const a = e.source;
    const b = e.target;

    if (!synonymMap.has(a)) synonymMap.set(a, new Set());
    if (!synonymMap.has(b)) synonymMap.set(b, new Set());

    synonymMap.get(a).add(b);
    synonymMap.get(b).add(a);
  });
  
	//console.log("📌 synonymMap :", synonymMap);
	//console.log("📌 Noeuds avec plus de 0 synonymes :", Array.from(synonymMap.entries()).filter(([_, v]) => v.size > 0));

  // ▶️ Ne garder que les adjectifs avec plus de 0 synonymes
  const adjectifs = Array.from(synonymMap.entries())
    .filter(([_, voisins]) => voisins.size > 0)
    .map(([mot]) => mot)
    .sort();

  // ▶️ Matrice binaire
  const matrice = adjectifs.map(a1 =>
    adjectifs.map(a2 => synonymMap.get(a1)?.has(a2) ? 1 : 0)
  );
  
const idToLabel = new Map();
s.graph.nodes().forEach(n => idToLabel.set(n.id, n.label || n.id));

let csv = 'mot,' + adjectifs.map(id => idToLabel.get(id)).join(',') + '\n';

adjectifs.forEach((mot, i) => {
  csv += [idToLabel.get(mot), ...matrice[i]].join(',') + '\n';
});


  // ▶️ Télécharger le fichier CSV
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'matrice_synonymes_filtrée.csv';
  a.click();
  URL.revokeObjectURL(url);

  showNotif("✅ Matrice de synonymie exportée. Fichier CSV dans votre dossier de Téléchargement.");
}
document.getElementById("export-matrix-btn").addEventListener("click", exportMatrice);
////  FIN MATRICE BINAIRE

////MATRICE DES distances
document.getElementById("export-path-btn").addEventListener("click", () => {
  if (!s || s.graph.nodes().length === 0) {
    showNotification("❌ Aucun graphe affiché.");
    return;
  }

  const nodesAffiches = s.graph.nodes();
  const nodeIdsAffiches = nodesAffiches.map(n => n.id);

  // ✅ Construire un graphe complet à partir du graphe initial
  const fullGraph = {};
  storedGraphInitial.nodes.forEach(n => {
    fullGraph[n.id] = [];
  });
  storedGraphInitial.edges.forEach(edge => {
    fullGraph[edge.source].push(edge.target);
    fullGraph[edge.target].push(edge.source); // graphe non orienté
  });

  // ✅ Fonction pour calculer distances depuis un nœud avec BFS
  function calculDistancesDepuis(sourceId) {
    const distances = {};
    const visited = new Set();
    const queue = [[sourceId, 0]];

    while (queue.length > 0) {
      const [current, dist] = queue.shift();
      if (visited.has(current)) continue;
      visited.add(current);
      distances[current] = dist;
      for (let neighbor of fullGraph[current]) {
        if (!visited.has(neighbor)) {
          queue.push([neighbor, dist + 1]);
        }
      }
    }
    return distances;
  }

  // ✅ Calculer distances entre les mots affichés
  const distances = {};
  nodeIdsAffiches.forEach(id => {
    distances[id] = calculDistancesDepuis(id);
  });

  // ✅ Créer un dictionnaire ID → label
  const idToLabel = {};
  nodesAffiches.forEach(n => idToLabel[n.id] = n.label);

  // ✅ Génération CSV avec labels et distances
  let csv = "Label," + nodeIdsAffiches.map(id => `"${idToLabel[id]}"`).join(",") + "\n";
  nodeIdsAffiches.forEach(i => {
    csv += `"${idToLabel[i]}",` +
           nodeIdsAffiches.map(j => {
             if (i === j) return 0;
             return distances[i][j] !== undefined ? distances[i][j] : -1;
           }).join(",") +
           "\n";
  });

  // ✅ Télécharger le fichier
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  link.setAttribute("href", URL.createObjectURL(blob));
  link.setAttribute("download", "matrice_distances.csv");
  link.style.display = "none";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  showNotif ("✅ Matrice des distances exportée. Fichier CSV dans votre dossier de Téléchargement.");
});
//// FIN MATRICE DES distances


///// IMPORTER DES MOTS

// ▶️ Quand on clique sur le bouton, on simule le clic du champ fichier
document.getElementById("btn-importer-mots").addEventListener("click", () => {
    document.getElementById("file-mots-import").click();
});

// ▶️ Quand un fichier est sélectionné
document.getElementById("file-mots-import").addEventListener("change", function (e) {
    const fichier = e.target.files[0];
    if (!fichier) {
        alert("❌ Aucun fichier sélectionné.");
        return;
    }

    importerEtAfficherMotsDepuisCSV(fichier);

    // ✅ Remettre le champ à vide pour autoriser le même fichier une prochaine fois
    this.value = null;
});

function importerEtAfficherMotsDepuisCSV(fichier) {
    const reader = new FileReader();

    reader.onload = function (e) {
        const contenu = e.target.result.trim();

        // 🔍 Extraire les mots importés
        const motsImportés = contenu
            .split(',')
            .map(m => m.trim())
            .filter(m => m.length > 0);

        // ✅ Vérifications de format via le tableau
        if (motsImportés.length === 0) {
            alert("❌ Aucun mot valide détecté dans le fichier. Assurez-vous qu'il contient une seule ligne de mots séparés par des virgules.");
            return;
        }

        // (optionnel) Vérifie s'il y a des sauts de ligne suspects
        if (contenu.includes('\n')) {
            alert("❌ Le fichier semble contenir plusieurs lignes. Seule une ligne de mots séparés par des virgules est attendue.");
            return;
        }

        const nodesToShow = [];
        const motsNonTrouvés = [];
        const labelToNode = {};

        storedGraphInitial.nodes.forEach(node => {
            labelToNode[node.label] = node;
        });

        motsImportés.forEach(mot => {
            const node = labelToNode[mot];
            if (node) {
                nodesToShow.push({ ...node });
            } else {
                motsNonTrouvés.push(mot);
            }
        });

        if (nodesToShow.length === 0) {
            alert("❌ Aucun mot trouvé dans le graphe.");
            return;
        }

        const subgraph = {
            nodes: nodesToShow,
            edges: []
        };

        displayGraph(subgraph);
        showNotification(`✅ ${nodesToShow.length} mot(s) affiché(s).`);

        if (motsNonTrouvés.length > 0) {
            alert("⚠️ Mots non trouvés dans le graphe :\n" + motsNonTrouvés.join(', '));
        }
    };

    reader.readAsText(fichier);

}
///FIN IMPORTER DES MOTS


//// CHEMIN ENTRE 2 MOTS
let modeCheminActif = false;
let selectedNode1 = null;
let grapheAvantChemin = null;
let surlignageActif = null;

document.getElementById("btn-mode-chemin").addEventListener("click", () => {
  modeCheminActif = true;
  selectedNode1 = null;
  //vedette = null;
  document.getElementById("btn-mode-chemin").classList.add("active");
  showNotification("Mode chemin activé : cliquez sur deux mots.");
  console.log("modeCheminActif",modeCheminActif);
});

console.log("modeCheminActif",modeCheminActif);
	s.bind('clickNode', function (e) {
  const clickedNode = e.data.node;

  // ✅ Mode CHEMIN entre deux mots activé
  if (modeCheminActif) {
    if (selectedNode1 && clickedNode.id === selectedNode1.id) {
      selectedNode1 = null;
      s.refresh();
      showNotification("⚠️ Sélection annulée.");
      return;
    }

    if (selectedNode1 && selectedNode1.originalColor)
      selectedNode1.color = selectedNode1.originalColor;

    if (!selectedNode1) {
      if (!clickedNode.originalColor) clickedNode.originalColor = clickedNode.color;
      clickedNode.color = "#FF0000";
      selectedNode1 = clickedNode;
      s.refresh();
      showNotification(`1er mot : <strong>${clickedNode.label}</strong>`);
      return;
    }

    const node1 = selectedNode1;
    const node2 = clickedNode;
    selectedNode1 = null;
    modeCheminActif = false;
    document.getElementById("btn-mode-chemin").classList.remove("active");

    // recherche du chemin dans le graphe affiché
    const chemin = trouverChemin(currentDisplayedGraph, node1.label, node2.label);
	// recherche du chemin dans le graphe initial
    //const chemin = trouverChemin(storedGraphInitial, node1.label, node2.label);
    if (!chemin) {
      showNotification(`❌ Aucun chemin entre <strong>${node1.label}</strong> et <strong>${node2.label}</strong>.`);
      s.refresh();
      return;
    }

    const distance = chemin.length - 1;
    const labels = chemin.map(id => {
      const n = storedGraphInitial.nodes.find(n => n.id === id);
      return n ? n.label : id;
    });

    showNotif(`✅ <strong>Chemin entre ${node1.label} et ${node2.label}</strong>
			(${distance} étape${distance > 1 ? 's' : ''}) :<br>${labels.join(" → ")}`);


   // grapheAvantChemin = JSON.parse(JSON.stringify(currentDisplayedGraph));
    surlignageActif = "chemin";
    afficherCheminDansGraphe(chemin, storedGraphInitial);
  }

  // ✅ Sinon : comportement classique vedette
else {
    // ✅ Clic sur un nœud : Met à jour les infos SEULEMENT si c'est un autre nœud
    s.bind('clickNode', function(e) {
        let node = e.data.node;
		
		vedette = e.data.node ;
		highlightNode(vedette.id);
		
		//console.log("📌 Noeud sélectionné par clic(vedette) :", vedette);
		//console.log("vedette =", vedette, "typeof =", typeof vedette);
		 // ✅ Active les boutons pour générer des sous-graphes
        document.getElementById("show-neighbors-btn").disabled = false;
        document.getElementById("show-syno2-btn").disabled = false;
        document.getElementById("show-adjacency-btn").disabled = false;

        // ✅ Mettre à jour les infos seulement si on clique sur un NOUVEAU nœud
        if (vedette !== node.id) {
            vedette = node;  // ✅ Stocke le nœud sélectionné
            
            var infoText = document.getElementById('info-text');

            var infoHTML = `                        						 
                	<p><strong style="font-size: 20px; font-weight: bold; color:red ">${node.label}</strong></p>	
					<p>Variantes: ${node.variantes?.join(', ') || 'Aucune'}</p>
					<p>Nombre de synonymes: ${node["nombre de synonymes"] || '0'}</p>
					<p>Synonymes: ${node.synonymes?.join(', ') || 'Aucun'}</p>
					<p>Antonymes: ${node.antonymes?.join(', ') || 'Aucun'}</p>
                           
					<p>Cliques: ${node.cliques?.map(clique => clique.join(', ')).join('; ') || 'Aucune'}</p>
					<p>Liste10: ${node.liste10?.map(item => item.map(subItem => subItem.join(': ')).join(', ')).join('; ') || 'Aucune'}</p>
				`;

            infoText.innerHTML = infoHTML;
        }
    });

    // ✅ CLIC DANS LE GRAPHE HORS D'UN NŒUD => Effacer les infos
    s.bind('clickStage', function() {
        vedette = null;  // ✅ Réinitialise la mémoire du dernier nœud
        document.getElementById('info-text').innerHTML = '<p>Survoler ou Cliquez sur un nœud pour voir les données associées.</p><p>Cliquer dans le graphe HORS des nœuds pour les cacher.</p><p>Zoom disponible</p>';
    });
  }
 
});
////FIN  CHEMIN ENTRE 2 MOTS




	
<!-- FIN BOUTONS DE LA GESTION DES GRAPHES  -->


/////////////////////// GESTION DES EVENEMENTS ////////////////////


// ✅ Fonction pour trouver le chemin le plus court entre deux mots dans le graphe
function trouverChemin(graph, sourceLabel, targetLabel) {
  const idLabelMap = {};
  const labelIdMap = {};

  graph.nodes.forEach(n => {
    idLabelMap[n.id] = n.label;
    labelIdMap[n.label] = n.id;
  });

  const sourceId = labelIdMap[sourceLabel];
  const targetId = labelIdMap[targetLabel];

  if (!sourceId || !targetId) return null;

  const visited = new Set();
  const queue = [[sourceId]];

  while (queue.length > 0) {
    const path = queue.shift();
    const current = path[path.length - 1];

    if (current === targetId) return path;

    if (visited.has(current)) continue;
    visited.add(current);

    graph.edges.forEach(edge => {
      if (edge.source === current && !visited.has(edge.target)) {
        queue.push([...path, edge.target]);
      } else if (edge.target === current && !visited.has(edge.source)) {
        queue.push([...path, edge.source]);
      }
    });
  }

  return null;
}

  
/////// Fonction pour gerer le CLIC GAUCHE sur les nœuds
 function ClicNodeEvents(s) {
  s.bind('clickNode', function (e) {
    const clickedNode = e.data.node;

    // ✅ MODE CHEMIN ENTRE 2 MOTS
    if (modeCheminActif) {
      if (selectedNode1 && clickedNode.id === selectedNode1.id) {
        selectedNode1 = null;
        s.refresh();
        showNotification("⚠️ Sélection annulée.");
        return;
      }

      if (selectedNode1 && selectedNode1.originalColor)
        selectedNode1.color = selectedNode1.originalColor;

      if (!selectedNode1) {
        if (!clickedNode.originalColor) clickedNode.originalColor = clickedNode.color;
        clickedNode.color = "#1eff00";
        selectedNode1 = clickedNode;
        s.refresh();
        // ✅ 1er mot sélectionné
		showNotification(`1er mot : <strong>${clickedNode.label}</strong>`);
        return;
      }
	  
	  const node1 = selectedNode1;
      const node2 = clickedNode;
	 node2.color = "#1eff00";
	 s.refresh();
	   // ✅ 2e mot sélectionné
	   showNotification(`2ᵉ mot : <strong>${node2.label}</strong><br>`);
      selectedNode1 = null;
      modeCheminActif = false;
      document.getElementById("btn-mode-chemin").classList.remove("active");

      const chemin = trouverChemin(storedGraphInitial, node1.label, node2.label);
      if (!chemin) {
        showNotification(`❌ Aucun chemin entre <strong>${node1.label}</strong> et <strong>${node2.label}</strong>.`);
        s.refresh();
        return;
      }

//grapheAvantChemin = s.graph.export();  // ✅ juste avant d'afficher les couleurs du chemin


	// ✅ Colorer tous les nœuds du chemin
		chemin.forEach(id => {
		const n = s.graph.nodes(id);
			if (n) {
			if (!n.originalColor) n.originalColor = n.color;
			n.color = "#1bcc53";
			}
		});
		
	// ✅ Colorer les arêtes du chemin  
		for (let i = 0; i < chemin.length - 1; i++) {
		const source = chemin[i];
		const target = chemin[i + 1];

		s.graph.edges().forEach(edge => {
		const match = (edge.source === source && edge.target === target)
               || (edge.source === target && edge.target === source);
			if (match) {
			if (!edge.originalColor) edge.originalColor = edge.color;
			edge.color = "#1bcc53";
			}
		});
}


s.refresh();

      const distance = chemin.length - 1;
      const labels = chemin.map(id => {
        const n = storedGraphInitial.nodes.find(n => n.id === id);
        return n ? n.label : id;
      });

     

showNotif(`✅ <strong>Chemin, dans le graphe complet, entre ${node1.label} et ${node2.label}</strong> (${distance} étape${distance > 1 ? 's' : ''}) :<br>${labels.join(" → ")}`);

      //grapheAvantChemin = s.graph.export();

      surlignageActif = "chemin";
      //afficherCheminDansGraphe(chemin, storedGraphInitial);
      return; // ⛔ on sort : pas de gestion classique dans ce mode
    }

    // ✅ MODE NORMAL — Affichage vedette + infos
    vedette = clickedNode;
    highlightNode(vedette.id);

    document.getElementById("show-neighbors-btn").disabled = false;
    document.getElementById("show-syno2-btn").disabled = false;
    document.getElementById("show-adjacency-btn").disabled = false;

    var infoText = document.getElementById('info-text');
    var infoHTML = `
      <p><strong style="font-size: 20px; font-weight: bold; color:red ">${clickedNode.label}</strong></p>	
      <p>Variantes: ${clickedNode.variantes?.join(', ') || 'Aucune'}</p>
      <p>Nombre de synonymes: ${clickedNode["nombre de synonymes"] || '0'}</p>
      <p>Synonymes: ${clickedNode.synonymes?.join(', ') || 'Aucun'}</p>
      <p>Antonymes: ${clickedNode.antonymes?.join(', ') || 'Aucun'}</p>
      <p>Cliques: ${clickedNode.cliques?.map(clique => clique.join(', ')).join('; ') || 'Aucune'}</p>
      <p>Liste10: ${clickedNode.liste10?.map(item => item.map(subItem => subItem.join(': ')).join(', ')).join('; ') || 'Aucune'}</p>
    `;
    infoText.innerHTML = infoHTML;
  });

  // ✅ CLIC HORS D’UN NŒUD : RESET
  s.bind('clickStage', function () {
    if (surlignageActif === "chemin" && grapheAvantChemin) {
      displayGraph(grapheAvantChemin);
      grapheAvantChemin = null;
    } else {
      s.graph.nodes().forEach(n => {
        if (n.originalColor) n.color = n.originalColor;
      });
      s.graph.edges().forEach(e => {
        if (e.originalColor) e.color = e.originalColor;
      });
      s.refresh();
    }

    modeCheminActif = false;
    selectedNode1 = null;
    vedette = null;
    surlignageActif = null;

    //document.getElementById('btn-mode-chemin').classList.remove('active');
   // document.getElementById('chemin-resultat').innerHTML = '';
    document.getElementById('info-text').innerHTML = `
      <p>Survoler ou Cliquez sur un nœud pour voir les données associées.</p>
      <p>Cliquer dans le graphe HORS des nœuds pour les cacher.</p>
      <p>Zoom disponible</p>
    `;
  });
}

  /////// FIN de la fonction pour gerer les evenements au CLIC GAUCHE des nœuds 
 
 ///gestion du CLIC DROIT SUR UN NOEUD
 function RightClickNodeEvents(s) {
  s.bind('rightClickNode', function (e) {
    const node = e.data.node;
    const nodeId = node.id;

    // ✅ Réinitialiser toutes les couleurs
    s.graph.nodes().forEach(n => {
      n.color = n.originalColor || '#ccc';
    });
    s.graph.edges().forEach(edge => {
      edge.color = edge.originalColor || '#999';
    });

    // ✅ Mettre le nœud cliqué en rouge
    if (!node.originalColor) node.originalColor = node.color;
    node.color = '#FF0000';

    const neighborLabels = new Set(); // 🧠 pour éviter les doublons

    // ✅ Colorer les voisins et les arêtes
    s.graph.edges().forEach(edge => {
      if (edge.source === nodeId || edge.target === nodeId) {
        if (!edge.originalColor) edge.originalColor = edge.color;
        edge.color = '#FF0000';

        const neighborId = edge.source === nodeId ? edge.target : edge.source;
        const neighbor = s.graph.nodes(neighborId);
        if (neighbor) {
          if (!neighbor.originalColor) neighbor.originalColor = neighbor.color;
          neighbor.color = '#FF0000';
          neighborLabels.add(neighbor.label); // ✅ enregistrer le label du voisin
        }
      }
    });

    s.refresh();

    const degree = neighborLabels.size;
    const neighborList = Array.from(neighborLabels).sort().join(", ");

    // ✅ Message enrichi avec la liste des voisins
    showNotif(`<strong>${node.label}</strong> a ${degree} lien(s) dans le graphe affiché.<br><br><em>Liens vers : </em> ${neighborList}`);
  });


  // clic droit hors d’un nœud → réinitialisation
 s.bind('clickStage', function () {
  s.graph.nodes().forEach(n => {
    if (n.originalColor) n.color = n.originalColor;
  });
  s.graph.edges().forEach(e => {
    if (e.originalColor) e.color = e.originalColor;
  });
  s.refresh();
});

}
///FIN gestion du CLIC DROIT SUR UN NOEUD

  
 /////// Fonction pour gerer les evenements SURVOL DES NŒUDS
  function SurvolNoeud(s) {
    s.bind('overNode', function(e) {
    var node = e.data.node;
		
        // ✅ Affichage temporaire dans une info-bulle (tooltip)
        var tooltip = document.getElementById('node-tooltip');
        tooltip.innerHTML = `<strong>${node.label}</strong><br>
                            <p>Nombre de synonymes: ${node["nombre de synonymes"] || '0'}</p>
							<p>Synonymes: ${node.synonymes?.join(', ') || 'Aucun'}</p>`;
							
        tooltip.style.display = "block";
        tooltip.style.left = `${e.data.captor.clientX + 10}px`;
        tooltip.style.top = `${e.data.captor.clientY + 10}px`;
    });

    s.bind('outNode', function() {
        var tooltip = document.getElementById('node-tooltip');
        tooltip.style.display = "none";  // ✅ Cache l'info-bulle quand la souris quitte le nœud
    });
}
 /////// FIN de la fonction pour gerer les evenements SURVOL DES NŒUDS
  
	 

// Charger le graphe lorsque la page est prête
//  window.onload = loadGraph;

 
</script>
<!-- fin du script js----------------------------------------------------------------------------------------------------- -->
  
   
  
</body>
</html>
